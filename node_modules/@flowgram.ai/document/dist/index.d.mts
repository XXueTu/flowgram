import * as _flowgram_ai_utils from '@flowgram.ai/utils';
import { Disposable, Emitter, IPoint, Rectangle, Event, PaddingSchema, SizeSchema as SizeSchema$1, ScrollSchema, PositionSchema as PositionSchema$1, DisposableCollection } from '@flowgram.ai/utils';
import { EntityManager, EntityDataRegistry, EntityData, SizeSchema, TransformData, PositionSchema, EntityOpts, Entity, ConfigEntity, OriginSchema } from '@flowgram.ai/core';
import { ContainerModule } from 'inversify';

/**
 * 存储节点的 tree 结构信息
 * 策略是 "重修改轻查询"，即修改时候做的事情更多，查询都通过指针来操作
 */
declare class FlowVirtualTree<T extends {
    id: string;
}> implements Disposable {
    readonly root: T;
    protected onTreeChangeEmitter: Emitter<void>;
    /**
     * tree 结构变化时候触发
     */
    onTreeChange: _flowgram_ai_utils.Event<void>;
    protected map: Map<T, FlowVirtualTree.NodeInfo<T>>;
    constructor(root: T);
    dispose(): void;
    getInfo(node: T): FlowVirtualTree.NodeInfo<T>;
    clear(): void;
    cloneMap(): Map<T, FlowVirtualTree.NodeInfo<T>>;
    clone(): FlowVirtualTree<T>;
    remove(node: T, withChildren?: boolean): void;
    addChild(parent: T, child: T, index?: number): T;
    moveChilds(parent: T, childs: T[], index?: number): T[];
    getById(id: string): T | undefined;
    /**
     * 插入节点到后边
     * @param before
     * @param after
     */
    insertAfter(before: T, after: T): void;
    removeParent(node: T): void;
    private _removeChildren;
    getParent(node: T): T | undefined;
    getPre(node: T): T | undefined;
    getNext(node: T): T | undefined;
    getChildren(node: T): T[];
    traverse(fn: (node: T, depth: number, index: number) => boolean | void, node?: T, depth?: number, index?: number): boolean | void;
    /**
     * 通知文档树结构更新
     */
    fireTreeChange(): void;
    get size(): number;
    toString(): string;
}
declare namespace FlowVirtualTree {
    interface NodeInfo<T> {
        parent?: T;
        next?: T;
        pre?: T;
        children: T[];
    }
}

/**
 * Render Tree 会只读模式，不具备操作 tree 结构元素
 */
declare class FlowRenderTree<T extends FlowNodeEntity> extends FlowVirtualTree<T> {
    readonly root: T;
    protected originTree: FlowVirtualTree<T>;
    protected document: FlowDocument;
    /**
     * 折叠的节点
     * @protected
     */
    protected nodesCollapsed: Set<T>;
    constructor(root: T, originTree: FlowVirtualTree<T>, document: FlowDocument);
    isCollapsed(node: T): boolean;
    get collapsedNodeList(): T[];
    /**
     * 折叠元素
     * @param node
     * @param collapsed
     */
    setCollapsed(node: T, collapsed: boolean): void;
    /**
     *
     */
    openNodeInsideCollapsed(node: T): void;
    /**
     * 更新结束节点等位置信息，分支里如果全是结束节点则要做相应的偏移
     */
    updateRenderStruct(): void;
    /**
     * 隐藏收起节点
     */
    protected hideCollapsed(): void;
    isNodeEnd(node: T): boolean;
    /**
     * 优化精简分支线
     * - 结束节点拉直分支线
     */
    protected refineBranch(block: T): void;
    protected dragNextNodesToBlock(toBlock: T, next: T): void;
    getInfo(node: T): FlowVirtualTree.NodeInfo<T>;
    getOriginInfo(node: T): FlowVirtualTree.NodeInfo<T>;
    getCollapsedChildren(node: T): T[];
    remove(): void;
    addChild(): T;
    insertAfter(): void;
    removeParent(): void;
}

declare const FlowDocumentOptions: unique symbol;
/**
 * 流程画布配置
 */
interface FlowDocumentOptions {
    /**
     * 布局，默认 垂直布局
     */
    defaultLayout?: string;
    /**
     * 所有节点的默认展开状态
     */
    allNodesDefaultExpanded?: boolean;
    toNodeJSON?(node: FlowNodeEntity): FlowNodeJSON;
    fromNodeJSON?(node: FlowNodeEntity, json: FlowNodeJSON, isFirstCreate: boolean): void;
    constants?: Record<string, any>;
    formatNodeLines?: (node: FlowNodeEntity, lines: FlowTransitionLine[]) => FlowTransitionLine[];
    formatNodeLabels?: (node: FlowNodeEntity, lines: FlowTransitionLabel[]) => FlowTransitionLabel[];
    /**
     * 获取默认的节点配置
     */
    getNodeDefaultRegistry?: (type: FlowNodeType) => FlowNodeRegistry;
}
declare const FlowDocumentOptionsDefault: FlowDocumentOptions;
/**
 * 支持外部 constants 自定义的 key 枚举
 */
declare const ConstantKeys: {
    /**
     * loop 底部留白
     */
    INLINE_SPACING_BOTTOM: string;
    /**
     * inlineBlocks 的 inlineTop
     * loop 循环线条上边距
     */
    INLINE_BLOCKS_INLINE_SPACING_TOP: string;
    /**
     * inlineBlocks 的 inlineBottom
     * loop 循环线条的下边距
     *
     */
    INLINE_BLOCKS_INLINE_SPACING_BOTTOM: string;
    /***
     * 线条、label 默认颜色
     */
    BASE_COLOR: string;
    /***
     * 线条、label 激活后的颜色
     */
    BASE_ACTIVATED_COLOR: string;
    /**
     * Branch bottom margin
     * 分支下边距
     */
    INLINE_BLOCKS_PADDING_TOP: string;
    NODE_SPACING: string;
    ROUNDED_LINE_X_RADIUS: string;
    ROUNDED_LINE_Y_RADIUS: string;
    INLINE_BLOCKS_PADDING_BOTTOM: string;
    COLLAPSED_SPACING: string;
    HOVER_AREA_WIDTH: string;
};

declare const FlowDocumentContribution: unique symbol;
interface FlowDocumentContribution<T extends FlowDocument = FlowDocument> {
    /**
     * 注册
     * @param document
     */
    registerDocument?(document: T): void;
    /**
     * 加载数据
     * @param document
     */
    loadDocument?(document: T): Promise<void>;
}

declare const FlowDocumentConfigDefaultData: unique symbol;
/**
 * 用于文档扩展配置
 */
declare class FlowDocumentConfig {
    private _data;
    private onDataChangeEmitter;
    readonly onChange: _flowgram_ai_utils.Event<string>;
    constructor(_data?: Record<string, any>);
    get(key: string): any;
    set(key: string, value: any): void;
    registerConfigs(config: Record<string, any>): void;
}

type FlowDocumentProvider = () => FlowDocument;
declare const FlowDocumentProvider: unique symbol;
/**
 * 流程整个文档数据
 */
declare class FlowDocument<T = FlowDocumentJSON> implements Disposable {
    protected entityManager: EntityManager;
    readonly config: FlowDocumentConfig;
    /**
     * 流程画布配置项
     */
    options: FlowDocumentOptions;
    protected contributions: FlowDocumentContribution[];
    protected registers: Map<FlowNodeType, FlowNodeRegistry<FlowNodeMeta>>;
    private nodeRegistryCache;
    protected nodeDataRegistries: EntityDataRegistry[];
    protected layouts: FlowLayout[];
    protected currentLayoutKey: string;
    protected onNodeUpdateEmitter: Emitter<{
        node: FlowNodeEntity;
        /**
         * use 'json' instead
         * @deprecated
         */
        data: FlowNodeJSON;
        json: FlowNodeJSON;
    }>;
    protected onNodeCreateEmitter: Emitter<{
        node: FlowNodeEntity;
        /**
         * use 'json' instead
         * @deprecated
         */
        data: FlowNodeJSON;
        json: FlowNodeJSON;
    }>;
    protected onNodeDisposeEmitter: Emitter<{
        node: FlowNodeEntity;
    }>;
    protected onLayoutChangeEmitter: Emitter<FlowLayout>;
    readonly onNodeUpdate: _flowgram_ai_utils.Event<{
        node: FlowNodeEntity;
        /**
         * use 'json' instead
         * @deprecated
         */
        data: FlowNodeJSON;
        json: FlowNodeJSON;
    }>;
    readonly onNodeCreate: _flowgram_ai_utils.Event<{
        node: FlowNodeEntity;
        /**
         * use 'json' instead
         * @deprecated
         */
        data: FlowNodeJSON;
        json: FlowNodeJSON;
    }>;
    readonly onNodeDispose: _flowgram_ai_utils.Event<{
        node: FlowNodeEntity;
    }>;
    readonly onLayoutChange: _flowgram_ai_utils.Event<FlowLayout>;
    private _disposed;
    root: FlowNodeEntity;
    /**
     * 原始的 tree 结构
     */
    originTree: FlowVirtualTree<FlowNodeEntity>;
    transformer: FlowDocumentTransformerEntity;
    /**
     * 渲染相关的全局轧辊台
     */
    renderState: FlowRendererStateEntity;
    /**
     * 渲染后的 tree 结构
     */
    renderTree: FlowRenderTree<FlowNodeEntity>;
    /**
     *
     */
    get disposed(): boolean;
    init(): void;
    /**
     * 从数据初始化 O(n)
     * @param json
     */
    /**
     * 加载数据，可以被重载
     * @param json 文档数据更新
     * @param fireRender 是否要触发渲染，默认 true
     */
    fromJSON(json: FlowDocumentJSON | any, fireRender?: boolean): void;
    get layout(): FlowLayout;
    load(): Promise<void>;
    get loading(): boolean;
    /**
     * 触发 render
     */
    fireRender(): void;
    /**
     * 从指定节点的下一个节点新增
     * @param fromNode
     * @param json
     */
    addFromNode(fromNode: FlowNodeEntity | string, json: FlowNodeJSON): FlowNodeEntity;
    removeNode(node: FlowNodeEntity | string): void;
    /**
     * 添加节点，如果节点已经存在则不会重复创建
     * @param data
     * @param addedNodes
     */
    addNode(data: AddNodeData, addedNodes?: FlowNodeEntity[], ignoreCreateAndUpdateEvent?: boolean, ignoreBlocks?: boolean): FlowNodeEntity;
    addBlocksAsChildren(parent: FlowNodeEntity, blocks: FlowNodeJSON[], addedNodes?: FlowNodeEntity[]): void;
    /**
     * block 格式：
     * node:  (最原始的 id)
     *  blockIcon
     *  inlineBlocks
     *    block
     *      blockOrderIcon
     *    block
     *      blockOrderIcon
     * @param node
     * @param blocks
     * @param addedNodes
     */
    addInlineBlocks(node: FlowNodeEntity, blocks: FlowNodeJSON[], addedNodes?: FlowNodeEntity[]): FlowNodeEntity[];
    /**
     * 添加单个 block
     * @param target
     * @param blockData
     * @param addedNodes
     * @param parent 默认去找 $inlineBlocks$
     */
    addBlock(target: FlowNodeEntity | string, blockData: FlowNodeJSON, addedNodes?: FlowNodeEntity[], parent?: FlowNodeEntity, index?: number): FlowNodeEntity;
    /**
     * 根据 id 获取节点
     * @param id
     */
    getNode(id: string): FlowNodeEntity | undefined;
    /**
     * 注册节点
     * @param registries
     */
    registerFlowNodes<T extends FlowNodeRegistry<any>>(...registries: T[]): void;
    /**
     * Check node extend
     * @param currentType
     * @param parentType
     */
    isExtend(currentType: FlowNodeType, parentType: FlowNodeType): boolean;
    /**
     * 导出数据，可以重载
     */
    toJSON(): T | any;
    /**
     * @deprecated
     * use `getNodeRegistry` instead
     */
    getNodeRegister<T extends FlowNodeRegistry = FlowNodeRegistry>(type: FlowNodeType, originParent?: FlowNodeEntity): T;
    getNodeRegistry<T extends FlowNodeRegistry = FlowNodeRegistry>(type: FlowNodeType, originParent?: FlowNodeEntity): T;
    /**
     * 节点注入数据
     * @param nodeDatas
     */
    registerNodeDatas(...nodeDatas: EntityDataRegistry[]): void;
    /**
     * traverse all nodes, O(n)
     *   R
     *   |
     *   +---1
     *   |   |
     *   |   +---1.1
     *   |   |
     *   |   +---1.2
     *   |   |
     *   |   +---1.3
     *   |   |    |
     *   |   |    +---1.3.1
     *   |   |    |
     *   |   |    +---1.3.2
     *   |   |
     *   |   +---1.4
     *   |
     *   +---2
     *       |
     *       +---2.1
     *
     *  sort: [1, 1.1, 1.2, 1.3, 1.3.1, 1.3.2, 1.4, 2, 2.1]
     * @param fn
     * @param node
     * @param depth
     * @return isBreak
     */
    traverse(fn: (node: FlowNodeEntity, depth: number, index: number) => boolean | void, node?: FlowNodeEntity, depth?: number): boolean | void;
    get size(): number;
    hasNode(nodeId: string): boolean;
    getAllNodes(): FlowNodeEntity[];
    toString(): string;
    /**
     * 返回需要渲染的数据
     */
    getRenderDatas<T extends EntityData>(dataRegistry: EntityDataRegistry<T>, containHiddenNodes?: boolean): T[];
    /**
     * 移动节点
     * @param param0
     * @returns
     */
    moveNodes({ dropNodeId, sortNodeIds, inside, }: {
        dropNodeId: string;
        sortNodeIds: string[];
        inside?: boolean;
    }): void;
    /**
     * 移动子节点
     * @param param0
     * @returns
     */
    moveChildNodes({ toParentId, toIndex, nodeIds, }: {
        toParentId: string;
        nodeIds: string[];
        toIndex: number;
    }): void;
    /**
     * 注册布局
     * @param layout
     */
    registerLayout(layout: FlowLayout): void;
    /**
     * 更新布局
     * @param layoutKey
     */
    setLayout(layoutKey: string): void;
    /**
     * 切换垂直或水平布局
     */
    toggleFixedLayout(): void;
    dispose(): void;
}

interface FlowNodeRenderSchema {
    addable: boolean;
    expandable: boolean;
    collapsed?: boolean;
    expanded: boolean;
    activated: boolean;
    hovered: boolean;
    dragging: boolean;
    stackIndex: number;
    extInfo?: Record<string, any>;
}
/**
 * 节点渲染状态相关数据
 */
declare class FlowNodeRenderData extends EntityData<FlowNodeRenderSchema> {
    static type: string;
    entity: FlowNodeEntity;
    private _node?;
    protected onExtInfoChangeEmitter: Emitter<{
        newInfo: any;
        oldInfo: any;
    }>;
    readonly onExtInfoChange: _flowgram_ai_utils.Event<{
        newInfo: any;
        oldInfo: any;
    }>;
    get key(): string;
    getDefaultData(): FlowNodeRenderSchema;
    updateExtInfo(info: Record<string, any>): void;
    getExtInfo(): Record<string, any> | undefined;
    constructor(entity: FlowNodeEntity);
    get addable(): boolean;
    get expandable(): boolean;
    get draggable(): boolean;
    get expanded(): boolean;
    set expanded(expanded: boolean);
    toggleExpand(): void;
    mouseLeaveTimeout?: ReturnType<typeof setTimeout>;
    toggleMouseEnter(silent?: boolean): void;
    toggleMouseLeave(silent?: boolean): void;
    get hidden(): boolean;
    set hovered(hovered: boolean);
    get hovered(): boolean;
    get dragging(): boolean;
    set dragging(dragging: boolean);
    set activated(activated: boolean);
    get activated(): boolean;
    get stackIndex(): number;
    set stackIndex(index: number);
    get lineActivated(): boolean;
    get node(): HTMLDivElement;
    dispose(): void;
}

interface FlowNodeTransformSchema {
    size: SizeSchema;
}
declare class FlowNodeTransformData extends EntityData<FlowNodeTransformSchema> {
    static type: string;
    entity: FlowNodeEntity;
    transform: TransformData;
    renderState: FlowNodeRenderData;
    localDirty: boolean;
    get origin(): _flowgram_ai_utils.OriginSchema;
    get key(): string;
    getDefaultData(): FlowNodeTransformSchema;
    constructor(entity: FlowNodeEntity);
    /**
     * 获取节点是否展开
     */
    get collapsed(): boolean;
    set collapsed(collapsed: boolean);
    /**
     * 获取节点的大小
     */
    get size(): SizeSchema;
    get position(): PositionSchema;
    set size(size: SizeSchema);
    get inputPoint(): IPoint;
    get defaultInputPoint(): IPoint;
    get defaultOutputPoint(): IPoint;
    get outputPoint(): IPoint;
    /**
     * 原点的最左偏移
     */
    get originDeltaX(): number;
    /**
     * 原点 y 轴偏移
     */
    get originDeltaY(): number;
    /**
     * 绝对坐标 bbox, 不包含自身的 spacing(marginBottom), 但是包含 inlineSpacing 和 子节点的 spacing
     */
    get bounds(): Rectangle;
    get boundsWithPadding(): Rectangle;
    get isContainer(): boolean;
    /**
     * 相对坐标 bbox, 这里的 localBounds 会加入 padding 一起算
     */
    get localBounds(): Rectangle;
    get padding(): _flowgram_ai_utils.PaddingSchema;
    setParentTransform(transform?: FlowNodeTransformData): void;
    get spacing(): number;
    get inlineSpacingPre(): number;
    get inlineSpacingAfter(): number;
    get minInlineBlockSpacing(): number;
    get children(): FlowNodeTransformData[];
    /**
     * 上一个节点的 transform 数据
     */
    get pre(): FlowNodeTransformData | undefined;
    get originParent(): FlowNodeTransformData | undefined;
    get isFirst(): boolean;
    get isLast(): boolean;
    get lastChild(): FlowNodeTransformData | undefined;
    get firstChild(): FlowNodeTransformData | undefined;
    /**
     * 下一个节点的 transform 数据
     */
    get next(): FlowNodeTransformData | undefined;
    /**
     * parent 节点的 transform 数据
     */
    get parent(): FlowNodeTransformData | undefined;
}

interface FlowNodeTransitionSchema {
}
declare const drawLineToNext: (transition: FlowNodeTransitionData) => {
    type: FlowTransitionLineEnum;
    from: _flowgram_ai_utils.IPoint;
    to: _flowgram_ai_utils.IPoint;
}[];
declare const drawLineToBottom: (transition: FlowNodeTransitionData) => {
    type: FlowTransitionLineEnum;
    from: _flowgram_ai_utils.IPoint;
    to: _flowgram_ai_utils.IPoint;
}[];
declare class FlowNodeTransitionData extends EntityData<FlowNodeTransitionSchema> {
    static type: string;
    entity: FlowNodeEntity;
    transform: FlowNodeTransformData;
    renderData: FlowNodeRenderData;
    getDefaultData(): FlowNodeTransitionSchema;
    formatLines(lines: FlowTransitionLine[]): FlowTransitionLine[];
    formatLabels(labels: FlowTransitionLabel[]): FlowTransitionLabel[];
    get lines(): FlowTransitionLine[];
    get labels(): FlowTransitionLabel[];
    constructor(entity: FlowNodeEntity);
    get collapsed(): boolean;
    get isNodeEnd(): boolean;
}

interface FlowNodeEntityConfig extends EntityOpts {
    document: FlowDocument;
    flowNodeType: FlowNodeType;
    originParent?: FlowNodeEntity;
    meta?: FlowNodeMeta;
}
interface FlowNodeInitData {
    originParent?: FlowNodeEntity;
    parent?: FlowNodeEntity;
    hidden?: boolean;
    meta?: FlowNodeMeta;
    index?: number;
}
declare class FlowNodeEntity extends Entity<FlowNodeEntityConfig> {
    private _memoLocalCache;
    private _memoGlobalCache;
    static type: string;
    private _registerCache?;
    private _metaCache?;
    metaFromJSON?: FlowNodeMeta;
    /**
     * 真实的父节点，条件块在内部会创建一些空的块节点，这些块需要关联它真实的父亲节点
     */
    originParent?: FlowNodeEntity;
    flowNodeType: FlowNodeType;
    /**
     * 是否隐藏
     */
    private _hidden;
    index: number;
    /**
     * 文档引用
     */
    document: FlowDocument;
    constructor(conf: FlowNodeEntityConfig);
    initData(initConf: FlowNodeInitData): void;
    get isStart(): boolean;
    get isFirst(): boolean;
    get isLast(): boolean;
    /**
     * 子节点采用水平布局
     */
    get isInlineBlocks(): boolean;
    /**
     * 水平节点
     */
    get isInlineBlock(): boolean;
    /**
     * 节点结束标记
     * - 当前节点是结束节点
     * - 当前节点最后一个节点包含结束标记
     * - 当前节点为 inlineBlock，每一个 block 包含结束标记
     *
     * 由子元素确定，因此使用 memoLocal
     */
    get isNodeEnd(): boolean;
    /**
     * 添加 子节点
     *
     * @param child 插入节点
     */
    addChild(child: FlowNodeEntity, index?: number): void;
    get hasChild(): boolean;
    get pre(): FlowNodeEntity | undefined;
    get next(): FlowNodeEntity | undefined;
    get parent(): FlowNodeEntity | undefined;
    getNodeRegistry<M extends FlowNodeRegistry = FlowNodeRegistry>(): M;
    /**
     * @deprecated
     * use getNodeRegistry instead
     */
    getNodeRegister<M extends FlowNodeRegistry = FlowNodeRegistry>(): M;
    getNodeMeta<M extends FlowNodeMeta = FlowNodeMeta>(): M & Required<FlowNodeMeta>;
    /**
     * 获取所有子节点，包含 child 及其所有兄弟节点
     */
    get allChildren(): FlowNodeEntity[];
    /**
     * 获取所有收起的子节点，包含 child 及其所有兄弟节点
     */
    get allCollapsedChildren(): FlowNodeEntity[];
    /**
     *
     * Get child blocks
     *
     * use `blocks` instead
     * @deprecated
     */
    get collapsedChildren(): FlowNodeEntity[];
    /**
     * Get child blocks
     */
    get blocks(): FlowNodeEntity[];
    /**
     * Get last block
     */
    get lastBlock(): FlowNodeEntity | undefined;
    /**
     * use `lastBlock` instead
     */
    get lastCollapsedChild(): FlowNodeEntity | undefined;
    /**
     * 获取子节点，如果子节点收起来，则会返回 空数组
     */
    get children(): FlowNodeEntity[];
    get lastChild(): FlowNodeEntity | undefined;
    get firstChild(): FlowNodeEntity | undefined;
    memoLocal<T>(key: string, fn: () => T): T;
    memoGlobal<T>(key: string, fn: () => T): T;
    clearMemoGlobal(): void;
    clearMemoLocal(): void;
    get childrenLength(): number;
    get collapsed(): boolean;
    set collapsed(collapsed: boolean);
    get hidden(): boolean;
    openInsideCollapsed(): void;
    /**
     * 可以重载
     */
    getJSONData(): any;
    /**
     * 生成 JSON
     * @param newId
     */
    toJSON(): FlowNodeJSON;
    get isVertical(): boolean;
    /**
     * 修改节点扩展信息
     * @param info
     */
    updateExtInfo<T extends Record<string, any> = Record<string, any>>(extInfo: T): void;
    /**
     * 获取节点扩展信息
     */
    getExtInfo<T extends Record<string, any> = Record<string, any>>(): T;
    get onExtInfoChange(): Event<{
        newInfo: any;
        oldInfo: any;
    }>;
    /**
     * 获取渲染数据
     */
    get renderData(): FlowNodeRenderData;
    /**
     * 获取位置大小数据
     */
    get transform(): FlowNodeTransformData;
    /**
     * 获取节点的位置及大小矩形
     */
    get bounds(): Rectangle;
}
declare namespace FlowNodeEntity {
    function is(obj: Entity): obj is FlowNodeEntity;
}

interface FlowDocumentTransformerEntityConfig extends EntityOpts {
    document: FlowDocument;
}
/**
 * 用于通知所有 layer 更新
 */
declare class FlowDocumentTransformerEntity extends ConfigEntity<{
    loading: boolean;
    treeVersion: number;
}, FlowDocumentTransformerEntityConfig> {
    static type: string;
    protected onRefreshEmitter: Emitter<void>;
    protected lastTransformVersion: number;
    protected lastTreeVersion: number;
    document: FlowDocument;
    readonly onRefresh: _flowgram_ai_utils.Event<void>;
    constructor(conf: FlowDocumentTransformerEntityConfig);
    getDefaultConfig(): {
        loading: boolean;
        treeVersion: number;
    };
    get loading(): boolean;
    set loading(loading: boolean);
    /**
     * 更新矩阵结构 (这个只有在树结构变化时候才会触发，如：添加节点、删除节点、改变位置节点)
     */
    updateTransformsTree(): void;
    clear(): void;
    isTreeDirty(): boolean;
    /**
     * 刷新节点的相对偏移
     */
    refresh(): void;
}

interface FlowRendererStateEntityConfig extends EntityOpts {
}
interface FlowRendererState {
    nodeHoveredId?: string;
    nodeDroppingId?: string;
    nodeDragStartId?: string;
    nodeDragIds?: string[];
    nodeDragIdsWithChildren?: string[];
    dragLabelSide?: LABEL_SIDE_TYPE;
}
/**
 * 渲染相关的全局状态管理
 */
declare class FlowRendererStateEntity extends ConfigEntity<FlowRendererState, FlowRendererStateEntityConfig> {
    static type: string;
    getDefaultConfig(): {};
    constructor(conf: FlowRendererStateEntityConfig);
    getNodeHovered(): FlowNodeEntity | undefined;
    setNodeHovered(node: FlowNodeEntity | undefined): void;
    getDragLabelSide(): LABEL_SIDE_TYPE | undefined;
    setDragLabelSide(dragLabelSide?: LABEL_SIDE_TYPE): void;
    getNodeDroppingId(): string | undefined;
    setNodeDroppingId(nodeDroppingId?: string): void;
    getDragStartEntity(): FlowNodeEntity | undefined;
    setDragStartEntity(node?: FlowNodeEntity): void;
    getDragEntities(): FlowNodeEntity[];
    setDragEntities(nodes: FlowNodeEntity[]): void;
    onNodeHoveredChange(fn: (hoveredNode: FlowNodeEntity | undefined) => void, debounceTime?: number): Disposable;
}

declare enum FlowTransitionLineEnum {
    STRAIGHT_LINE = 0,
    DIVERGE_LINE = 1,
    MERGE_LINE = 2,
    ROUNDED_LINE = 3,
    CUSTOM_LINE = 4,
    DRAGGING_LINE = 5
}
interface Vertex extends IPoint {
    radiusX?: number;
    radiusY?: number;
    moveX?: number;
    moveY?: number;
}
interface FlowTransitionLine {
    type: FlowTransitionLineEnum;
    from: IPoint;
    to: IPoint;
    vertices?: Vertex[];
    arrow?: boolean;
    renderKey?: string;
    isHorizontal?: boolean;
    isDraggingLine?: boolean;
    activated?: boolean;
    side?: LABEL_SIDE_TYPE;
    style?: React.CSSProperties;
    lineId?: string;
}
declare enum FlowTransitionLabelEnum {
    ADDER_LABEL = 0,
    TEXT_LABEL = 1,
    COLLAPSE_LABEL = 2,
    COLLAPSE_ADDER_LABEL = 3,
    CUSTOM_LABEL = 4,
    BRANCH_DRAGGING_LABEL = 5
}
interface FlowTransitionLabel {
    type: FlowTransitionLabelEnum;
    renderKey?: string;
    offset: IPoint;
    width?: number;
    rotate?: string;
    props?: Record<string, any>;
    labelId?: string;
}
interface AdderProps {
    node: FlowNodeEntity;
    from: FlowNodeEntity;
    to: FlowNodeEntity;
    renderTo: FlowNodeEntity;
    [key: string]: any;
}
interface CollapseProps {
    node: FlowNodeEntity;
    collapseNode: FlowNodeEntity;
    activateNode?: FlowNodeEntity;
    forceVisible?: boolean;
    [key: string]: any;
}
interface CustomLabelProps {
    node: FlowNodeEntity;
    [key: string]: any;
}
interface CollapseAdderProps extends AdderProps, CollapseProps {
    [key: string]: any;
}
interface DragNodeProps {
    node: FlowNodeEntity;
}

declare enum FlowLayoutDefault {
    VERTICAL_FIXED_LAYOUT = "vertical-fixed-layout",
    HORIZONTAL_FIXED_LAYOUT = "horizontal-fixed-layout"
}
declare namespace FlowLayoutDefault {
    function isVertical(layout: FlowLayout): boolean;
}
declare const FlowLayoutContribution: unique symbol;
interface FlowLayoutContribution {
    onAfterUpdateLocalTransform?: (transform: FlowNodeTransformData, layout: FlowLayout) => void;
}
declare const FlowLayout: unique symbol;
/**
 * 流程布局算法
 */
interface FlowLayout {
    /**
     * 布局名字
     */
    name: string;
    /**
     * 布局切换时候触发
     */
    reload?(): void;
    /**
     * 更新布局
     */
    update(): void;
    /**
     * 获取节点的 padding 数据
     * @param node
     */
    getPadding(node: FlowNodeEntity): PaddingSchema;
    /**
     * 获取默认滚动 目前用在 scroll-limit-layer
     * @param contentSize
     */
    getInitScroll(contentSize: SizeSchema$1): ScrollSchema;
    /**
     * 获取默认输入点
     */
    getDefaultInputPoint(node: FlowNodeEntity): IPoint;
    /**
     * 获取默认输出点
     */
    getDefaultOutputPoint(node: FlowNodeEntity): IPoint;
    /**
     * 获取默认远点
     */
    getDefaultNodeOrigin(): IPoint;
}

/**
 * 节点渲染相关配置信息，可扩展
 */
interface FlowNodeMeta {
    isStart?: boolean;
    addable?: boolean;
    expandable?: boolean;
    draggable?: boolean | ((node: FlowNodeEntity) => boolean);
    selectable?: boolean | ((node: FlowNodeEntity, mousePos?: PositionSchema$1) => boolean);
    deleteDisable?: boolean;
    copyDisable?: boolean;
    addDisable?: boolean;
    hidden?: boolean;
    size?: SizeSchema;
    /**
     * @deprecated 使用 NodeRegister.getOrigin 代替
     */
    origin?: OriginSchema;
    defaultExpanded?: boolean;
    defaultCollapsed?: boolean;
    expandedSize?: SizeSchema;
    spacing?: number | ((transform: FlowNodeTransformData) => number);
    padding?: PaddingSchema | ((transform: FlowNodeTransformData) => PaddingSchema);
    inlineSpacingPre?: number | ((transform: FlowNodeTransformData) => number);
    inlineSpacingAfter?: number | ((transform: FlowNodeTransformData) => number);
    renderKey?: string;
    isInlineBlocks?: boolean | ((node: FlowNodeEntity) => boolean);
    minInlineBlockSpacing?: number | ((node: FlowNodeTransformData) => number);
    isNodeEnd?: boolean;
    [key: string]: any;
}
/**
 * spacing default key 值
 */
declare const DefaultSpacingKey: {
    /**
     * 普通节点间距。垂直 / 水平
     */
    NODE_SPACING: string;
    /**
     * 圆弧线条 x radius
     */
    ROUNDED_LINE_X_RADIUS: string;
    /**
     * 圆弧线条 y radius
     */
    ROUNDED_LINE_Y_RADIUS: string;
    /**
     * dynamicSplit block list 下部留白间距，因为有两个拐弯，所以翻一倍
     */
    INLINE_BLOCKS_PADDING_BOTTOM: string;
    /**
     * 复合节点距离上个节点的距离
     * 条件分支菱形下边和分支的距离
     */
    COLLAPSED_SPACING: string;
    /**
     * width of hover area
     */
    HOVER_AREA_WIDTH: string;
};
/**
 * 默认一些间隔参数
 */
declare const DEFAULT_SPACING: {
    [x: string]: number;
    NULL: number;
    MARGIN_RIGHT: number;
    INLINE_BLOCK_PADDING_BOTTOM: number;
    INLINE_BLOCKS_PADDING_TOP: number;
    MIN_INLINE_BLOCK_SPACING: number;
    MIN_INLINE_BLOCK_SPACING_HORIZONTAL: number;
};
/**
 * 拖拽种类枚举
 * 1. 节点拖拽
 * 2. 分支拖拽
 */
declare enum DRAGGING_TYPE {
    NODE = "node",
    BRANCH = "branch"
}
/**
 * 拖拽分支 Adder、Line 类型
 */
declare enum LABEL_SIDE_TYPE {
    PRE_BRANCH = "pre_branch",
    NORMAL_BRANCH = "normal_branch"
}
/**
 * 默认节点大小
 */
declare const DEFAULT_SIZE: {
    width: number;
    height: number;
};
/**
 * 默认 meta 配置
 */
declare const DEFAULT_FLOW_NODE_META: (nodeType: FlowNodeType, document: FlowDocument) => FlowNodeMeta;
/**
 * 节点注册
 */
interface FlowNodeRegistry<M extends FlowNodeMeta = FlowNodeMeta> {
    /**
     * 从另外一个注册扩展
     */
    extend?: string;
    /**
     * 节点类型
     */
    type: FlowNodeType;
    /**
     * 节点注册的数据，可以理解为 ECS 里的 Component, 这里可以配置自定义数据
     */
    dataRegistries?: EntityDataRegistry[];
    /**
     * 节点画布相关初始化配置信息，会覆盖 DEFAULT_FLOW_NODE_META
     */
    meta?: Partial<M>;
    /**
     * 自定义创建节点，可以自定义节点的树形结构
     * 返回新加入的节点，这样才能统计缓存
     *
     * @action 使用该方法，在创建时候将会忽略 json blocks 数据，而是交给适用节点自己处理 json 逻辑
     */
    onCreate?: (node: FlowNodeEntity, json: FlowNodeJSON) => FlowNodeEntity[] | void;
    /**
     * 添加子 block，一般用于分支的动态添加
     */
    onBlockChildCreate?: (node: FlowNodeEntity, json: FlowNodeJSON, addedNodes?: FlowNodeEntity[]) => FlowNodeEntity;
    /**
     * 创建线条
     */
    getLines?: (transition: FlowNodeTransitionData, layout: FlowLayout) => FlowTransitionLine[];
    /**
     * 创建 label
     */
    getLabels?: (transition: FlowNodeTransitionData, layout: FlowLayout) => FlowTransitionLabel[];
    /**
     * 调整子节点的线条，优先级高于子节点本身的 getLines
     */
    getChildLines?: (transition: FlowNodeTransitionData, layout: FlowLayout) => FlowTransitionLine[];
    /**
     * 调整子节点的 Labels，优先级高于子节点本身的 getLabels
     */
    getChildLabels?: (transition: FlowNodeTransitionData, layout: FlowLayout) => FlowTransitionLabel[];
    /**
     * 自定义输入节点
     */
    getInputPoint?: (transform: FlowNodeTransformData, layout: FlowLayout) => IPoint;
    /**
     * 自定义输出节点
     */
    getOutputPoint?: (transform: FlowNodeTransformData, layoutKey: FlowLayout) => IPoint;
    /**
     *  获取当前节点 Position 偏移量，偏移量计算只能使用已经计算完的数据，如上一个节点或者子节点，不然会造成 o(n^2) 复杂度
     *
     *  1. 切记不要用当前节点的 localBounds(相对位置 bbox)，因为 delta 计算发生在 localBounds 计算之前
     *  2. 切记不要用 bounds(绝对位置 bbox, 会触发所有父节点绝对位置计算), bounds 只能在最终 render 时候使用
     *  3. 可以用 pre 节点 和 子节点的 localBounds 或者 size 数据，因为子节点是先算的
     *  4. 可以用当前节点的 size (所有子节点的最大 bbox), 这是已经确定下来的
     */
    getDelta?: (transform: FlowNodeTransformData, layout: FlowLayout) => IPoint | undefined;
    /**
     * 动态获取原点，会覆盖 meta.origin
     */
    getOrigin?(transform: FlowNodeTransformData, layout: FlowLayout): IPoint;
    /**
     * 原点 X 偏移
     * @param transform
     */
    getOriginDeltaX?: (transform: FlowNodeTransformData, layout: FlowLayout) => number;
    /**
     * 原点 Y 偏移
     * @param transform
     */
    getOriginDeltaY?: (transform: FlowNodeTransformData, layout: FlowLayout) => number;
    /**
     * 通过 parent 计算当前节点的偏移，规则同 getDelta
     */
    getChildDelta?: (childBlock: FlowNodeTransformData, layout: FlowLayout) => IPoint | undefined;
    /**
     * 在当前节点布局完成后调用，可以对布局做更精细的调整
     */
    onAfterUpdateLocalTransform?: (transform: FlowNodeTransformData, layout: FlowLayout) => void;
    /**
     * 子节点的 registry 覆盖，这里通过 originParent 来查找
     */
    extendChildRegistries?: FlowNodeRegistry[];
    /**
     * 自定义子节点添加逻辑
     * @param node 节点
     * @param json 添加的节点 JSON
     * @param options 其它配置
     * @returns
     */
    addChild?: (node: FlowNodeEntity, json: FlowNodeJSON, options?: {
        hidden?: boolean;
        index?: number;
    }) => FlowNodeEntity;
    /**
     * 内部用于继承逻辑判断，不要使用
     */
    __extends__?: FlowNodeType[];
    /**
     * 扩展注册器
     */
    [key: string]: any;
}
declare namespace FlowNodeRegistry {
    function mergeChildRegistries(r1?: FlowNodeRegistry[], r2?: FlowNodeRegistry[]): FlowNodeRegistry[];
    function merge(registry1: FlowNodeRegistry, registry2: FlowNodeRegistry, finalType: FlowNodeType): FlowNodeRegistry;
    function extend(registry: FlowNodeRegistry, extendRegistries: FlowNodeRegistry[]): FlowNodeRegistry;
}

type FlowNodeType = string | number;
/**
 * Flow node json data
 */
interface FlowNodeJSON {
    id: string;
    type?: FlowNodeBaseType | FlowNodeSplitType | FlowNodeType;
    data?: Record<string, any>;
    meta?: FlowNodeMeta;
    blocks?: FlowNodeJSON[];
}
type FlowDocumentJSON = {
    nodes: FlowNodeJSON[];
};
declare enum FlowNodeBaseType {
    START = "start",
    DEFAULT = "default",
    ROOT = "root",
    EMPTY = "empty",
    INLINE_BLOCKS = "inlineBlocks",
    BLOCK_ICON = "blockIcon",
    BLOCK = "block",
    BLOCK_ORDER_ICON = "blockOrderIcon",
    GROUP = "group",
    END = "end",
    BREAK = "break",
    CONDITION = "condition",
    SUB_CANVAS = "subCanvas",
    MULTI_INPUTS = "multiInputs",
    MULTI_OUTPUTS = "multiOutputs",
    INPUT = "input",
    OUTPUT = "output"
}
declare enum FlowNodeSplitType {
    SIMPLE_SPLIT = "simpleSplit",
    DYNAMIC_SPLIT = "dynamicSplit",
    STATIC_SPLIT = "staticSplit"
}
declare enum FlowDocumentConfigEnum {
    END_NODES_REFINE_BRANCH = "END_NODES_REFINE_BRANCH"
}
declare const FLOW_DEFAULT_HIDDEN_TYPES: FlowNodeType[];
type AddNodeData = FlowNodeJSON & {
    originParent?: FlowNodeEntity;
    parent?: FlowNodeEntity;
    hidden?: boolean;
    index?: number;
};

declare enum OperationType {
    addFromNode = "addFromNode",
    deleteFromNode = "deleteFromNode",
    addBlock = "addBlock",
    deleteBlock = "deleteBlock",
    createGroup = "createGroup",
    ungroup = "ungroup",
    moveNodes = "moveNodes",
    moveBlock = "moveBlock",
    moveChildNodes = "moveChildNodes",
    addNodes = "addNodes",
    deleteNodes = "deleteNodes",
    changeNode = "changeNode",
    addChildNode = "addChildNode",
    deleteChildNode = "deleteChildNode",
    addNode = "addNode",
    deleteNode = "deleteNode"
}
interface AddOrDeleteFromNodeOperationValue {
    fromId: string;
    data: FlowNodeJSON;
}
interface AddOrDeleteNodeOperationValue {
    fromId: string;
    data: FlowNodeJSON;
}
interface AddFromNodeOperation {
    type: OperationType.addFromNode;
    value: AddOrDeleteFromNodeOperationValue;
}
interface DeleteFromNodeOperation {
    type: OperationType.deleteFromNode;
    value: AddOrDeleteFromNodeOperationValue;
}
interface AddOrDeleteBlockValue {
    targetId: string;
    index?: number;
    blockData: FlowNodeJSON;
    parentId?: string;
}
interface createOrUngroupValue {
    targetId: string;
    groupId: string;
    nodeIds: string[];
}
interface AddBlockOperation {
    type: OperationType.addBlock;
    value: AddOrDeleteBlockValue;
}
interface DeleteBlockOperation {
    type: OperationType.deleteBlock;
    value: AddOrDeleteBlockValue;
}
interface CreateGroupOperation {
    type: OperationType.createGroup;
    value: createOrUngroupValue;
}
interface UngroupOperation {
    type: OperationType.ungroup;
    value: createOrUngroupValue;
}
interface MoveNodesOperationValue {
    fromId: string;
    toId: string;
    nodeIds: string[];
}
interface MoveNodesOperation {
    type: OperationType.moveNodes;
    value: MoveNodesOperationValue;
}
interface AddOrDeleteNodesOperationValue {
    fromId: string;
    nodes: FlowNodeJSON[];
}
interface AddNodesOperation {
    type: OperationType.addNodes;
    value: AddOrDeleteNodesOperationValue;
}
interface DeleteNodesOperation {
    type: OperationType.deleteNodes;
    value: AddOrDeleteNodesOperationValue;
}
interface ChangeNodeOperationValue {
    id: string;
    path: string;
    oldValue: any;
    value: any;
}
interface ChangeNodeOperation {
    type: OperationType.changeNode;
    value: ChangeNodeOperationValue;
}
interface MoveChildNodesOperationValue {
    nodeIds: string[];
    fromParentId: string;
    fromIndex: number;
    toParentId: string;
    toIndex: number;
}
type MoveBlockOperationValue = {
    nodeId: string;
    fromParentId: string;
    fromIndex: number;
    toParentId: string;
    toIndex: number;
};
interface MoveBlockOperation {
    type: OperationType.moveBlock;
    value: MoveBlockOperationValue;
}
interface MoveChildNodesOperation {
    type: OperationType.moveChildNodes;
    value: MoveChildNodesOperationValue;
}
interface AddChildNodeOperation {
    type: OperationType.addChildNode;
    value: AddOrDeleteChildNodeValue;
}
interface DeleteChildNodeOperation {
    type: OperationType.deleteChildNode;
    value: AddOrDeleteChildNodeValue;
}
interface AddOrDeleteChildNodeValue {
    data: FlowNodeJSON;
    parentId?: string;
    index?: number;
    originParentId?: string;
    hidden?: boolean;
}
interface AddNodeOperation {
    type: OperationType.addNode;
    value: AddOrDeleteNodeValue;
}
interface DeleteNodeOperation {
    type: OperationType.deleteNode;
    value: AddOrDeleteNodeValue;
}
interface AddOrDeleteNodeValue {
    data: FlowNodeJSON;
    parentId?: string;
    index?: number;
    hidden?: boolean;
}
type FlowOperation = AddFromNodeOperation | DeleteFromNodeOperation | AddBlockOperation | DeleteBlockOperation | CreateGroupOperation | UngroupOperation | MoveNodesOperation | AddNodesOperation | DeleteNodesOperation | ChangeNodeOperation | MoveBlockOperation | AddChildNodeOperation | DeleteChildNodeOperation | MoveChildNodesOperation | AddNodeOperation | DeleteNodeOperation;
type FlowNodeEntityOrId = string | FlowNodeEntity;
type AddNodeConfig = {
    parent?: FlowNodeEntityOrId;
    hidden?: boolean;
    index?: number;
};
/**
 * 添加block时的配置
 */
interface AddBlockConfig {
    parent?: FlowNodeEntity;
    index?: number;
}
/**
 * 移动节点时的配置
 */
interface MoveNodeConfig {
    parent?: FlowNodeEntityOrId;
    index?: number;
}
/**
 * 节点添加事件
 */
interface OnNodeAddEvent {
    node: FlowNodeEntity;
    data: AddNodeData;
}
/**
 * 节点移动事件
 */
interface OnNodeMoveEvent {
    node: FlowNodeEntity;
    fromParent: FlowNodeEntity;
    fromIndex: number;
    toParent: FlowNodeEntity;
    toIndex: number;
}
interface FlowOperationBaseService extends Disposable {
    /**
     * 执行操作
     * @param operation 可序列化的操作
     * @returns 操作返回
     */
    apply(operation: FlowOperation): any;
    /**
     * 添加节点，如果节点已经存在则不会重复创建
     * @param nodeJSON 节点数据
     * @param config 配置
     * @returns 成功添加的节点
     */
    addNode(nodeJSON: FlowNodeJSON, config?: AddNodeConfig): FlowNodeEntity;
    /**
     * 基于某一个起始节点往后面添加
     * @param fromNode 起始节点
     * @param nodeJSON 添加的节点JSON
     */
    addFromNode(fromNode: FlowNodeEntityOrId, nodeJSON: FlowNodeJSON): FlowNodeEntity;
    /**
     * 删除节点
     * @param node 节点
     * @returns
     */
    deleteNode(node: FlowNodeEntityOrId): void;
    /**
     * 批量删除节点
     * @param nodes
     */
    deleteNodes(nodes: FlowNodeEntityOrId[]): void;
    /**
     * 添加块（分支）
     * @param target 目标
     * @param blockJSON 块数据
     * @param config 配置
     * @returns
     */
    addBlock(target: FlowNodeEntityOrId, blockJSON: FlowNodeJSON, config?: AddBlockConfig): FlowNodeEntity;
    /**
     * 移动节点
     * @param node 被移动的节点
     * @param config 移动节点配置
     */
    moveNode(node: FlowNodeEntityOrId, config?: MoveNodeConfig): void;
    /**
     * 拖拽节点
     * @param param0
     * @returns
     */
    dragNodes({ dropNode, nodes }: {
        dropNode: FlowNodeEntity;
        nodes: FlowNodeEntity[];
    }): void;
    /**
     * 添加节点的回调
     */
    onNodeAdd: Event<OnNodeAddEvent>;
    /**
     * 节点移动的回调
     */
    onNodeMove: Event<OnNodeMoveEvent>;
}
declare const FlowOperationBaseService: unique symbol;

interface FlowGroupJSON {
    nodeIDs: string[];
}

declare const FlowDocumentContainerModule: ContainerModule;

/**
 * 拖拽相关操作
 * 外部实现抽象类
 */
declare class FlowDragService {
    protected document: FlowDocument;
    protected operationService: FlowOperationBaseService;
    protected entityManager: EntityManager;
    protected onDropEmitter: Emitter<{
        dropNode: FlowNodeEntity;
        dragNodes: FlowNodeEntity[];
    }>;
    readonly onDrop: _flowgram_ai_utils.Event<{
        dropNode: FlowNodeEntity;
        dragNodes: FlowNodeEntity[];
    }>;
    get renderState(): FlowRendererStateEntity;
    get dragStartNode(): FlowNodeEntity;
    get dragNodes(): FlowNodeEntity[];
    get dropNodeId(): string | undefined;
    get isDragBranch(): boolean;
    get nodeDragIdsWithChildren(): string[];
    get dragging(): boolean;
    get labelSide(): LABEL_SIDE_TYPE | undefined;
    /**
     * 放置到目标分支
     */
    dropBranch(): void;
    /**
     * 移动到目标节点
     */
    dropNode(): void;
    /**
     * 拖拽是否可以释放在该节点后面
     */
    isDroppableNode(node: FlowNodeEntity): boolean;
    /**
     * 拖拽分支是否可以释放在该分支
     * @param node 拖拽的分支节点
     * @param side 分支的前面还是后面
     */
    isDroppableBranch(node: FlowNodeEntity, side?: LABEL_SIDE_TYPE): boolean;
}

/**
 * 操作服务
 */
declare class FlowOperationBaseServiceImpl implements FlowOperationBaseService {
    protected entityManager: EntityManager;
    protected document: FlowDocument;
    protected onNodeAddEmitter: Emitter<OnNodeAddEvent>;
    readonly onNodeAdd: _flowgram_ai_utils.Event<OnNodeAddEvent>;
    protected toDispose: DisposableCollection;
    private onNodeMoveEmitter;
    readonly onNodeMove: _flowgram_ai_utils.Event<OnNodeMoveEvent>;
    protected init(): void;
    addNode(nodeJSON: FlowNodeJSON, config?: AddNodeConfig): FlowNodeEntity;
    addFromNode(fromNode: FlowNodeEntityOrId, nodeJSON: FlowNodeJSON): FlowNodeEntity;
    deleteNode(node: FlowNodeEntityOrId): void;
    deleteNodes(nodes: FlowNodeEntityOrId[]): void;
    addBlock(target: FlowNodeEntityOrId, blockJSON: FlowNodeJSON, config?: AddBlockConfig): FlowNodeEntity;
    moveNode(node: FlowNodeEntityOrId, config?: MoveNodeConfig): void;
    /**
     * 拖拽节点
     * @param param0
     * @returns
     */
    dragNodes({ dropNode, nodes }: {
        dropNode: FlowNodeEntity;
        nodes: FlowNodeEntity[];
    }): any;
    /**
     * 执行操作
     * @param operation 可序列化的操作
     * @returns 操作返回
     */
    apply(operation: FlowOperation): any;
    /**
     * 事务执行
     * @param transaction
     */
    transact(transaction: () => void): void;
    dispose(): void;
    protected toId(node: FlowNodeEntityOrId): string;
    protected toNodeEntity(node: FlowNodeEntityOrId): FlowNodeEntity | undefined;
    protected getNodeIndex(node: FlowNodeEntityOrId): number;
    protected doMoveNode(node: FlowNodeEntity, newParent: FlowNodeEntity, index: number): void;
}

/** 分组控制器 */
declare class FlowGroupController {
    readonly groupNode: FlowNodeEntity;
    private constructor();
    get nodes(): FlowNodeEntity[];
    get collapsed(): boolean;
    collapse(): void;
    expand(): void;
    /** 获取分组外围的最大边框 */
    get bounds(): Rectangle;
    /** 是否是开始节点 */
    isStartNode(node?: FlowNodeEntity): boolean;
    /** 是否是结束节点 */
    isEndNode(node?: FlowNodeEntity): boolean;
    set note(note: string);
    get note(): string;
    set noteHeight(height: number);
    get noteHeight(): number;
    get positionConfig(): Record<string, number>;
    private set collapsed(value);
    set hovered(hovered: boolean);
    get hovered(): boolean;
    static create(groupNode?: FlowNodeEntity): FlowGroupController | undefined;
}

declare class FlowGroupService {
    readonly entityManager: EntityManager;
    readonly operationService: FlowOperationBaseService;
    /** 创建分组节点 */
    createGroup(nodes: FlowNodeEntity[]): FlowNodeEntity | undefined;
    /** 删除分组 */
    deleteGroup(groupNode: FlowNodeEntity): void;
    /** 取消分组 */
    ungroup(groupNode: FlowNodeEntity): void;
    /** 返回所有分组节点 */
    getAllGroups(): FlowGroupController[];
    /** 获取分组控制器*/
    groupController(group: FlowNodeEntity): FlowGroupController | undefined;
    static validate(nodes: FlowNodeEntity[]): boolean;
}

/**
 *
 * @param node 节点 entity
 * @param key 从 DocumentOptions 里获取 constants 的 key
 * @param defaultSpacing 默认从 DEFAULT_SPACING 获取 spacing，也可以外部传入默认值
 * @returns
 */
declare const getDefaultSpacing: (node: FlowNodeEntity, key: string, defaultSpacing?: number) => any;

export { type AddBlockConfig, type AddBlockOperation, type AddChildNodeOperation, type AddFromNodeOperation, type AddNodeConfig, type AddNodeData, type AddNodeOperation, type AddNodesOperation, type AddOrDeleteBlockValue, type AddOrDeleteChildNodeValue, type AddOrDeleteFromNodeOperationValue, type AddOrDeleteNodeOperationValue, type AddOrDeleteNodeValue, type AddOrDeleteNodesOperationValue, type AdderProps, type ChangeNodeOperation, type ChangeNodeOperationValue, type CollapseAdderProps, type CollapseProps, ConstantKeys, type CreateGroupOperation, type CustomLabelProps, DEFAULT_FLOW_NODE_META, DEFAULT_SIZE, DEFAULT_SPACING, DRAGGING_TYPE, DefaultSpacingKey, type DeleteBlockOperation, type DeleteChildNodeOperation, type DeleteFromNodeOperation, type DeleteNodeOperation, type DeleteNodesOperation, type DragNodeProps, FLOW_DEFAULT_HIDDEN_TYPES, FlowDocument, FlowDocumentConfig, FlowDocumentConfigDefaultData, FlowDocumentConfigEnum, FlowDocumentContainerModule, FlowDocumentContribution, type FlowDocumentJSON, FlowDocumentOptions, FlowDocumentOptionsDefault, FlowDocumentProvider, FlowDocumentTransformerEntity, FlowDragService, FlowGroupController, type FlowGroupJSON, FlowGroupService, FlowLayout, FlowLayoutContribution, FlowLayoutDefault, FlowNodeBaseType, FlowNodeEntity, type FlowNodeEntityConfig, type FlowNodeEntityOrId, type FlowNodeInitData, type FlowNodeJSON, type FlowNodeMeta, FlowNodeRegistry, FlowNodeRenderData, type FlowNodeRenderSchema, FlowNodeSplitType, FlowNodeTransformData, type FlowNodeTransformSchema, FlowNodeTransitionData, type FlowNodeTransitionSchema, type FlowNodeType, type FlowOperation, FlowOperationBaseService, FlowOperationBaseServiceImpl, FlowRendererStateEntity, type FlowTransitionLabel, FlowTransitionLabelEnum, type FlowTransitionLine, FlowTransitionLineEnum, FlowVirtualTree, LABEL_SIDE_TYPE, type MoveBlockOperation, type MoveBlockOperationValue, type MoveChildNodesOperation, type MoveChildNodesOperationValue, type MoveNodeConfig, type MoveNodesOperation, type MoveNodesOperationValue, type OnNodeAddEvent, type OnNodeMoveEvent, OperationType, type UngroupOperation, type Vertex, type createOrUngroupValue, drawLineToBottom, drawLineToNext, getDefaultSpacing };
