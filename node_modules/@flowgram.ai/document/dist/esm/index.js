var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

// src/typings/flow.ts
var FlowNodeBaseType = /* @__PURE__ */ ((FlowNodeBaseType2) => {
  FlowNodeBaseType2["START"] = "start";
  FlowNodeBaseType2["DEFAULT"] = "default";
  FlowNodeBaseType2["ROOT"] = "root";
  FlowNodeBaseType2["EMPTY"] = "empty";
  FlowNodeBaseType2["INLINE_BLOCKS"] = "inlineBlocks";
  FlowNodeBaseType2["BLOCK_ICON"] = "blockIcon";
  FlowNodeBaseType2["BLOCK"] = "block";
  FlowNodeBaseType2["BLOCK_ORDER_ICON"] = "blockOrderIcon";
  FlowNodeBaseType2["GROUP"] = "group";
  FlowNodeBaseType2["END"] = "end";
  FlowNodeBaseType2["BREAK"] = "break";
  FlowNodeBaseType2["CONDITION"] = "condition";
  FlowNodeBaseType2["SUB_CANVAS"] = "subCanvas";
  FlowNodeBaseType2["MULTI_INPUTS"] = "multiInputs";
  FlowNodeBaseType2["MULTI_OUTPUTS"] = "multiOutputs";
  FlowNodeBaseType2["INPUT"] = "input";
  FlowNodeBaseType2["OUTPUT"] = "output";
  return FlowNodeBaseType2;
})(FlowNodeBaseType || {});
var FlowNodeSplitType = /* @__PURE__ */ ((FlowNodeSplitType2) => {
  FlowNodeSplitType2["SIMPLE_SPLIT"] = "simpleSplit";
  FlowNodeSplitType2["DYNAMIC_SPLIT"] = "dynamicSplit";
  FlowNodeSplitType2["STATIC_SPLIT"] = "staticSplit";
  return FlowNodeSplitType2;
})(FlowNodeSplitType || {});
var FlowDocumentConfigEnum = /* @__PURE__ */ ((FlowDocumentConfigEnum2) => {
  FlowDocumentConfigEnum2["END_NODES_REFINE_BRANCH"] = "END_NODES_REFINE_BRANCH";
  return FlowDocumentConfigEnum2;
})(FlowDocumentConfigEnum || {});
var FLOW_DEFAULT_HIDDEN_TYPES = [
  "root" /* ROOT */,
  "inlineBlocks" /* INLINE_BLOCKS */,
  "block" /* BLOCK */
];

// src/typings/flow-layout.ts
var FlowLayout = Symbol("FlowLayout");
var FlowLayoutContribution = Symbol("FlowLayoutContribution");
var FlowLayoutDefault = /* @__PURE__ */ ((FlowLayoutDefault2) => {
  FlowLayoutDefault2["VERTICAL_FIXED_LAYOUT"] = "vertical-fixed-layout";
  FlowLayoutDefault2["HORIZONTAL_FIXED_LAYOUT"] = "horizontal-fixed-layout";
  return FlowLayoutDefault2;
})(FlowLayoutDefault || {});
((FlowLayoutDefault2) => {
  function isVertical(layout) {
    return layout.name === "vertical-fixed-layout" /* VERTICAL_FIXED_LAYOUT */;
  }
  FlowLayoutDefault2.isVertical = isVertical;
})(FlowLayoutDefault || (FlowLayoutDefault = {}));

// src/typings/flow-transition.ts
var FlowTransitionLineEnum = /* @__PURE__ */ ((FlowTransitionLineEnum2) => {
  FlowTransitionLineEnum2[FlowTransitionLineEnum2["STRAIGHT_LINE"] = 0] = "STRAIGHT_LINE";
  FlowTransitionLineEnum2[FlowTransitionLineEnum2["DIVERGE_LINE"] = 1] = "DIVERGE_LINE";
  FlowTransitionLineEnum2[FlowTransitionLineEnum2["MERGE_LINE"] = 2] = "MERGE_LINE";
  FlowTransitionLineEnum2[FlowTransitionLineEnum2["ROUNDED_LINE"] = 3] = "ROUNDED_LINE";
  FlowTransitionLineEnum2[FlowTransitionLineEnum2["CUSTOM_LINE"] = 4] = "CUSTOM_LINE";
  FlowTransitionLineEnum2[FlowTransitionLineEnum2["DRAGGING_LINE"] = 5] = "DRAGGING_LINE";
  return FlowTransitionLineEnum2;
})(FlowTransitionLineEnum || {});
var FlowTransitionLabelEnum = /* @__PURE__ */ ((FlowTransitionLabelEnum2) => {
  FlowTransitionLabelEnum2[FlowTransitionLabelEnum2["ADDER_LABEL"] = 0] = "ADDER_LABEL";
  FlowTransitionLabelEnum2[FlowTransitionLabelEnum2["TEXT_LABEL"] = 1] = "TEXT_LABEL";
  FlowTransitionLabelEnum2[FlowTransitionLabelEnum2["COLLAPSE_LABEL"] = 2] = "COLLAPSE_LABEL";
  FlowTransitionLabelEnum2[FlowTransitionLabelEnum2["COLLAPSE_ADDER_LABEL"] = 3] = "COLLAPSE_ADDER_LABEL";
  FlowTransitionLabelEnum2[FlowTransitionLabelEnum2["CUSTOM_LABEL"] = 4] = "CUSTOM_LABEL";
  FlowTransitionLabelEnum2[FlowTransitionLabelEnum2["BRANCH_DRAGGING_LABEL"] = 5] = "BRANCH_DRAGGING_LABEL";
  return FlowTransitionLabelEnum2;
})(FlowTransitionLabelEnum || {});

// src/typings/flow-node-register.ts
var DefaultSpacingKey = {
  /**
   * 普通节点间距。垂直 / 水平
   */
  NODE_SPACING: "SPACING",
  /**
   * 圆弧线条 x radius
   */
  ROUNDED_LINE_X_RADIUS: "ROUNDED_LINE_X_RADIUS",
  /**
   * 圆弧线条 y radius
   */
  ROUNDED_LINE_Y_RADIUS: "ROUNDED_LINE_Y_RADIUS",
  /**
   * dynamicSplit block list 下部留白间距，因为有两个拐弯，所以翻一倍
   */
  INLINE_BLOCKS_PADDING_BOTTOM: "INLINE_BLOCKS_PADDING_BOTTOM",
  /**
   * 复合节点距离上个节点的距离
   * 条件分支菱形下边和分支的距离
   */
  COLLAPSED_SPACING: "COLLAPSED_SPACING",
  /**
   * width of hover area
   */
  HOVER_AREA_WIDTH: "HOVER_AREA_WIDTH"
};
var DEFAULT_SPACING = {
  NULL: 0,
  [DefaultSpacingKey.NODE_SPACING]: 32,
  // 普通节点间距。垂直 / 水平
  MARGIN_RIGHT: 20,
  // 普通节点右边间距
  INLINE_BLOCK_PADDING_BOTTOM: 16,
  // block 底部留白
  INLINE_BLOCKS_PADDING_TOP: 30,
  // block list 上部留白间距
  [DefaultSpacingKey.INLINE_BLOCKS_PADDING_BOTTOM]: 40,
  // block lit 下部留白间距，因为有两个拐弯，所以翻一倍
  MIN_INLINE_BLOCK_SPACING: 200,
  // 分支间最小边距 (垂直布局)
  MIN_INLINE_BLOCK_SPACING_HORIZONTAL: 80,
  // 分支间最小边距 (水平布局)
  [DefaultSpacingKey.COLLAPSED_SPACING]: 12,
  // 复合节点距离上个节点的距离
  [DefaultSpacingKey.ROUNDED_LINE_X_RADIUS]: 16,
  // 圆弧线条 x radius
  [DefaultSpacingKey.ROUNDED_LINE_Y_RADIUS]: 20,
  // 圆弧线条 y radius
  [DefaultSpacingKey.HOVER_AREA_WIDTH]: 20
  // width of hover area
};
var DRAGGING_TYPE = /* @__PURE__ */ ((DRAGGING_TYPE2) => {
  DRAGGING_TYPE2["NODE"] = "node";
  DRAGGING_TYPE2["BRANCH"] = "branch";
  return DRAGGING_TYPE2;
})(DRAGGING_TYPE || {});
var LABEL_SIDE_TYPE = /* @__PURE__ */ ((LABEL_SIDE_TYPE2) => {
  LABEL_SIDE_TYPE2["PRE_BRANCH"] = "pre_branch";
  LABEL_SIDE_TYPE2["NORMAL_BRANCH"] = "normal_branch";
  return LABEL_SIDE_TYPE2;
})(LABEL_SIDE_TYPE || {});
var DEFAULT_SIZE = {
  width: 280,
  height: 60
};
var DEFAULT_FLOW_NODE_META = (nodeType, document) => {
  const hidden = FLOW_DEFAULT_HIDDEN_TYPES.includes(nodeType);
  return {
    isStart: nodeType === "start",
    hidden,
    defaultExpanded: document.options.allNodesDefaultExpanded,
    expandedSize: { width: 520, height: 300 },
    // 展开后的大小
    size: DEFAULT_SIZE,
    origin: document.layout.getDefaultNodeOrigin(),
    isInlineBlocks: nodeType === "inlineBlocks" /* INLINE_BLOCKS */,
    // miniSize: { width: 200, height: 40 },
    spacing: DEFAULT_SPACING.SPACING,
    inlineSpacingPre: 0,
    inlineSpacingAfter: 0,
    expandable: true,
    draggable: true,
    selectable: true,
    renderKey: "",
    minInlineBlockSpacing: () => {
      const isVertical = FlowLayoutDefault.isVertical(document.layout);
      return isVertical ? DEFAULT_SPACING.MIN_INLINE_BLOCK_SPACING : DEFAULT_SPACING.MIN_INLINE_BLOCK_SPACING_HORIZONTAL;
    }
  };
};
var FlowNodeRegistry;
((FlowNodeRegistry4) => {
  function mergeChildRegistries(r1 = [], r2 = []) {
    if (r1.length === 0 || r2.length === 0) {
      return [...r1, ...r2];
    }
    const r1Filter = r1.map((r1Current) => {
      const r2Current = r2.find((n) => n.type === r1Current.type);
      if (r2Current) {
        return merge(r1Current, r2Current, r1Current.type);
      }
      return r1Current;
    });
    const r2Filter = r2.filter((n) => !r1.some((r) => r.type === n.type));
    return [...r1Filter, ...r2Filter];
  }
  FlowNodeRegistry4.mergeChildRegistries = mergeChildRegistries;
  function merge(registry1, registry2, finalType) {
    const extendKeys = registry1.__extends__ ? registry1.__extends__.slice() : [];
    if (registry1.type !== registry2.type) {
      extendKeys.unshift(registry1.type);
    }
    return {
      ...registry1,
      ...registry2,
      extendChildRegistries: mergeChildRegistries(
        registry1.extendChildRegistries,
        registry2.extendChildRegistries
      ),
      meta: { ...registry1.meta, ...registry2.meta },
      extend: void 0,
      type: finalType,
      __extends__: extendKeys
    };
  }
  FlowNodeRegistry4.merge = merge;
  function extend(registry, extendRegistries) {
    if (!extendRegistries.length) return registry;
    return extendRegistries.reduce((res, ext) => merge(res, ext, registry.type), registry);
  }
  FlowNodeRegistry4.extend = extend;
})(FlowNodeRegistry || (FlowNodeRegistry = {}));

// src/typings/flow-operation.ts
var OperationType = /* @__PURE__ */ ((OperationType2) => {
  OperationType2["addFromNode"] = "addFromNode";
  OperationType2["deleteFromNode"] = "deleteFromNode";
  OperationType2["addBlock"] = "addBlock";
  OperationType2["deleteBlock"] = "deleteBlock";
  OperationType2["createGroup"] = "createGroup";
  OperationType2["ungroup"] = "ungroup";
  OperationType2["moveNodes"] = "moveNodes";
  OperationType2["moveBlock"] = "moveBlock";
  OperationType2["moveChildNodes"] = "moveChildNodes";
  OperationType2["addNodes"] = "addNodes";
  OperationType2["deleteNodes"] = "deleteNodes";
  OperationType2["changeNode"] = "changeNode";
  OperationType2["addChildNode"] = "addChildNode";
  OperationType2["deleteChildNode"] = "deleteChildNode";
  OperationType2["addNode"] = "addNode";
  OperationType2["deleteNode"] = "deleteNode";
  return OperationType2;
})(OperationType || {});
var FlowOperationBaseService = Symbol("FlowOperationBaseService");

// src/entities/flow-node-entity.ts
import { Entity } from "@flowgram.ai/core";

// src/datas/flow-node-transform-data.ts
import { Disposable as Disposable2, Rectangle } from "@flowgram.ai/utils";
import {
  Bounds,
  EntityData as EntityData2,
  TransformData
} from "@flowgram.ai/core";

// src/datas/flow-node-render-data.ts
import { Compare, Disposable, domUtils, Emitter } from "@flowgram.ai/utils";
import { EntityData } from "@flowgram.ai/core";
var _FlowNodeRenderData = class _FlowNodeRenderData extends EntityData {
  constructor(entity) {
    super(entity);
    this.onExtInfoChangeEmitter = new Emitter();
    this.onExtInfoChange = this.onExtInfoChangeEmitter.event;
    this.toDispose.push(
      Disposable.create(() => {
        if (this._node) this._node.remove();
      })
    );
  }
  get key() {
    return this.entity.id;
  }
  getDefaultData() {
    const { addable, expandable, defaultExpanded } = this.entity.getNodeMeta();
    return {
      addable,
      expandable,
      expanded: defaultExpanded || false,
      activated: false,
      hovered: false,
      dragging: false,
      stackIndex: 0
    };
  }
  updateExtInfo(info) {
    if (Compare.isChanged(this.data.extInfo, info)) {
      const oldInfo = this.data.extInfo;
      this.update({
        extInfo: info
      });
      this.onExtInfoChangeEmitter.fire({ oldInfo, newInfo: info });
    }
  }
  getExtInfo() {
    return this.data.extInfo;
  }
  get addable() {
    return this.data.addable;
  }
  get expandable() {
    return this.data.expandable;
  }
  get draggable() {
    const { draggable } = this.entity.getNodeMeta();
    if (typeof draggable === "function") {
      return draggable(this.entity);
    }
    return draggable;
  }
  get expanded() {
    return this.data.expanded;
  }
  set expanded(expanded) {
    if (this.expandable && this.data.expanded !== expanded) {
      this.data.expanded = expanded;
      this.fireChange();
    }
  }
  toggleExpand() {
    this.expanded = !this.expanded;
  }
  toggleMouseEnter(silent = false) {
    this.entity.document.renderState.setNodeHovered(this.entity);
    if (silent) return;
    const transform = this.entity.getData(FlowNodeTransformData);
    if (transform.renderState.hidden) {
      return;
    }
    if (this.mouseLeaveTimeout) {
      clearTimeout(this.mouseLeaveTimeout);
      this.mouseLeaveTimeout = void 0;
    }
    transform.renderState.hovered = true;
    if (this.entity.isFirst && this.entity.parent?.id !== "root") {
      transform.parent.renderState.activated = true;
    } else {
      transform.renderState.activated = true;
    }
  }
  toggleMouseLeave(silent = false) {
    this.entity.document.renderState.setNodeHovered(void 0);
    if (silent) return;
    const transform = this.entity.getData(FlowNodeTransformData);
    this.mouseLeaveTimeout = setTimeout(() => {
      transform.renderState.hovered = false;
      if (this.entity.isFirst && this.entity.parent?.id !== "root") {
        transform.parent.renderState.activated = false;
      }
      transform.renderState.activated = false;
    }, 200);
  }
  get hidden() {
    return this.entity.hidden;
  }
  set hovered(hovered) {
    this.data.hovered = hovered;
    this.fireChange();
  }
  get hovered() {
    return this.data.hovered;
  }
  get dragging() {
    return this.data.dragging;
  }
  set dragging(dragging) {
    if (this.data.dragging !== dragging) {
      this.data.dragging = dragging;
      this.fireChange();
    }
  }
  set activated(activated) {
    if (this.entity.flowNodeType === "blockIcon" /* BLOCK_ICON */ && this.entity.parent) {
      this.entity.parent.getData(_FlowNodeRenderData).activated = activated;
      return;
    }
    if (this.data.activated !== activated) {
      this.data.activated = activated;
      this.fireChange();
    }
  }
  get activated() {
    const { entity } = this;
    if (entity.parent && entity.parent.getData(_FlowNodeRenderData).activated) {
      return true;
    }
    return this.data.activated;
  }
  get stackIndex() {
    return this.data.stackIndex;
  }
  set stackIndex(index) {
    this.data.stackIndex = index;
  }
  get lineActivated() {
    const { activated } = this;
    if (!activated) return false;
    return Boolean(
      this.entity.parent?.getData(_FlowNodeRenderData)?.activated || this.entity.isInlineBlock || this.entity.next?.getData(_FlowNodeRenderData).activated
    );
  }
  get node() {
    if (this._node) return this._node;
    this._node = domUtils.createDivWithClass("gedit-flow-activity-node");
    this._node.dataset.testid = "sdk.workflow.canvas.node";
    this._node.dataset.nodeId = this.entity.id;
    return this._node;
  }
  dispose() {
    super.dispose();
    this.onExtInfoChangeEmitter.dispose();
  }
};
_FlowNodeRenderData.type = "FlowNodeRenderData";
var FlowNodeRenderData = _FlowNodeRenderData;

// src/datas/flow-node-transform-data.ts
var _FlowNodeTransformData = class _FlowNodeTransformData extends EntityData2 {
  constructor(entity) {
    super(entity);
    this.localDirty = true;
    const { origin } = this.entity.getNodeMeta();
    this.transform = this.entity.addData(TransformData);
    this.transform.changeLocked = true;
    this.transform.update({ origin: { ...origin } });
    this.transform.changeLocked = false;
    this.renderState = this.entity.addData(FlowNodeRenderData);
    this.bindChange(this.transform);
    this.toDispose.push(
      Disposable2.create(() => {
        const { next, parent } = this;
        if (next) next.localDirty = true;
        if (parent) parent.localDirty = true;
      })
    );
  }
  get origin() {
    return this.transform.origin;
  }
  get key() {
    return this.entity.id;
  }
  getDefaultData() {
    const { size, defaultExpanded, expandedSize, hidden } = this.entity.getNodeMeta();
    const defaultSize = defaultExpanded ? expandedSize : size;
    return {
      size: !hidden ? { ...defaultSize } : { width: 0, height: 0 }
    };
  }
  /**
   * 获取节点是否展开
   */
  get collapsed() {
    return this.entity.collapsed;
  }
  set collapsed(collapsed) {
    this.entity.collapsed = collapsed;
    this.localDirty = true;
    if (this.firstChild) this.firstChild.localDirty = true;
    this.fireChange();
  }
  /**
   * 获取节点的大小
   */
  get size() {
    return this.entity.memoGlobal("size", () => {
      if (this.isContainer) return this.transform.localSize;
      return this.data.size;
    });
  }
  get position() {
    const { position } = this.transform;
    return {
      x: position.x,
      y: position.y
    };
  }
  set size(size) {
    const { width, height } = this.data.size;
    if (this.isContainer) return;
    if (size.width !== width || size.height !== height) {
      this._data.size = { ...size };
      this.localDirty = true;
      this.fireChange();
    }
  }
  get inputPoint() {
    return this.entity.memoGlobal("inputPoint", () => {
      const { getInputPoint } = this.entity.getNodeRegistry();
      return getInputPoint ? getInputPoint(this, this.entity.document.layout) : this.defaultInputPoint;
    });
  }
  get defaultInputPoint() {
    return this.entity.memoGlobal(
      "defaultInputPoint",
      () => this.entity.document.layout.getDefaultInputPoint(this.entity)
    );
  }
  get defaultOutputPoint() {
    return this.entity.memoGlobal(
      "defaultOutputPoint",
      () => this.entity.document.layout.getDefaultOutputPoint(this.entity)
    );
  }
  get outputPoint() {
    return this.entity.memoGlobal("outputPoint", () => {
      const { getOutputPoint } = this.entity.getNodeRegistry();
      return getOutputPoint ? getOutputPoint(this, this.entity.document.layout) : this.defaultOutputPoint;
    });
  }
  /**
   * 原点的最左偏移
   */
  get originDeltaX() {
    return this.entity.memoLocal("originDeltaX", () => {
      const { children } = this;
      const { getOriginDeltaX } = this.entity.getNodeRegistry();
      if (getOriginDeltaX) return getOriginDeltaX(this, this.entity.document.layout);
      if (children.length === 0) {
        return -this.size.width * this.origin.x;
      }
      if (children.length === 1) return children[0].originDeltaX;
      if (this.entity.isInlineBlocks && children.length > 1) {
        return children[0].originDeltaX + this.transform.position.x;
      }
      return children.reduce((res, child) => {
        const deltaX = child.originDeltaX;
        return res === void 0 || deltaX < res ? deltaX : res;
      }, void 0);
    });
  }
  /**
   * 原点 y 轴偏移
   */
  get originDeltaY() {
    return this.entity.memoLocal("originDeltaY", () => {
      const { children } = this;
      const { getOriginDeltaY } = this.entity.getNodeRegistry();
      if (getOriginDeltaY) return getOriginDeltaY(this, this.entity.document.layout);
      if (children.length === 0) {
        return -this.size.height * this.origin.y;
      }
      if (children.length === 1) return children[0].originDeltaY;
      if (this.entity.isInlineBlocks && children.length > 1) {
        return children[0].originDeltaY + this.transform.position.y;
      }
      return children.reduce((res, child) => {
        const deltaY = child.originDeltaY;
        return res === void 0 || deltaY < res ? deltaY : res;
      }, void 0);
    });
  }
  /**
   * 绝对坐标 bbox, 不包含自身的 spacing(marginBottom), 但是包含 inlineSpacing 和 子节点的 spacing
   */
  get bounds() {
    return this.entity.memoGlobal("bounds", () => {
      const { transform } = this;
      if (this.isContainer) {
        const childrenRects = transform.children.map(
          (c) => c.entity.getData(_FlowNodeTransformData).boundsWithPadding
        );
        return Rectangle.enlarge(childrenRects).withPadding(this.padding);
      }
      return transform.bounds;
    });
  }
  get boundsWithPadding() {
    return this.entity.memoGlobal("boundsWithPadding", () => {
      const { transform } = this;
      if (this.isContainer) {
        const childrenRects = transform.children.map(
          (c) => c.entity.getData(_FlowNodeTransformData).boundsWithPadding
        );
        return Rectangle.enlarge(childrenRects).withPadding(this.padding);
      }
      return transform.bounds.clone().withPadding(this.padding);
    });
  }
  get isContainer() {
    return this.transform.isContainer;
  }
  /**
   * 相对坐标 bbox, 这里的 localBounds 会加入 padding 一起算
   */
  get localBounds() {
    return this.entity.memoLocal("localBounds", () => {
      const { transform } = this;
      if (this.isContainer) {
        const childrenRects = transform.children.map(
          (c) => c.entity.getData(_FlowNodeTransformData).localBounds
        );
        const childrenBounds = Rectangle.enlarge(childrenRects).withPadding(this.padding);
        return Bounds.applyMatrix(childrenBounds, transform.localTransform);
      }
      return transform.localBounds.clone().withPadding(this.padding);
    });
  }
  get padding() {
    return this.entity.document.layout.getPadding(this.entity);
  }
  setParentTransform(transform) {
    if (this.transform.parent !== transform?.transform) {
      this.localDirty = true;
    }
    this.transform.setParent(transform?.transform);
  }
  get spacing() {
    const { spacing } = this.entity.getNodeMeta();
    return typeof spacing === "function" ? spacing(this) : spacing;
  }
  get inlineSpacingPre() {
    const { inlineSpacingPre } = this.entity.getNodeMeta();
    return typeof inlineSpacingPre === "function" ? inlineSpacingPre(this) : inlineSpacingPre;
  }
  get inlineSpacingAfter() {
    const { inlineSpacingAfter } = this.entity.getNodeMeta();
    return typeof inlineSpacingAfter === "function" ? inlineSpacingAfter(this) : inlineSpacingAfter;
  }
  get minInlineBlockSpacing() {
    const { minInlineBlockSpacing } = this.entity.getNodeMeta();
    return typeof minInlineBlockSpacing === "function" ? minInlineBlockSpacing(this) : minInlineBlockSpacing;
  }
  get children() {
    return this.entity.children.map(
      (child) => child.getData(_FlowNodeTransformData)
    );
  }
  /**
   * 上一个节点的 transform 数据
   */
  get pre() {
    return this.entity.pre?.getData(_FlowNodeTransformData);
  }
  get originParent() {
    return this.entity.originParent?.getData(_FlowNodeTransformData);
  }
  get isFirst() {
    return this.entity.isFirst;
  }
  get isLast() {
    return this.entity.isLast;
  }
  get lastChild() {
    return this.entity.lastChild?.getData(_FlowNodeTransformData);
  }
  get firstChild() {
    return this.entity.firstChild?.getData(_FlowNodeTransformData);
  }
  /**
   * 下一个节点的 transform 数据
   */
  get next() {
    return this.entity.next?.getData(_FlowNodeTransformData);
  }
  /**
   * parent 节点的 transform 数据
   */
  get parent() {
    return this.entity.parent?.getData(_FlowNodeTransformData);
  }
};
_FlowNodeTransformData.type = "FlowNodeTransformData";
var FlowNodeTransformData = _FlowNodeTransformData;

// src/datas/flow-node-transition-data.ts
import { Point } from "@flowgram.ai/utils";
import { EntityData as EntityData3 } from "@flowgram.ai/core";
var drawLineToNext = (transition) => {
  const { transform } = transition;
  const currentOutput = transform.outputPoint;
  if (transform.next) {
    return [
      {
        type: 0 /* STRAIGHT_LINE */,
        from: currentOutput,
        to: transform.next.inputPoint
      }
    ];
  }
  return [];
};
var drawLineToBottom = (transition) => {
  const { transform } = transition;
  const currentOutput = transform.outputPoint;
  const parentOutput = transform.parent?.outputPoint;
  if (!transform.next && parentOutput && !new Point().copyFrom(currentOutput).equals(parentOutput) && !transition.isNodeEnd) {
    return [
      {
        type: 0 /* STRAIGHT_LINE */,
        from: currentOutput,
        to: parentOutput
      }
    ];
  }
  return [];
};
var FlowNodeTransitionData = class extends EntityData3 {
  getDefaultData() {
    return {};
  }
  formatLines(lines) {
    if (this.entity.document.options?.formatNodeLines) {
      return this.entity.document.options?.formatNodeLines?.(this.entity, lines);
    }
    return lines;
  }
  formatLabels(labels) {
    if (this.entity.document.options.formatNodeLabels) {
      return this.entity.document.options?.formatNodeLabels?.(this.entity, labels);
    }
    return labels;
  }
  get lines() {
    return this.entity.memoGlobal("lines", () => {
      const { getChildLines } = this.entity.parent?.getNodeRegistry() || {};
      if (getChildLines) {
        return this.formatLines(getChildLines(this, this.entity.document.layout));
      }
      const { getLines } = this.entity.getNodeRegistry();
      if (getLines) {
        return this.formatLines(getLines(this, this.entity.document.layout));
      }
      if (this.transform.entity.isInlineBlock) {
        return [];
      }
      return this.formatLines([...drawLineToNext(this), ...drawLineToBottom(this)]);
    });
  }
  get labels() {
    return this.entity.memoGlobal("labels", () => {
      const { getChildLabels } = this.entity.parent?.getNodeRegistry() || {};
      if (getChildLabels) {
        return this.formatLabels(getChildLabels(this, this.entity.document.layout));
      }
      const { getLabels } = this.entity.getNodeRegistry();
      if (getLabels) {
        return this.formatLabels(getLabels(this, this.entity.document.layout));
      }
      if (this.transform.entity.isInlineBlock) {
        return [];
      }
      const currentOutput = this.transform.outputPoint;
      if (this.transform.next) {
        return this.formatLabels([
          {
            offset: Point.getMiddlePoint(currentOutput, this.transform.next.inputPoint),
            type: 0 /* ADDER_LABEL */
          }
        ]);
      }
      const parentOutput = this.transform.parent?.outputPoint;
      if (parentOutput && !new Point().copyFrom(currentOutput).equals(parentOutput) && !this.isNodeEnd) {
        return this.formatLabels([
          {
            offset: parentOutput,
            type: 0 /* ADDER_LABEL */
          }
        ]);
      }
      return [];
    });
  }
  constructor(entity) {
    super(entity);
    this.transform = this.entity.addData(FlowNodeTransformData);
    this.renderData = this.entity.addData(FlowNodeRenderData);
    this.bindChange(this.transform);
    this.bindChange(this.renderData);
  }
  get collapsed() {
    return this.entity.collapsed;
  }
  get isNodeEnd() {
    return this.entity.isNodeEnd;
  }
};
FlowNodeTransitionData.type = "FlowNodeTransitionData";

// src/entities/flow-node-entity.ts
var FlowNodeEntity = class extends Entity {
  constructor(conf) {
    super(conf);
    this._memoLocalCache = /* @__PURE__ */ new Map();
    this._memoGlobalCache = /* @__PURE__ */ new Map();
    this.flowNodeType = "unknown";
    // 流程类型
    /**
     * 是否隐藏
     */
    this._hidden = false;
    this.index = -1;
    this.document = conf.document;
    this.flowNodeType = conf.flowNodeType;
    this.originParent = conf.originParent;
    this.metaFromJSON = conf.meta;
    this.onDispose(() => {
      this.document.originTree.getChildren(this).slice().forEach((child) => {
        child.dispose();
      });
      this.document.originTree.remove(this, false);
      this.originParent = void 0;
    });
  }
  initData(initConf) {
    if (initConf.originParent !== this.originParent) {
      this.originParent = initConf.originParent;
      this._registerCache = void 0;
    }
    if (initConf.parent) {
      initConf.parent.addChild(this, initConf.index);
    }
    if (initConf.meta !== this.metaFromJSON) {
      this._metaCache = void 0;
      this.metaFromJSON = initConf.meta;
    }
    this._hidden = !!(this.getNodeMeta().hidden || initConf.hidden);
  }
  get isStart() {
    return this.getNodeMeta().isStart;
  }
  get isFirst() {
    return !this.pre;
  }
  get isLast() {
    return !this.next;
  }
  /**
   * 子节点采用水平布局
   */
  get isInlineBlocks() {
    const originIsInlineBlocks = this.getNodeMeta().isInlineBlocks;
    return typeof originIsInlineBlocks === "function" ? originIsInlineBlocks(this) : originIsInlineBlocks;
  }
  /**
   * 水平节点
   */
  get isInlineBlock() {
    const parent = this.document.renderTree.getParent(this);
    return !!(parent && parent.isInlineBlocks);
  }
  /**
   * 节点结束标记
   * - 当前节点是结束节点
   * - 当前节点最后一个节点包含结束标记
   * - 当前节点为 inlineBlock，每一个 block 包含结束标记
   *
   * 由子元素确定，因此使用 memoLocal
   */
  get isNodeEnd() {
    return this.memoLocal("isNodeEnd", () => {
      if (this.getNodeMeta().isNodeEnd) {
        return true;
      }
      if (this.isInlineBlocks && this.collapsedChildren.length) {
        return this.collapsedChildren.every((child) => child.isNodeEnd);
      }
      if (this.lastCollapsedChild) {
        return this.lastCollapsedChild.isNodeEnd;
      }
      return false;
    });
  }
  /**
   * 添加 子节点
   *
   * @param child 插入节点
   */
  addChild(child, index) {
    if (child.parent === this) return;
    this.document.originTree.addChild(this, child, index);
  }
  get hasChild() {
    return this.children.length > 0;
  }
  get pre() {
    return this.document.renderTree.getPre(this);
  }
  get next() {
    return this.document.renderTree.getNext(this);
  }
  get parent() {
    return this.document.renderTree.getParent(this);
  }
  getNodeRegistry() {
    if (this._registerCache) return this._registerCache;
    this._registerCache = this.document.getNodeRegistry(this.flowNodeType, this.originParent);
    return this._registerCache;
  }
  /**
   * @deprecated
   * use getNodeRegistry instead
   */
  getNodeRegister() {
    return this.getNodeRegistry();
  }
  getNodeMeta() {
    if (this._metaCache) return this._metaCache;
    if (this.metaFromJSON) {
      this._metaCache = {
        ...this.getNodeRegistry().meta,
        ...this.metaFromJSON
      };
    } else {
      this._metaCache = this.getNodeRegistry().meta;
    }
    return this._metaCache;
  }
  /**
   * 获取所有子节点，包含 child 及其所有兄弟节点
   */
  get allChildren() {
    const children = [];
    for (const child of this.children) {
      children.push(child);
      children.push(...child.allChildren);
    }
    return children;
  }
  /**
   * 获取所有收起的子节点，包含 child 及其所有兄弟节点
   */
  get allCollapsedChildren() {
    const children = [];
    for (const child of this.collapsedChildren) {
      children.push(child);
      children.push(...child.allCollapsedChildren);
    }
    return children;
  }
  /**
   *
   * Get child blocks
   *
   * use `blocks` instead
   * @deprecated
   */
  get collapsedChildren() {
    return this.document.renderTree.getCollapsedChildren(this);
  }
  /**
   * Get child blocks
   */
  get blocks() {
    return this.collapsedChildren;
  }
  /**
   * Get last block
   */
  get lastBlock() {
    return this.lastCollapsedChild;
  }
  /**
   * use `lastBlock` instead
   */
  get lastCollapsedChild() {
    const { collapsedChildren } = this;
    return collapsedChildren[collapsedChildren.length - 1];
  }
  /**
   * 获取子节点，如果子节点收起来，则会返回 空数组
   */
  get children() {
    return this.document.renderTree.getChildren(this);
  }
  get lastChild() {
    const { children } = this;
    return children[children.length - 1];
  }
  get firstChild() {
    return this.children[0];
  }
  memoLocal(key, fn) {
    if (this._memoLocalCache.has(key)) {
      return this._memoLocalCache.get(key);
    }
    const data = fn();
    this._memoLocalCache.set(key, data);
    return data;
  }
  memoGlobal(key, fn) {
    if (this._memoGlobalCache.has(key)) {
      return this._memoGlobalCache.get(key);
    }
    const data = fn();
    this._memoGlobalCache.set(key, data);
    return data;
  }
  clearMemoGlobal() {
    this._memoGlobalCache.clear();
  }
  clearMemoLocal() {
    this._memoLocalCache.clear();
  }
  get childrenLength() {
    return this.children.length;
  }
  get collapsed() {
    if (this.document.renderTree.isCollapsed(this)) return true;
    return !!this.parent?.collapsed;
  }
  set collapsed(collapsed) {
    this.document.renderTree.setCollapsed(this, collapsed);
    this.clearMemoGlobal();
    this.clearMemoLocal();
  }
  get hidden() {
    return this._hidden;
  }
  // 展开该节点
  openInsideCollapsed() {
    this.document.renderTree.openNodeInsideCollapsed(this);
  }
  /**
   * 可以重载
   */
  getJSONData() {
    return this.getExtInfo();
  }
  /**
   * 生成 JSON
   * @param newId
   */
  toJSON() {
    if (this.document.options.toNodeJSON) {
      return this.document.options.toNodeJSON(this);
    }
    const nodesMap = {};
    let startNodeJSON;
    this.document.traverse((node) => {
      const isSystemNode = node.id.startsWith("$");
      if (isSystemNode) return;
      const nodeJSONData = this.getJSONData();
      const nodeJSON = {
        id: node.id,
        type: node.flowNodeType
      };
      if (nodeJSONData !== void 0) {
        nodeJSON.data = nodeJSONData;
      }
      if (!startNodeJSON) startNodeJSON = nodeJSON;
      let { parent } = node;
      if (parent && parent.id.startsWith("$")) {
        parent = parent.originParent;
      }
      const parentJSON = parent ? nodesMap[parent.id] : void 0;
      if (parentJSON) {
        if (!parentJSON.blocks) {
          parentJSON.blocks = [];
        }
        parentJSON.blocks.push(nodeJSON);
      }
      nodesMap[node.id] = nodeJSON;
    }, this);
    return startNodeJSON;
  }
  get isVertical() {
    return this.document.layout.name === "vertical-fixed-layout" /* VERTICAL_FIXED_LAYOUT */;
  }
  /**
   * 修改节点扩展信息
   * @param info
   */
  updateExtInfo(extInfo) {
    this.getData(FlowNodeRenderData).updateExtInfo(extInfo);
  }
  /**
   * 获取节点扩展信息
   */
  getExtInfo() {
    return this.getData(FlowNodeRenderData).getExtInfo();
  }
  get onExtInfoChange() {
    return this.renderData.onExtInfoChange;
  }
  /**
   * 获取渲染数据
   */
  get renderData() {
    return this.getData(FlowNodeRenderData);
  }
  /**
   * 获取位置大小数据
   */
  get transform() {
    return this.getData(FlowNodeTransformData);
  }
  /**
   * 获取节点的位置及大小矩形
   */
  get bounds() {
    return this.transform.bounds;
  }
};
FlowNodeEntity.type = "FlowNodeEntity";
((FlowNodeEntity2) => {
  function is(obj) {
    return obj instanceof FlowNodeEntity2;
  }
  FlowNodeEntity2.is = is;
})(FlowNodeEntity || (FlowNodeEntity = {}));

// src/entities/flow-document-transformer-entity.ts
import { Emitter as Emitter2 } from "@flowgram.ai/utils";
import { ConfigEntity } from "@flowgram.ai/core";
var FlowDocumentTransformerEntity = class extends ConfigEntity {
  constructor(conf) {
    super(conf);
    this.onRefreshEmitter = new Emitter2();
    this.lastTransformVersion = -1;
    this.lastTreeVersion = -1;
    this.onRefresh = this.onRefreshEmitter.event;
    this.document = conf.document;
    this.toDispose.push(
      this.document.originTree.onTreeChange(() => {
        this.config.treeVersion += 1;
        this.fireChange();
      })
    );
    this.toDispose.push(this.onRefreshEmitter);
  }
  getDefaultConfig() {
    return {
      loading: true,
      treeVersion: 0
    };
  }
  get loading() {
    return this.config.loading;
  }
  set loading(loading) {
    if (this.config.loading !== loading) {
      this.config.loading = loading;
      this.fireChange();
    }
  }
  /**
   * 更新矩阵结构 (这个只有在树结构变化时候才会触发，如：添加节点、删除节点、改变位置节点)
   */
  updateTransformsTree() {
    this.document.renderTree.traverse((node, depth, index) => {
      const transform = node.getData(FlowNodeTransformData);
      if (transform.collapsed) {
        transform.transform.clearChildren();
      }
      if (node.parent) {
        transform.setParentTransform(node.parent.getData(FlowNodeTransformData));
      }
      node.index = index;
    });
  }
  clear() {
    this.lastTreeVersion = -1;
    this.lastTransformVersion = -1;
  }
  isTreeDirty() {
    const transformVersion = this.entityManager.getEntityDataVersion(FlowNodeTransformData);
    const isTreeVersionChanged = this.lastTreeVersion !== this.config.treeVersion;
    const isTransformVersionChanged = this.lastTransformVersion !== transformVersion;
    return isTreeVersionChanged || isTransformVersionChanged;
  }
  /**
   * 刷新节点的相对偏移
   */
  refresh() {
    const transformVersion = this.entityManager.getEntityDataVersion(FlowNodeTransformData);
    const isTreeVersionChanged = this.lastTreeVersion !== this.config.treeVersion;
    const isTransformVersionChanged = this.lastTransformVersion !== transformVersion;
    this.entityManager.changeEntityLocked = true;
    if (isTreeVersionChanged) {
      this.document.renderTree.updateRenderStruct();
      this.updateTransformsTree();
      this.lastTreeVersion = this.config.treeVersion;
    }
    if (isTreeVersionChanged || isTransformVersionChanged) {
      this.document.layout.update();
      this.lastTransformVersion = this.entityManager.getEntityDataVersion(FlowNodeTransformData);
      this.lastTreeVersion = this.config.treeVersion;
      this.onRefreshEmitter.fire();
    }
    this.entityManager.changeEntityLocked = false;
  }
};
FlowDocumentTransformerEntity.type = "FlowDocumentTransformerEntity";

// src/entities/flow-renderer-state-entity.ts
import { debounce } from "lodash";
import { ConfigEntity as ConfigEntity2 } from "@flowgram.ai/core";
var FlowRendererStateEntity = class extends ConfigEntity2 {
  getDefaultConfig() {
    return {};
  }
  constructor(conf) {
    super(conf);
  }
  getNodeHovered() {
    return this.config.nodeHoveredId ? this.entityManager.getEntityById(this.config.nodeHoveredId) : void 0;
  }
  setNodeHovered(node) {
    this.updateConfig({
      nodeHoveredId: node?.id
    });
  }
  getDragLabelSide() {
    return this.config.dragLabelSide;
  }
  setDragLabelSide(dragLabelSide) {
    this.updateConfig({
      dragLabelSide
    });
  }
  getNodeDroppingId() {
    return this.config.nodeDroppingId;
  }
  setNodeDroppingId(nodeDroppingId) {
    this.updateConfig({
      nodeDroppingId
    });
  }
  getDragStartEntity() {
    const { nodeDragStartId } = this.config;
    return this.entityManager.getEntityById(nodeDragStartId);
  }
  setDragStartEntity(node) {
    this.updateConfig({
      nodeDragStartId: node?.id
    });
  }
  // 拖拽多个节点时
  getDragEntities() {
    const { nodeDragIds } = this.config;
    return (nodeDragIds || []).map((_id) => this.entityManager.getEntityById(_id));
  }
  // 设置拖拽的节点
  setDragEntities(nodes) {
    this.updateConfig({
      nodeDragIds: nodes.map((_node) => _node.id),
      nodeDragIdsWithChildren: nodes.map((_node) => [_node.id, ..._node.allCollapsedChildren.map((_n) => _n.id)]).flat()
    });
  }
  onNodeHoveredChange(fn, debounceTime = 100) {
    return this.onConfigChanged(debounce(() => fn(this.getNodeHovered()), debounceTime));
  }
};
FlowRendererStateEntity.type = "FlowRendererStateEntity";

// src/flow-document.ts
import { omit } from "lodash";
import { inject as inject2, injectable as injectable2, multiInject, optional as optional2, postConstruct } from "inversify";
import { Emitter as Emitter5 } from "@flowgram.ai/utils";
import { EntityManager } from "@flowgram.ai/core";

// src/flow-virtual-tree.ts
import { Emitter as Emitter3 } from "@flowgram.ai/utils";
var FlowVirtualTree = class _FlowVirtualTree {
  constructor(root) {
    this.root = root;
    this.onTreeChangeEmitter = new Emitter3();
    /**
     * tree 结构变化时候触发
     */
    this.onTreeChange = this.onTreeChangeEmitter.event;
    this.map = /* @__PURE__ */ new Map();
  }
  dispose() {
    this.map.clear();
    this.onTreeChangeEmitter.dispose();
  }
  getInfo(node) {
    let res = this.map.get(node);
    if (!res) {
      res = { children: [] };
      this.map.set(node, res);
    }
    return res;
  }
  clear() {
    this.map.clear();
  }
  cloneMap() {
    const newMap = /* @__PURE__ */ new Map();
    for (const [key, value] of this.map) {
      newMap.set(key, {
        ...value,
        children: value.children.slice()
      });
    }
    return newMap;
  }
  clone() {
    const newTree = new _FlowVirtualTree(this.root);
    newTree.map = this.cloneMap();
    return newTree;
  }
  remove(node, withChildren = true) {
    this.removeParent(node);
    if (withChildren) {
      this._removeChildren(node);
    }
    this.map.delete(node);
    this.fireTreeChange();
  }
  addChild(parent, child, index) {
    const parentInfo = this.getInfo(parent);
    const childInfo = this.getInfo(child);
    if (childInfo.parent) {
      if (childInfo.parent === parent) return child;
      if (childInfo.parent !== parent) {
        this.removeParent(child);
      }
    }
    const len = parentInfo.children.length;
    const idx = typeof index === "undefined" ? len - 1 : index - 1;
    const lastChild = parentInfo.children[idx];
    const nextChild = parentInfo.children[idx + 1];
    if (lastChild) this.getInfo(lastChild).next = child;
    if (nextChild) this.getInfo(nextChild).pre = child;
    childInfo.pre = lastChild;
    childInfo.next = nextChild;
    parentInfo.children.splice(idx + 1, 0, child);
    childInfo.parent = parent;
    this.fireTreeChange();
    return child;
  }
  moveChilds(parent, childs, index) {
    const parentInfo = this.getInfo(parent);
    const len = parentInfo.children.length;
    let childIndex = index ?? len;
    childs.forEach((child) => {
      const childInfo = this.getInfo(child);
      if (childInfo.parent) {
        this.removeParent(child);
      }
    });
    childs.forEach((child) => {
      const childInfo = this.getInfo(child);
      let lastChild = parentInfo.children[childIndex - 1];
      let nextChild = parentInfo.children[childIndex];
      if (lastChild) this.getInfo(lastChild).next = child;
      if (nextChild) this.getInfo(nextChild).pre = child;
      childInfo.pre = lastChild;
      childInfo.next = nextChild;
      parentInfo.children.splice(childIndex, 0, child);
      childInfo.parent = parent;
      childIndex++;
    });
    this.fireTreeChange();
    return childs;
  }
  getById(id) {
    for (const node of this.map.keys()) {
      if (node.id === id) return node;
    }
  }
  /**
   * 插入节点到后边
   * @param before
   * @param after
   */
  insertAfter(before, after) {
    const beforeInfo = this.getInfo(before);
    const afterInfo = this.getInfo(after);
    this.removeParent(after);
    if (beforeInfo.parent) {
      const parentInfo = this.getInfo(beforeInfo.parent);
      parentInfo.children.splice(parentInfo.children.indexOf(before) + 1, 0, after);
      const { next } = beforeInfo;
      if (next) {
        this.getInfo(next).pre = after;
      }
      afterInfo.next = next;
      beforeInfo.next = after;
      afterInfo.pre = before;
      afterInfo.parent = beforeInfo.parent;
    }
    this.fireTreeChange();
  }
  removeParent(node) {
    const info = this.getInfo(node);
    if (!info.parent) return;
    const parentInfo = this.getInfo(info.parent);
    const index = parentInfo.children.indexOf(node);
    parentInfo.children.splice(index, 1);
    const { pre, next } = info;
    if (pre) this.getInfo(pre).next = next;
    if (next) this.getInfo(next).pre = pre;
    this.fireTreeChange();
  }
  _removeChildren(node) {
    const children = this.getChildren(node);
    if (children.length > 0) {
      children.forEach((child) => {
        this._removeChildren(child);
        this.map.delete(child);
      });
    }
  }
  getParent(node) {
    return this.getInfo(node).parent;
  }
  getPre(node) {
    return this.getInfo(node).pre;
  }
  getNext(node) {
    return this.getInfo(node).next;
  }
  getChildren(node) {
    return this.getInfo(node).children;
  }
  traverse(fn, node = this.root, depth = 0, index = 0) {
    const breaked = fn(node, depth, index);
    if (breaked) return true;
    const info = this.getInfo(node);
    const shouldBreak = info.children.find((child, i) => this.traverse(fn, child, depth + 1, i));
    if (shouldBreak) return true;
  }
  /**
   * 通知文档树结构更新
   */
  fireTreeChange() {
    this.onTreeChangeEmitter.fire();
  }
  get size() {
    return this.map.size;
  }
  toString() {
    const ret = [];
    this.traverse((node, depth) => {
      if (depth === 0) {
        ret.push(node.id);
      } else {
        ret.push(`|${new Array(depth).fill("--").join("")} ${node.id}`);
      }
    });
    return `${ret.join("\n")}`;
  }
};

// src/flow-render-tree.ts
var FlowRenderTree = class extends FlowVirtualTree {
  constructor(root, originTree, document) {
    super(root);
    this.root = root;
    /**
     * 折叠的节点
     * @protected
     */
    this.nodesCollapsed = /* @__PURE__ */ new Set();
    this.originTree = originTree;
    this.onTreeChange = this.originTree.onTreeChange;
    this.document = document;
  }
  isCollapsed(node) {
    return this.nodesCollapsed.has(node);
  }
  get collapsedNodeList() {
    return Array.from(this.nodesCollapsed);
  }
  /**
   * 折叠元素
   * @param node
   * @param collapsed
   */
  setCollapsed(node, collapsed) {
    if (collapsed) {
      this.nodesCollapsed.add(node);
    } else {
      this.nodesCollapsed.delete(node);
    }
    this.originTree.fireTreeChange();
  }
  /**
   *
   */
  openNodeInsideCollapsed(node) {
    let curr = this.originTree.getInfo(node)?.parent;
    while (curr) {
      if (this.nodesCollapsed.has(curr)) {
        this.nodesCollapsed.delete(curr);
      }
      const { parent } = this.originTree.getInfo(curr) || {};
      curr = parent;
    }
    this.originTree.fireTreeChange();
  }
  /**
   * 更新结束节点等位置信息，分支里如果全是结束节点则要做相应的偏移
   */
  updateRenderStruct() {
    this.map = this.originTree.cloneMap();
    if (this.document.config.get("END_NODES_REFINE_BRANCH" /* END_NODES_REFINE_BRANCH */)) {
      this.refineBranch(this.root);
    }
    this.hideCollapsed();
  }
  /**
   * 隐藏收起节点
   */
  hideCollapsed() {
    this.nodesCollapsed.forEach((collapsedNode) => {
      const collapsedNodeInfo = this.getInfo(collapsedNode);
      if (!collapsedNodeInfo) {
        this.nodesCollapsed.delete(collapsedNode);
        return;
      }
      const iconChild = collapsedNodeInfo.children.find(
        (_child) => _child.flowNodeType === "blockIcon" /* BLOCK_ICON */ || _child.flowNodeType === "blockOrderIcon" /* BLOCK_ORDER_ICON */
      );
      if (iconChild) {
        const iconInfo = this.getInfo(iconChild);
        iconInfo.next = void 0;
        iconInfo.pre = void 0;
        collapsedNodeInfo.children = [iconChild];
        return;
      }
      collapsedNodeInfo.children = [];
    });
  }
  // 节点是否为结束节点
  isNodeEnd(node) {
    if (node.getNodeMeta().isNodeEnd) {
      return true;
    }
    const { children } = this.getInfo(node);
    if (children.length > 0 && node.isInlineBlocks) {
      return children.every((child) => this.isNodeEnd(child));
    }
    if (node.isInlineBlock) {
      return this.isNodeEnd(children[children.length - 1]);
    }
    return false;
  }
  /**
   * 优化精简分支线
   * - 结束节点拉直分支线
   */
  refineBranch(block) {
    let curr = this.getInfo(block).children[0];
    while (curr) {
      if (curr.flowNodeType === "dynamicSplit" /* DYNAMIC_SPLIT */ || curr.flowNodeType === "staticSplit" /* STATIC_SPLIT */) {
        const { next, children: branchChildren } = this.getInfo(curr);
        const { children } = this.getInfo(branchChildren[1]);
        const passBlocks = (children || []).filter((child) => !this.isNodeEnd(child));
        const shouldDragAllNextNodes = passBlocks.length === 1;
        if (shouldDragAllNextNodes && next) {
          this.dragNextNodesToBlock(passBlocks[0], next);
        }
        children?.forEach((child) => {
          this.refineBranch(child);
        });
        if (shouldDragAllNextNodes) {
          break;
        }
      }
      curr = curr.next;
    }
  }
  // 结束节点拽分支，将后续节点拽到对应分支内
  dragNextNodesToBlock(toBlock, next) {
    const toBlockInfo = this.getInfo(toBlock);
    const nextInfo = this.getInfo(next);
    const toBlockLastChild = toBlockInfo.children[toBlock.children.length - 1];
    if (nextInfo.parent) {
      const nextParentInfo = this.getInfo(nextInfo.parent);
      if (nextInfo.pre) {
        this.getInfo(nextInfo.pre).next = void 0;
      }
      if (toBlockLastChild) {
        const lastChildInfo = this.getInfo(toBlockLastChild);
        lastChildInfo.next = next;
        nextInfo.pre = toBlockLastChild;
      }
      const nextNodeIndex = nextParentInfo.children.indexOf(next);
      const allNextNodes = nextParentInfo.children.slice(nextNodeIndex);
      nextParentInfo.children = nextParentInfo.children.slice(0, nextNodeIndex);
      for (const node of allNextNodes) {
        const nodeInfo = this.getInfo(node);
        toBlockInfo.children.push(node);
        nodeInfo.parent = toBlock;
      }
    }
  }
  getInfo(node) {
    const info = this.map.get(node) || this.originTree.getInfo(node);
    return info;
  }
  // 或者originTree节点的信息
  getOriginInfo(node) {
    return this.originTree.getInfo(node);
  }
  // 获取收起的隐藏节点
  getCollapsedChildren(node) {
    return this.getOriginInfo(node).children || [];
  }
  remove() {
    throw new Error("Render Tree cannot use remove node");
  }
  addChild() {
    throw new Error("Render tree cannot use add child");
  }
  insertAfter() {
    throw new Error("Render tree cannot use insert after");
  }
  removeParent() {
    throw new Error("Render tree cannot use remove parent");
  }
};

// src/flow-document-options.ts
var FlowDocumentOptions = Symbol("FlowDocumentOptions");
var FlowDocumentOptionsDefault = {
  allNodesDefaultExpanded: false
};
var ConstantKeys = {
  ...DefaultSpacingKey,
  /**
   * loop 底部留白
   */
  INLINE_SPACING_BOTTOM: "INLINE_SPACING_BOTTOM",
  /**
   * inlineBlocks 的 inlineTop
   * loop 循环线条上边距
   */
  INLINE_BLOCKS_INLINE_SPACING_TOP: "INLINE_BLOCKS_INLINE_SPACING_TOP",
  /**
   * inlineBlocks 的 inlineBottom
   * loop 循环线条的下边距
   *
   */
  INLINE_BLOCKS_INLINE_SPACING_BOTTOM: "INLINE_BLOCKS_INLINE_SPACING_BOTTOM",
  /***
   * 线条、label 默认颜色
   */
  BASE_COLOR: "BASE_COLOR",
  /***
   * 线条、label 激活后的颜色
   */
  BASE_ACTIVATED_COLOR: "BASE_ACTIVATED_COLOR",
  /**
   * Branch bottom margin
   * 分支下边距
   */
  INLINE_BLOCKS_PADDING_TOP: "INLINE_BLOCKS_PADDING_TOP"
};

// src/flow-document-contribution.ts
var FlowDocumentContribution = Symbol("FlowDocumentContribution");

// src/flow-document-config.ts
import { inject, injectable, optional } from "inversify";
import { Emitter as Emitter4 } from "@flowgram.ai/utils";
var FlowDocumentConfigDefaultData = Symbol("FlowDocumentConfigDefaultData");
var FlowDocumentConfig = class {
  constructor(_data = {}) {
    this._data = _data;
    this.onDataChangeEmitter = new Emitter4();
    this.onChange = this.onDataChangeEmitter.event;
  }
  get(key) {
    return this._data[key];
  }
  set(key, value) {
    if (this.get(key) !== value) {
      this._data[key] = value;
      this.onDataChangeEmitter.fire(key);
    }
  }
  registerConfigs(config) {
    Object.keys(config).forEach((key) => {
      this.set(key, config[key]);
    });
  }
};
FlowDocumentConfig = __decorateClass([
  injectable(),
  __decorateParam(0, inject(FlowDocumentConfigDefaultData)),
  __decorateParam(0, optional())
], FlowDocumentConfig);

// src/flow-document.ts
var FlowDocumentProvider = Symbol("FlowDocumentProvider");
var FlowDocument = class {
  constructor() {
    this.contributions = [];
    this.registers = /* @__PURE__ */ new Map();
    this.nodeRegistryCache = /* @__PURE__ */ new Map();
    this.nodeDataRegistries = [];
    this.layouts = [];
    this.currentLayoutKey = "";
    this.onNodeUpdateEmitter = new Emitter5();
    this.onNodeCreateEmitter = new Emitter5();
    this.onNodeDisposeEmitter = new Emitter5();
    this.onLayoutChangeEmitter = new Emitter5();
    this.onNodeUpdate = this.onNodeUpdateEmitter.event;
    this.onNodeCreate = this.onNodeCreateEmitter.event;
    this.onNodeDispose = this.onNodeDisposeEmitter.event;
    this.onLayoutChange = this.onLayoutChangeEmitter.event;
    this._disposed = false;
  }
  /**
   *
   */
  get disposed() {
    return this._disposed;
  }
  init() {
    if (!this.options) this.options = FlowDocumentOptionsDefault;
    this.currentLayoutKey = this.options.defaultLayout || "vertical-fixed-layout" /* VERTICAL_FIXED_LAYOUT */;
    this.contributions.forEach((contrib) => contrib.registerDocument?.(this));
    this.root = this.addNode({ id: "root", type: "root" /* ROOT */ });
    this.originTree = new FlowVirtualTree(this.root);
    this.transformer = this.entityManager.createEntity(
      FlowDocumentTransformerEntity,
      { document: this }
    );
    this.renderState = this.entityManager.createEntity(FlowRendererStateEntity);
    this.renderTree = new FlowRenderTree(this.root, this.originTree, this);
    this.layout.reload?.();
  }
  /**
   * 从数据初始化 O(n)
   * @param json
   */
  /**
   * 加载数据，可以被重载
   * @param json 文档数据更新
   * @param fireRender 是否要触发渲染，默认 true
   */
  fromJSON(json, fireRender = true) {
    if (this._disposed) return;
    this.originTree.clear();
    this.renderTree.clear();
    this.entityManager.changeEntityLocked = true;
    const oldNodes = this.entityManager.getEntities(FlowNodeEntity);
    const newNodes = [this.root];
    this.addBlocksAsChildren(this.root, json.nodes || [], newNodes);
    oldNodes.forEach((node) => {
      if (!newNodes.includes(node)) {
        node.dispose();
      }
    });
    this.entityManager.changeEntityLocked = false;
    this.transformer.loading = false;
    if (fireRender) this.fireRender();
  }
  get layout() {
    const layout = this.layouts.find((layout2) => layout2.name == this.currentLayoutKey);
    if (!layout) {
      throw new Error(`Unknown flow layout: ${this.currentLayoutKey}`);
    }
    return layout;
  }
  async load() {
    await Promise.all(this.contributions.map((c) => c.loadDocument?.(this)));
  }
  get loading() {
    return this.transformer.loading;
  }
  /**
   * 触发 render
   */
  fireRender() {
    if (this.transformer.isTreeDirty()) {
      this.entityManager.fireEntityChanged(FlowNodeEntity.type);
      this.entityManager.fireEntityChanged(FlowDocumentTransformerEntity.type);
    }
  }
  /**
   * 从指定节点的下一个节点新增
   * @param fromNode
   * @param json
   */
  addFromNode(fromNode, json) {
    const node = typeof fromNode === "string" ? this.getNode(fromNode) : fromNode;
    this.entityManager.changeEntityLocked = true;
    const { parent } = node;
    const result = this.addNode({
      ...json,
      parent
      // originParent,
    });
    this.originTree.insertAfter(node, result);
    this.entityManager.changeEntityLocked = false;
    this.entityManager.fireEntityChanged(FlowNodeEntity.type);
    return result;
  }
  removeNode(node) {
    if (typeof node === "string") {
      this.getNode(node)?.dispose();
    } else {
      node.dispose();
    }
  }
  /**
   * 添加节点，如果节点已经存在则不会重复创建
   * @param data
   * @param addedNodes
   */
  addNode(data, addedNodes, ignoreCreateAndUpdateEvent, ignoreBlocks) {
    const { id, type = "block", originParent, parent, meta, hidden, index } = data;
    let node = this.getNode(id);
    let isNew = false;
    const register = this.getNodeRegistry(type, data.originParent);
    if (node && node.flowNodeType !== data.type) {
      node.dispose();
      node = void 0;
    }
    if (!node) {
      const { dataRegistries } = register;
      node = this.entityManager.createEntity(FlowNodeEntity, {
        id,
        document: this,
        flowNodeType: type,
        originParent,
        meta
      });
      const datas = dataRegistries ? this.nodeDataRegistries.concat(...dataRegistries) : this.nodeDataRegistries;
      node.addInitializeData(datas);
      node.onDispose(() => this.onNodeDisposeEmitter.fire({ node }));
      this.options.fromNodeJSON?.(node, data, true);
      isNew = true;
    } else {
      this.options.fromNodeJSON?.(node, data, false);
    }
    node.initData({
      originParent,
      parent,
      meta,
      hidden,
      index
    });
    if (node.isStart) {
      this.root.addChild(node);
    }
    addedNodes?.push(node);
    if (register.onCreate) {
      const extendNodes = register.onCreate(node, data);
      if (extendNodes && addedNodes) {
        addedNodes.push(...extendNodes);
      }
    } else if (data.blocks && data.blocks.length > 0 && !ignoreBlocks) {
      if (!data.blocks[0].type) {
        this.addInlineBlocks(node, data.blocks, addedNodes);
      } else {
        this.addBlocksAsChildren(node, data.blocks, addedNodes);
      }
    }
    if (!ignoreCreateAndUpdateEvent) {
      if (isNew) {
        this.onNodeCreateEmitter.fire({
          node,
          data,
          json: data
        });
      } else {
        this.onNodeUpdateEmitter.fire({ node, data, json: data });
      }
    }
    return node;
  }
  addBlocksAsChildren(parent, blocks, addedNodes) {
    for (const block of blocks) {
      this.addNode(
        {
          ...block,
          parent
        },
        addedNodes
      );
    }
  }
  /**
   * block 格式：
   * node:  (最原始的 id)
   *  blockIcon
   *  inlineBlocks
   *    block
   *      blockOrderIcon
   *    block
   *      blockOrderIcon
   * @param node
   * @param blocks
   * @param addedNodes
   */
  addInlineBlocks(node, blocks, addedNodes = []) {
    const blockIconNode = this.addNode({
      id: `$blockIcon$${node.id}`,
      type: "blockIcon" /* BLOCK_ICON */,
      originParent: node,
      parent: node
    });
    addedNodes.push(blockIconNode);
    const inlineBlocksNode = this.addNode({
      id: `$inlineBlocks$${node.id}`,
      type: "inlineBlocks" /* INLINE_BLOCKS */,
      originParent: node,
      parent: node
    });
    addedNodes.push(inlineBlocksNode);
    blocks.forEach((blockData) => {
      this.addBlock(node, blockData, addedNodes);
    });
    return addedNodes;
  }
  /**
   * 添加单个 block
   * @param target
   * @param blockData
   * @param addedNodes
   * @param parent 默认去找 $inlineBlocks$
   */
  addBlock(target, blockData, addedNodes, parent, index) {
    const node = typeof target === "string" ? this.getNode(target) : target;
    const { onBlockChildCreate } = node.getNodeRegistry();
    if (onBlockChildCreate) {
      return onBlockChildCreate(node, blockData, addedNodes);
    }
    parent = parent || this.getNode(`$inlineBlocks$${node.id}`);
    const block = this.addNode({
      ...omit(blockData, "blocks"),
      type: blockData.type || "block" /* BLOCK */,
      originParent: node,
      parent,
      index
    });
    if (blockData.meta?.defaultCollapsed) {
      block.collapsed = true;
    }
    const blockOrderIcon = this.addNode({
      id: `$blockOrderIcon$${blockData.id}`,
      type: "blockOrderIcon" /* BLOCK_ORDER_ICON */,
      originParent: node,
      meta: blockData.meta,
      data: blockData.data,
      parent: block
    });
    addedNodes?.push(block, blockOrderIcon);
    if (blockData.blocks) {
      this.addBlocksAsChildren(block, blockData.blocks, addedNodes);
    }
    return block;
  }
  /**
   * 根据 id 获取节点
   * @param id
   */
  getNode(id) {
    if (!id) return void 0;
    return this.entityManager.getEntityById(id);
  }
  /**
   * 注册节点
   * @param registries
   */
  registerFlowNodes(...registries) {
    registries.forEach((newRegistry) => {
      if (!newRegistry) {
        throw new Error("[FlowDocument] registerFlowNodes parameters get undefined registry.");
      }
      const preRegistry = this.registers.get(newRegistry.type);
      this.registers.set(newRegistry.type, {
        ...preRegistry,
        ...newRegistry,
        meta: {
          ...preRegistry?.meta,
          ...newRegistry?.meta
        },
        extendChildRegistries: FlowNodeRegistry.mergeChildRegistries(
          preRegistry?.extendChildRegistries,
          newRegistry?.extendChildRegistries
        )
      });
    });
  }
  /**
   * Check node extend
   * @param currentType
   * @param parentType
   */
  isExtend(currentType, parentType) {
    return (this.getNodeRegistry(currentType).__extends__ || []).includes(parentType);
  }
  /**
   * 导出数据，可以重载
   */
  toJSON() {
    return {
      nodes: this.root.toJSON().blocks
    };
  }
  /**
   * @deprecated
   * use `getNodeRegistry` instead
   */
  getNodeRegister(type, originParent) {
    return this.getNodeRegistry(type, originParent);
  }
  getNodeRegistry(type, originParent) {
    const typeKey = `${type}_${originParent?.flowNodeType || ""}`;
    if (this.nodeRegistryCache.has(typeKey)) {
      return this.nodeRegistryCache.get(typeKey);
    }
    const customDefaultRegistry = this.options.getNodeDefaultRegistry?.(type);
    let register = this.registers.get(type) || { type };
    const extendRegisters = [];
    const extendKey = register.extend;
    if (register.extend && this.registers.has(register.extend)) {
      register = FlowNodeRegistry.merge(
        this.getNodeRegistry(register.extend),
        register,
        register.type
      );
    }
    if (originParent) {
      const extendRegister = this.getNodeRegistry(
        originParent.flowNodeType
      ).extendChildRegistries?.find((r) => r.type === type);
      if (extendRegister) {
        if (extendRegister.extend && this.registers.has(extendRegister.extend)) {
          extendRegisters.push(this.registers.get(extendRegister.extend));
        }
        extendRegisters.push(extendRegister);
      }
    }
    register = FlowNodeRegistry.extend(register, extendRegisters);
    const defaultNodeMeta = DEFAULT_FLOW_NODE_META(type, this);
    defaultNodeMeta.spacing = this.options?.constants?.[ConstantKeys.NODE_SPACING] || defaultNodeMeta.spacing;
    const res = {
      ...customDefaultRegistry,
      ...register,
      meta: {
        ...defaultNodeMeta,
        ...customDefaultRegistry?.meta,
        ...register.meta
      }
    };
    if (extendKey) {
      res.extend = extendKey;
    }
    this.nodeRegistryCache.set(typeKey, res);
    return res;
  }
  /**
   * 节点注入数据
   * @param nodeDatas
   */
  registerNodeDatas(...nodeDatas) {
    this.nodeDataRegistries.push(...nodeDatas);
  }
  /**
   * traverse all nodes, O(n)
   *   R
   *   |
   *   +---1
   *   |   |
   *   |   +---1.1
   *   |   |
   *   |   +---1.2
   *   |   |
   *   |   +---1.3
   *   |   |    |
   *   |   |    +---1.3.1
   *   |   |    |
   *   |   |    +---1.3.2
   *   |   |
   *   |   +---1.4
   *   |
   *   +---2
   *       |
   *       +---2.1
   *
   *  sort: [1, 1.1, 1.2, 1.3, 1.3.1, 1.3.2, 1.4, 2, 2.1]
   * @param fn
   * @param node
   * @param depth
   * @return isBreak
   */
  traverse(fn, node = this.root, depth = 0) {
    return this.originTree.traverse(fn, node, depth);
  }
  get size() {
    return this.getAllNodes().length;
  }
  hasNode(nodeId) {
    return !!this.entityManager.getEntityById(nodeId);
  }
  getAllNodes() {
    return this.entityManager.getEntities(FlowNodeEntity);
  }
  toString() {
    return this.originTree.toString();
  }
  /**
   * 返回需要渲染的数据
   */
  getRenderDatas(dataRegistry, containHiddenNodes = true) {
    const result = [];
    this.renderTree.traverse((node) => {
      if (!containHiddenNodes && node.hidden) return;
      result.push(node.getData(dataRegistry));
    });
    return result;
  }
  /**
   * 移动节点
   * @param param0
   * @returns
   */
  moveNodes({
    dropNodeId,
    sortNodeIds,
    inside = false
  }) {
    const dropEntity = this.getNode(dropNodeId);
    if (!dropEntity) {
      return;
    }
    const sortNodes = sortNodeIds.map((id) => this.getNode(id));
    this.entityManager.changeEntityLocked = true;
    for (const node of sortNodes.reverse()) {
      if (inside) {
        this.originTree.addChild(dropEntity, node, 0);
      } else {
        this.originTree.insertAfter(dropEntity, node);
      }
    }
    this.entityManager.changeEntityLocked = false;
    this.fireRender();
  }
  /**
   * 移动子节点
   * @param param0
   * @returns
   */
  moveChildNodes({
    toParentId,
    toIndex,
    nodeIds
  }) {
    if (nodeIds.length === 0) {
      return;
    }
    const toParent = this.getNode(toParentId);
    if (!toParent) {
      return;
    }
    this.entityManager.changeEntityLocked = true;
    this.originTree.moveChilds(
      toParent,
      nodeIds.map((nodeId) => this.getNode(nodeId)),
      toIndex
    );
    this.entityManager.changeEntityLocked = false;
    this.fireRender();
  }
  /**
   * 注册布局
   * @param layout
   */
  registerLayout(layout) {
    this.layouts.push(layout);
  }
  /**
   * 更新布局
   * @param layoutKey
   */
  setLayout(layoutKey) {
    if (this.currentLayoutKey === layoutKey) return;
    const layout = this.layouts.find((layout2) => layout2.name === layoutKey);
    if (!layout) return;
    this.currentLayoutKey = layoutKey;
    this.transformer.clear();
    layout.reload?.();
    this.fireRender();
    this.onLayoutChangeEmitter.fire(this.layout);
  }
  /**
   * 切换垂直或水平布局
   */
  toggleFixedLayout() {
    this.setLayout(
      this.layout.name === "horizontal-fixed-layout" /* HORIZONTAL_FIXED_LAYOUT */ ? "vertical-fixed-layout" /* VERTICAL_FIXED_LAYOUT */ : "horizontal-fixed-layout" /* HORIZONTAL_FIXED_LAYOUT */
    );
  }
  dispose() {
    if (this._disposed) return;
    this.registers.clear();
    this.nodeRegistryCache.clear();
    this.originTree.dispose();
    this.renderTree.dispose();
    this.onNodeUpdateEmitter.dispose();
    this.onNodeCreateEmitter.dispose();
    this.onNodeDisposeEmitter.dispose();
    this.onLayoutChangeEmitter.dispose();
    this._disposed = true;
  }
};
__decorateClass([
  inject2(EntityManager)
], FlowDocument.prototype, "entityManager", 2);
__decorateClass([
  inject2(FlowDocumentConfig)
], FlowDocument.prototype, "config", 2);
__decorateClass([
  inject2(FlowDocumentOptions),
  optional2()
], FlowDocument.prototype, "options", 2);
__decorateClass([
  multiInject(FlowDocumentContribution),
  optional2()
], FlowDocument.prototype, "contributions", 2);
__decorateClass([
  postConstruct()
], FlowDocument.prototype, "init", 1);
FlowDocument = __decorateClass([
  injectable2()
], FlowDocument);

// src/flow-document-container-module.ts
import { ContainerModule } from "inversify";

// src/services/flow-drag-service.ts
import { inject as inject3, injectable as injectable3 } from "inversify";
import { Emitter as Emitter6 } from "@flowgram.ai/utils";
import { EntityManager as EntityManager2 } from "@flowgram.ai/core";

// src/services/flow-group-service/flow-group-controller.ts
var FlowGroupController = class _FlowGroupController {
  constructor(groupNode) {
    this.groupNode = groupNode;
  }
  get nodes() {
    return this.groupNode.collapsedChildren || [];
  }
  get collapsed() {
    const groupTransformData = this.groupNode.getData(FlowNodeTransformData);
    return groupTransformData.collapsed;
  }
  collapse() {
    this.collapsed = true;
  }
  expand() {
    this.collapsed = false;
  }
  /** 获取分组外围的最大边框 */
  get bounds() {
    const groupNodeBounds = this.groupNode.getData(FlowNodeTransformData).bounds;
    return groupNodeBounds;
  }
  /** 是否是开始节点 */
  isStartNode(node) {
    if (!node) {
      return false;
    }
    const nodes = this.nodes;
    if (!nodes[0]) {
      return false;
    }
    return node.id === nodes[0].id;
  }
  /** 是否是结束节点 */
  isEndNode(node) {
    if (!node) {
      return false;
    }
    const nodes = this.nodes;
    if (!nodes[nodes.length - 1]) {
      return false;
    }
    return node.id === nodes[nodes.length - 1].id;
  }
  set note(note) {
    this.groupNode.getNodeMeta().note = note;
  }
  get note() {
    return this.groupNode.getNodeMeta().note || "";
  }
  set noteHeight(height) {
    this.groupNode.getNodeMeta().noteHeight = height;
  }
  get noteHeight() {
    return this.groupNode.getNodeMeta().noteHeight || 0;
  }
  get positionConfig() {
    return this.groupNode.getNodeMeta().positionConfig;
  }
  set collapsed(collapsed) {
    const groupTransformData = this.groupNode.getData(FlowNodeTransformData);
    groupTransformData.collapsed = collapsed;
    groupTransformData.localDirty = true;
    if (groupTransformData.parent) groupTransformData.parent.localDirty = true;
    if (groupTransformData.parent?.firstChild)
      groupTransformData.parent.firstChild.localDirty = true;
  }
  set hovered(hovered) {
    const groupRenderData = this.groupNode.getData(FlowNodeRenderData);
    if (hovered) {
      groupRenderData.toggleMouseEnter();
    } else {
      groupRenderData.toggleMouseLeave();
    }
    if (groupRenderData.hovered === hovered) {
      return;
    }
    groupRenderData.hovered = hovered;
  }
  get hovered() {
    const groupRenderData = this.groupNode.getData(FlowNodeRenderData);
    return groupRenderData.hovered;
  }
  static create(groupNode) {
    if (!groupNode) {
      return;
    }
    if (!FlowGroupUtils.isGroupNode(groupNode)) {
      return;
    }
    return new _FlowGroupController(groupNode);
  }
};

// src/services/flow-group-service/flow-group-utils.ts
var FlowGroupUtils;
((FlowGroupUtils2) => {
  const findNodeParents = (node) => {
    const parents = [];
    let parent = node.parent;
    while (parent) {
      parents.push(parent);
      parent = parent.parent;
    }
    return parents;
  };
  const isNodeInGroup = (node) => {
    if (node?.parent?.flowNodeType === "group" /* GROUP */) {
      return true;
    }
    return false;
  };
  FlowGroupUtils2.validate = (nodes) => {
    if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
      return false;
    }
    const isGroupRelatedNode = nodes.some((node) => (0, FlowGroupUtils2.isGroupNode)(node));
    if (isGroupRelatedNode) return false;
    const hasGroup = nodes.some((node) => node && isNodeInGroup(node));
    if (hasGroup) return false;
    const parent = nodes[0].parent;
    const isSameParent = nodes.every((node) => node.parent === parent);
    if (!isSameParent) return false;
    const indexes = nodes.map((node) => node.index).sort((a, b) => a - b);
    const isIndexContinuous = indexes.every((index, i, arr) => {
      if (i === 0) {
        return true;
      }
      return index === arr[i - 1] + 1;
    });
    if (!isIndexContinuous) return false;
    const parents = findNodeParents(nodes[0]);
    const parentsInGroup = parents.some((parent2) => isNodeInGroup(parent2));
    if (parentsInGroup) return false;
    return true;
  };
  FlowGroupUtils2.getNodeGroupController = (node) => {
    if (!node) {
      return;
    }
    if (!isNodeInGroup(node)) {
      return;
    }
    const groupNode = node?.parent;
    return FlowGroupController.create(groupNode);
  };
  FlowGroupUtils2.getNodeRecursionGroupController = (node) => {
    if (!node) {
      return;
    }
    const group = (0, FlowGroupUtils2.getNodeGroupController)(node);
    if (group) {
      return group;
    }
    if (node.parent) {
      return (0, FlowGroupUtils2.getNodeRecursionGroupController)(node.parent);
    }
    return;
  };
  FlowGroupUtils2.isGroupNode = (group) => group.flowNodeType === "group" /* GROUP */;
})(FlowGroupUtils || (FlowGroupUtils = {}));

// src/services/flow-drag-service.ts
var FlowDragService = class {
  constructor() {
    this.onDropEmitter = new Emitter6();
    this.onDrop = this.onDropEmitter.event;
  }
  get renderState() {
    return this.document.renderState;
  }
  // 拖拽所有节点中的首个节点
  get dragStartNode() {
    return this.renderState.getDragStartEntity();
  }
  // 拖拽的所有节点
  get dragNodes() {
    return this.renderState.getDragEntities();
  }
  // 放置的区域
  get dropNodeId() {
    return this.renderState.getNodeDroppingId();
  }
  // 是否在拖拽分支
  get isDragBranch() {
    return this.dragStartNode?.isInlineBlock;
  }
  // 拖拽的所有节点及其自节点
  get nodeDragIdsWithChildren() {
    return this.renderState.config.nodeDragIdsWithChildren || [];
  }
  get dragging() {
    const renderData = this.dragStartNode?.getData(FlowNodeRenderData);
    return !!renderData?.dragging;
  }
  get labelSide() {
    return this.renderState.config.dragLabelSide;
  }
  /**
   * 放置到目标分支
   */
  dropBranch() {
    this.dropNode();
  }
  /**
   * 移动到目标节点
   */
  dropNode() {
    const dropEntity = this.document.getNode(this.dropNodeId);
    if (!dropEntity) {
      return;
    }
    const sortNodes = [];
    let curr = this.dragStartNode;
    while (curr && this.dragNodes.includes(curr)) {
      sortNodes.push(curr);
      curr = curr.next;
    }
    this.operationService.dragNodes({
      dropNode: dropEntity,
      nodes: sortNodes
    });
    if (sortNodes.length > 0) {
      this.onDropEmitter.fire({
        dropNode: dropEntity,
        dragNodes: sortNodes
      });
    }
  }
  /**
   * 拖拽是否可以释放在该节点后面
   */
  isDroppableNode(node) {
    if (!this.dragging || this.isDragBranch) {
      return false;
    }
    if (this.nodeDragIdsWithChildren.includes(node.id) || node.next && this.nodeDragIdsWithChildren.includes(node.next.id)) {
      return false;
    }
    if (node.isInlineBlocks || node.isInlineBlock) {
      return false;
    }
    const hasGroupNode = this.dragNodes.some(
      (node2) => node2.flowNodeType === "group" /* GROUP */
    );
    if (hasGroupNode) {
      const group = FlowGroupUtils.getNodeRecursionGroupController(node);
      if (group) {
        return false;
      }
    }
    return true;
  }
  /**
   * 拖拽分支是否可以释放在该分支
   * @param node 拖拽的分支节点
   * @param side 分支的前面还是后面
   */
  isDroppableBranch(node, side = "normal_branch" /* NORMAL_BRANCH */) {
    if (this.isDragBranch) {
      if (
        // 拖拽到分支
        !node.isInlineBlock || // 只能在同一分支条件下
        node.parent !== this.dragStartNode.parent || // 自己不能拖拽给自己
        node === this.dragStartNode
      ) {
        return false;
      }
      if (side === "normal_branch" /* NORMAL_BRANCH */ && node.next !== this.dragStartNode) {
        return true;
      }
      if (side === "pre_branch" /* PRE_BRANCH */ && node.pre !== this.dragStartNode) {
        return true;
      }
    }
    return false;
  }
};
__decorateClass([
  inject3(FlowDocument)
], FlowDragService.prototype, "document", 2);
__decorateClass([
  inject3(FlowOperationBaseService)
], FlowDragService.prototype, "operationService", 2);
__decorateClass([
  inject3(EntityManager2)
], FlowDragService.prototype, "entityManager", 2);
FlowDragService = __decorateClass([
  injectable3()
], FlowDragService);

// src/services/flow-operation-base-service.ts
import { inject as inject4, injectable as injectable4, postConstruct as postConstruct2 } from "inversify";
import { DisposableCollection, Emitter as Emitter7 } from "@flowgram.ai/utils";
import { EntityManager as EntityManager3 } from "@flowgram.ai/core";
var FlowOperationBaseServiceImpl = class {
  constructor() {
    this.onNodeAddEmitter = new Emitter7();
    this.onNodeAdd = this.onNodeAddEmitter.event;
    this.toDispose = new DisposableCollection();
    this.onNodeMoveEmitter = new Emitter7();
    this.onNodeMove = this.onNodeMoveEmitter.event;
  }
  init() {
    this.toDispose.pushAll([this.onNodeAddEmitter, this.onNodeMoveEmitter]);
  }
  addNode(nodeJSON, config = {}) {
    const { parent, index, hidden } = config;
    let parentEntity;
    if (parent) {
      parentEntity = this.toNodeEntity(parent);
    }
    let register;
    if (parentEntity) {
      register = parentEntity.getNodeRegistry();
    }
    const addJSON = {
      ...nodeJSON,
      type: nodeJSON.type || "block" /* BLOCK */
    };
    const addNodeData = {
      ...addJSON,
      parent: parentEntity,
      index,
      hidden
    };
    let added;
    if (parentEntity && register?.addChild) {
      added = register.addChild(parentEntity, addJSON, {
        index,
        hidden
      });
    } else {
      added = this.document.addNode(addNodeData);
    }
    this.onNodeAddEmitter.fire({
      node: added,
      data: addNodeData
    });
    return added;
  }
  addFromNode(fromNode, nodeJSON) {
    return this.document.addFromNode(fromNode, nodeJSON);
  }
  deleteNode(node) {
    this.document.removeNode(node);
  }
  deleteNodes(nodes) {
    (nodes || []).forEach((node) => {
      this.deleteNode(node);
    });
  }
  addBlock(target, blockJSON, config = {}) {
    const { parent, index } = config;
    return this.document.addBlock(target, blockJSON, void 0, parent, index);
  }
  moveNode(node, config = {}) {
    const { parent: newParent, index } = config;
    const entity = this.toNodeEntity(node);
    const parent = entity?.parent;
    if (!parent) {
      return;
    }
    const newParentEntity = newParent ? this.toNodeEntity(newParent) : parent;
    if (!newParentEntity) {
      console.warn("no new parent found", newParent);
      return;
    }
    let toIndex = typeof index === "undefined" ? newParentEntity.collapsedChildren.length : index;
    return this.doMoveNode(entity, newParentEntity, toIndex);
  }
  /**
   * 拖拽节点
   * @param param0
   * @returns
   */
  dragNodes({ dropNode, nodes }) {
    if (nodes.length === 0) {
      return;
    }
    const startNode = nodes[0];
    const fromParent = startNode.parent;
    const toParent = dropNode.parent;
    if (!fromParent || !toParent) {
      return;
    }
    const fromIndex = fromParent.children.findIndex((child) => child === startNode);
    const dropIndex = toParent.children.findIndex((child) => child === dropNode);
    let toIndex = dropIndex + 1;
    if (fromParent === toParent && fromIndex < dropIndex) {
      toIndex = toIndex - nodes.length;
    }
    const value = {
      nodeIds: nodes.map((node) => node.id),
      fromParentId: fromParent.id,
      toParentId: toParent.id,
      fromIndex,
      toIndex
    };
    return this.apply({
      type: "moveChildNodes" /* moveChildNodes */,
      value
    });
  }
  /**
   * 执行操作
   * @param operation 可序列化的操作
   * @returns 操作返回
   */
  apply(operation) {
    const document = this.document;
    switch (operation.type) {
      case "addFromNode" /* addFromNode */:
        return document.addFromNode(operation.value.fromId, operation.value.data);
      case "deleteFromNode" /* deleteFromNode */:
        return document.getNode(operation.value?.data?.id)?.dispose();
      case "addBlock" /* addBlock */: {
        let parent;
        if (operation.value.parentId) {
          parent = document.getNode(operation.value.parentId);
        }
        return document.addBlock(
          operation.value.targetId,
          operation.value.blockData,
          void 0,
          parent,
          operation.value.index
        );
      }
      case "deleteBlock" /* deleteBlock */: {
        const entity = document.getNode(operation.value?.blockData.id);
        return entity?.dispose();
      }
      case "createGroup" /* createGroup */: {
        const groupNode = document.addFromNode(operation.value.targetId, {
          id: operation.value.groupId,
          type: "group" /* GROUP */
        });
        document.moveNodes({
          dropNodeId: operation.value.groupId,
          sortNodeIds: operation.value.nodeIds,
          inside: true
        });
        return groupNode;
      }
      case "ungroup" /* ungroup */: {
        document.moveNodes({
          dropNodeId: operation.value.groupId,
          sortNodeIds: operation.value.nodeIds
        });
        return document.getNode(operation.value.groupId)?.dispose();
      }
      case "moveNodes" /* moveNodes */: {
        return document.moveNodes({
          dropNodeId: operation.value.toId,
          sortNodeIds: operation.value.nodeIds
        });
      }
      case "moveBlock" /* moveBlock */: {
        return document.moveChildNodes({
          ...operation.value,
          nodeIds: [operation.value.nodeId]
        });
      }
      case "addNodes" /* addNodes */: {
        let fromId = operation.value.fromId;
        (operation.value.nodes || []).forEach((node) => {
          const added = document.addFromNode(fromId, node);
          fromId = added.id;
        });
        break;
      }
      case "deleteNodes" /* deleteNodes */: {
        (operation.value.nodes || []).forEach((node) => {
          const entity = document.getNode(node.id);
          entity?.dispose();
        });
        break;
      }
      case "addChildNode" /* addChildNode */: {
        return document.addNode({
          ...operation.value.data,
          parent: operation.value.parentId ? document.getNode(operation.value.parentId) : void 0,
          originParent: operation.value.originParentId ? document.getNode(operation.value.originParentId) : void 0,
          index: operation.value.index,
          hidden: operation.value.hidden
        });
      }
      case "deleteChildNode" /* deleteChildNode */:
        return document.getNode(operation.value.data.id)?.dispose();
      case "moveChildNodes" /* moveChildNodes */:
        return document.moveChildNodes(operation.value);
      default:
        throw new Error(`unknown operation type`);
    }
  }
  /**
   * 事务执行
   * @param transaction
   */
  transact(transaction) {
    transaction();
  }
  dispose() {
    this.toDispose.dispose();
  }
  toId(node) {
    return typeof node === "string" ? node : node.id;
  }
  toNodeEntity(node) {
    return typeof node === "string" ? this.document.getNode(node) : node;
  }
  getNodeIndex(node) {
    const entity = this.toNodeEntity(node);
    const parent = entity?.parent;
    if (!parent) {
      return -1;
    }
    return parent.children.findIndex((child) => child === entity);
  }
  doMoveNode(node, newParent, index) {
    if (!node.parent) {
      throw new Error("root node cannot move");
    }
    const event = {
      node,
      fromParent: node.parent,
      toParent: newParent,
      fromIndex: this.getNodeIndex(node),
      toIndex: index
    };
    this.document.moveChildNodes({
      nodeIds: [this.toId(node)],
      toParentId: this.toId(newParent),
      toIndex: index
    });
    this.onNodeMoveEmitter.fire(event);
  }
};
__decorateClass([
  inject4(EntityManager3)
], FlowOperationBaseServiceImpl.prototype, "entityManager", 2);
__decorateClass([
  inject4(FlowDocument)
], FlowOperationBaseServiceImpl.prototype, "document", 2);
__decorateClass([
  postConstruct2()
], FlowOperationBaseServiceImpl.prototype, "init", 1);
FlowOperationBaseServiceImpl = __decorateClass([
  injectable4()
], FlowOperationBaseServiceImpl);

// src/services/flow-group-service/flow-group-service.ts
import { nanoid } from "nanoid";
import { inject as inject5, injectable as injectable5 } from "inversify";
import { EntityManager as EntityManager4 } from "@flowgram.ai/core";
var FlowGroupService = class {
  /** 创建分组节点 */
  createGroup(nodes) {
    if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
      return;
    }
    if (!FlowGroupUtils.validate(nodes)) {
      return;
    }
    const sortedNodes = nodes.sort((a, b) => a.index - b.index);
    const fromNode = sortedNodes[0];
    const groupId = `group_${nanoid(5)}`;
    this.operationService.apply({
      type: "createGroup" /* createGroup */,
      value: {
        targetId: fromNode.id,
        groupId,
        nodeIds: nodes.map((node) => node.id)
      }
    });
    const groupNode = this.entityManager.getEntityById(groupId);
    if (!groupNode) {
      return;
    }
    const group = this.groupController(groupNode);
    if (!group) {
      return;
    }
    group.expand();
    return groupNode;
  }
  /** 删除分组 */
  deleteGroup(groupNode) {
    const json = groupNode.toJSON();
    if (!groupNode.pre || !json) {
      return;
    }
    this.operationService.apply({
      type: "deleteNodes" /* deleteNodes */,
      value: {
        fromId: groupNode.pre.id,
        nodes: [json]
      }
    });
  }
  /** 取消分组 */
  ungroup(groupNode) {
    const group = this.groupController(groupNode);
    if (!group) {
      return;
    }
    const nodes = group.nodes;
    if (!groupNode.pre) {
      return;
    }
    group.collapse();
    this.operationService.apply({
      type: "ungroup" /* ungroup */,
      value: {
        groupId: groupNode.id,
        targetId: groupNode.pre.id,
        nodeIds: nodes.map((node) => node.id)
      }
    });
  }
  /** 返回所有分组节点 */
  getAllGroups() {
    const allNodes = this.entityManager.getEntities(FlowNodeEntity);
    const groupNodes = allNodes.filter((node) => node.flowNodeType === "group" /* GROUP */);
    return groupNodes.map((node) => this.groupController(node)).filter(Boolean);
  }
  /** 获取分组控制器*/
  groupController(group) {
    return FlowGroupController.create(group);
  }
  static validate(nodes) {
    return FlowGroupUtils.validate(nodes);
  }
};
__decorateClass([
  inject5(EntityManager4)
], FlowGroupService.prototype, "entityManager", 2);
__decorateClass([
  inject5(FlowOperationBaseService)
], FlowGroupService.prototype, "operationService", 2);
FlowGroupService = __decorateClass([
  injectable5()
], FlowGroupService);

// src/layout/vertical-fixed-layout.ts
import { injectable as injectable6, inject as inject6, multiInject as multiInject2, optional as optional3 } from "inversify";
var DEFAULT_SCROLL = -36;
function isStructDataEqual(struct1, struct2) {
  return struct1.childrenLength === struct2.childrenLength && struct1.index === struct2.index;
}
var VerticalFixedLayout = class {
  constructor() {
    this.name = "vertical-fixed-layout" /* VERTICAL_FIXED_LAYOUT */;
    this.structDataMap = /* @__PURE__ */ new WeakMap();
  }
  get document() {
    return this.documentProvider();
  }
  reload() {
    this.structDataMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * 更新布局
   */
  update() {
    this.updateLocalTransform(this.document.root);
  }
  /**
   * 更新节点的偏移
   * @param node
   * @param forceChange
   */
  updateLocalTransform(node, forceChange = false) {
    const { children, parent, isInlineBlock } = node;
    const transform = node.getData(FlowNodeTransformData);
    const { getDelta, getOrigin } = node.getNodeRegistry();
    const lastStructData = this.structDataMap.get(node) || {
      childrenLength: 0,
      index: -1
    };
    node.clearMemoGlobal();
    let localDirty = transform.localDirty || forceChange;
    const newStructData = {
      index: node.index,
      childrenLength: node.children.length
    };
    if (!isStructDataEqual(lastStructData, newStructData)) {
      localDirty = true;
      this.structDataMap.set(node, newStructData);
    }
    let siblingDirty = false;
    if (children.length > 0) {
      for (const child of children) {
        const childDirty = this.updateLocalTransform(child, siblingDirty);
        if (childDirty) {
          siblingDirty = true;
          localDirty = true;
        }
      }
    }
    if (!localDirty) return false;
    node.clearMemoLocal();
    transform.transform.update({
      origin: getOrigin ? getOrigin(transform, this) : this.getDefaultNodeOrigin()
    });
    const preTransform = transform.pre;
    const delta = getDelta?.(transform, this) || { x: 0, y: 0 };
    const inlineSpacingPre = isInlineBlock && transform.parent?.inlineSpacingPre ? transform.parent?.inlineSpacingPre : 0;
    const fromParentDelta = parent?.getNodeRegistry().getChildDelta?.(transform, this) || {
      x: 0,
      y: 0
    };
    delta.x += fromParentDelta.x;
    delta.y += fromParentDelta.y;
    const position = { x: delta.x, y: delta.y };
    if (isInlineBlock) {
      position.y += inlineSpacingPre;
    } else {
      position.y += preTransform?.localBounds.bottom || 0;
      position.y += preTransform?.spacing || 0;
    }
    transform.transform.update({
      size: transform.data.size,
      position
    });
    this.onAfterUpdateLocalTransform(transform);
    transform.localDirty = false;
    return true;
  }
  onAfterUpdateLocalTransform(transform) {
    const { onAfterUpdateLocalTransform } = transform.entity.getNodeRegistry();
    onAfterUpdateLocalTransform?.(transform, this);
    this.contribs?.forEach((_contrib) => {
      _contrib?.onAfterUpdateLocalTransform?.(transform, this);
    });
  }
  getNodeTransform(node) {
    return node.getData(FlowNodeTransformData);
  }
  getPadding(node) {
    const { inlineSpacingPre, inlineSpacingAfter, padding } = node.getNodeMeta();
    const transform = this.getNodeTransform(node);
    if (padding) {
      return typeof padding === "function" ? padding(transform) : padding;
    }
    const paddingPre = typeof inlineSpacingPre === "function" ? inlineSpacingPre(transform) : inlineSpacingPre;
    const paddingAfter = typeof inlineSpacingAfter === "function" ? inlineSpacingAfter(transform) : inlineSpacingAfter;
    return {
      left: 0,
      top: paddingPre,
      right: 0,
      bottom: paddingAfter
    };
  }
  getInitScroll(contentSize) {
    return {
      scrollX: -contentSize.width / 2,
      scrollY: DEFAULT_SCROLL
    };
  }
  getDefaultInputPoint(node) {
    return this.getNodeTransform(node).bounds.topCenter;
  }
  getDefaultOutputPoint(node) {
    return this.getNodeTransform(node).bounds.bottomCenter;
  }
  getDefaultNodeOrigin() {
    return { x: 0.5, y: 0 };
  }
};
__decorateClass([
  inject6(FlowDocumentProvider)
], VerticalFixedLayout.prototype, "documentProvider", 2);
__decorateClass([
  multiInject2(FlowLayoutContribution),
  optional3()
], VerticalFixedLayout.prototype, "contribs", 2);
VerticalFixedLayout = __decorateClass([
  injectable6()
], VerticalFixedLayout);

// src/layout/horizontal-fixed-layout.ts
import { injectable as injectable7, inject as inject7, multiInject as multiInject3, optional as optional4 } from "inversify";
var DEFAULT_SCROLL2 = -36;
function isStructDataEqual2(struct1, struct2) {
  return struct1.childrenLength === struct2.childrenLength && struct1.index === struct2.index;
}
var HorizontalFixedLayout = class {
  constructor() {
    this.name = "horizontal-fixed-layout" /* HORIZONTAL_FIXED_LAYOUT */;
    this.structDataMap = /* @__PURE__ */ new WeakMap();
  }
  get document() {
    return this.documentProvider();
  }
  reload() {
    this.structDataMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * 更新布局
   */
  update() {
    this.updateLocalTransform(this.document.root);
  }
  /**
   * 更新节点的偏移
   * @param node
   * @param forceChange
   */
  updateLocalTransform(node, forceChange = false) {
    const { children, parent, isInlineBlock } = node;
    const transform = node.getData(FlowNodeTransformData);
    const { getDelta, getOrigin } = node.getNodeRegistry();
    const lastStructData = this.structDataMap.get(node) || {
      childrenLength: 0,
      index: -1
    };
    node.clearMemoGlobal();
    let localDirty = transform.localDirty || forceChange;
    const newStructData = {
      index: node.index,
      childrenLength: node.children.length
    };
    if (!isStructDataEqual2(lastStructData, newStructData)) {
      localDirty = true;
      this.structDataMap.set(node, newStructData);
    }
    let siblingDirty = false;
    if (children.length > 0) {
      for (const child of children) {
        const childDirty = this.updateLocalTransform(child, siblingDirty);
        if (childDirty) {
          siblingDirty = true;
          localDirty = true;
        }
      }
    }
    if (!localDirty) return false;
    node.clearMemoLocal();
    transform.transform.update({
      origin: getOrigin ? getOrigin(transform, this) : this.getDefaultNodeOrigin()
    });
    const preTransform = transform.pre;
    const delta = getDelta?.(transform, this) || { x: 0, y: 0 };
    const inlineSpacingPre = isInlineBlock && transform.parent?.inlineSpacingPre ? transform.parent?.inlineSpacingPre : 0;
    const fromParentDelta = parent?.getNodeRegistry().getChildDelta?.(transform, this) || {
      x: 0,
      y: 0
    };
    delta.x += fromParentDelta.x;
    delta.y += fromParentDelta.y;
    const position = { x: delta.x, y: delta.y };
    if (isInlineBlock) {
      position.x += inlineSpacingPre;
    } else {
      position.x += preTransform?.localBounds.right || 0;
      position.x += preTransform?.spacing || 0;
    }
    transform.transform.update({
      size: transform.data.size,
      position
    });
    this.onAfterUpdateLocalTransform(transform);
    transform.localDirty = false;
    return true;
  }
  onAfterUpdateLocalTransform(transform) {
    const { onAfterUpdateLocalTransform } = transform.entity.getNodeRegistry();
    onAfterUpdateLocalTransform?.(transform, this);
    this.contribs?.forEach((_contrib) => {
      _contrib?.onAfterUpdateLocalTransform?.(transform, this);
    });
  }
  getNodeTransform(node) {
    return node.getData(FlowNodeTransformData);
  }
  getPadding(node) {
    const { inlineSpacingPre, inlineSpacingAfter, padding } = node.getNodeMeta();
    const transform = this.getNodeTransform(node);
    if (padding) {
      return typeof padding === "function" ? padding(transform) : padding;
    }
    const paddingPre = typeof inlineSpacingPre === "function" ? inlineSpacingPre(transform) : inlineSpacingPre;
    const paddingAfter = typeof inlineSpacingAfter === "function" ? inlineSpacingAfter(transform) : inlineSpacingAfter;
    return {
      left: paddingPre,
      top: 0,
      right: paddingAfter,
      bottom: 0
    };
  }
  getInitScroll(contentSize) {
    return {
      scrollX: DEFAULT_SCROLL2,
      scrollY: -contentSize.height / 2
    };
  }
  getDefaultInputPoint(node) {
    return this.getNodeTransform(node).bounds.leftCenter;
  }
  getDefaultOutputPoint(node) {
    return this.getNodeTransform(node).bounds.rightCenter;
  }
  getDefaultNodeOrigin() {
    return { x: 0, y: 0.5 };
  }
};
__decorateClass([
  inject7(FlowDocumentProvider)
], HorizontalFixedLayout.prototype, "documentProvider", 2);
__decorateClass([
  multiInject3(FlowLayoutContribution),
  optional4()
], HorizontalFixedLayout.prototype, "contribs", 2);
HorizontalFixedLayout = __decorateClass([
  injectable7()
], HorizontalFixedLayout);

// src/flow-document-container-module.ts
var FlowDocumentContainerModule = new ContainerModule((bind) => {
  bind(FlowDocument).toSelf().inSingletonScope();
  bind(FlowDocumentProvider).toDynamicValue((ctx) => () => ctx.container.get(FlowDocument)).inSingletonScope();
  bind(FlowDocumentConfig).toSelf().inSingletonScope();
  bind(VerticalFixedLayout).toSelf().inSingletonScope();
  bind(HorizontalFixedLayout).toSelf().inSingletonScope();
  bind(FlowDragService).toSelf().inSingletonScope();
  bind(FlowOperationBaseService).to(FlowOperationBaseServiceImpl).inSingletonScope();
  bind(FlowGroupService).toSelf().inSingletonScope();
  bind(FlowDocumentContribution).toDynamicValue((ctx) => ({
    registerDocument: (document) => {
      document.registerLayout(ctx.container.get(VerticalFixedLayout));
      document.registerLayout(ctx.container.get(HorizontalFixedLayout));
    }
  }));
});

// src/utils/get-default-spacing.ts
var getDefaultSpacing = (node, key, defaultSpacing) => {
  const flowDocumentOptions = node.getService(FlowDocumentOptions);
  const spacing = flowDocumentOptions?.constants?.[key] || defaultSpacing || DEFAULT_SPACING[key];
  return spacing;
};
export {
  ConstantKeys,
  DEFAULT_FLOW_NODE_META,
  DEFAULT_SIZE,
  DEFAULT_SPACING,
  DRAGGING_TYPE,
  DefaultSpacingKey,
  FLOW_DEFAULT_HIDDEN_TYPES,
  FlowDocument,
  FlowDocumentConfig,
  FlowDocumentConfigDefaultData,
  FlowDocumentConfigEnum,
  FlowDocumentContainerModule,
  FlowDocumentContribution,
  FlowDocumentOptions,
  FlowDocumentOptionsDefault,
  FlowDocumentProvider,
  FlowDocumentTransformerEntity,
  FlowDragService,
  FlowGroupController,
  FlowGroupService,
  FlowLayout,
  FlowLayoutContribution,
  FlowLayoutDefault,
  FlowNodeBaseType,
  FlowNodeEntity,
  FlowNodeRegistry,
  FlowNodeRenderData,
  FlowNodeSplitType,
  FlowNodeTransformData,
  FlowNodeTransitionData,
  FlowOperationBaseService,
  FlowOperationBaseServiceImpl,
  FlowRendererStateEntity,
  FlowTransitionLabelEnum,
  FlowTransitionLineEnum,
  FlowVirtualTree,
  LABEL_SIDE_TYPE,
  OperationType,
  drawLineToBottom,
  drawLineToNext,
  getDefaultSpacing
};
//# sourceMappingURL=index.js.map