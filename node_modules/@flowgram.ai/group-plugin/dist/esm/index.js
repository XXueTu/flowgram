var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
import { FlowGroupController as FlowGroupController5 } from "@flowgram.ai/document";

// src/groups-layer.tsx
import React3 from "react";
import { inject, injectable } from "inversify";
import { FlowRendererRegistry } from "@flowgram.ai/renderer";
import {
  FlowDocument as FlowDocument2,
  FlowDocumentTransformerEntity,
  FlowGroupService,
  FlowNodeEntity as FlowNodeEntity2,
  FlowNodeRenderData as FlowNodeRenderData2,
  FlowNodeTransformData
} from "@flowgram.ai/document";
import { Layer, observeEntity, observeEntityDatas } from "@flowgram.ai/core";
import { domUtils } from "@flowgram.ai/utils";

// src/constant.ts
var GroupRenderer = /* @__PURE__ */ ((GroupRenderer2) => {
  GroupRenderer2["GroupRender"] = "group_render";
  GroupRenderer2["GroupBox"] = "group_box";
  return GroupRenderer2;
})(GroupRenderer || {});
var PositionConfig = {
  paddingWithNote: 50,
  // note 留白大小
  padding: 10,
  // 无 label 的 padding
  paddingWithAddLabel: 20,
  // 有 label 的padding，如要放添加按钮
  headerHeight: 20
  // 基础头部高度
};
var GroupPluginRegister = /* @__PURE__ */ ((GroupPluginRegister2) => {
  GroupPluginRegister2["GroupNode"] = "registerGroupNode";
  GroupPluginRegister2["Render"] = "registerRender";
  GroupPluginRegister2["Layer"] = "registerLayer";
  GroupPluginRegister2["CleanGroups"] = "registerCleanGroups";
  return GroupPluginRegister2;
})(GroupPluginRegister || {});

// src/components/group-render.tsx
import React, { useCallback, useEffect, useState } from "react";
import { FlowGroupController, FlowNodeRenderData } from "@flowgram.ai/document";
import { FlowDocument } from "@flowgram.ai/document";
import { useEntityFromContext, useService } from "@flowgram.ai/core";
import { delay } from "@flowgram.ai/utils";
function useCurrentDomNode() {
  const entity = useEntityFromContext();
  const renderData = entity.getData(FlowNodeRenderData);
  return renderData.node;
}
var GroupRender = (props) => {
  const { groupNode, GroupNode, GroupBoxHeader } = props;
  const container = useCurrentDomNode();
  const document = useService(FlowDocument);
  const groupController = FlowGroupController.create(groupNode);
  const [key, setKey] = useState(0);
  const [rendering, setRendering] = useState(true);
  const [collapsedCache, setCollapsedCache] = useState(groupController?.collapsed ?? false);
  const rerender = useCallback(async () => {
    setRendering(true);
    setKey(key + 1);
    await delay(50);
    setKey(key + 1);
    setRendering(false);
  }, [key]);
  useEffect(() => {
    const disposer = document.renderTree.onTreeChange(() => {
      if (groupController?.collapsed !== collapsedCache) {
        setCollapsedCache(groupController?.collapsed ?? false);
        rerender();
      }
    });
    return () => {
      disposer.dispose();
    };
  }, [key]);
  useEffect(() => {
    if (!groupController || groupController.collapsed) {
      return;
    }
    rerender();
  }, []);
  if (!groupController) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null);
  }
  const groupNodeRender = /* @__PURE__ */ React.createElement(GroupNode, { key, groupNode, groupController });
  const groupBoxHeader = /* @__PURE__ */ React.createElement(GroupBoxHeader, { key, groupController, groupNode });
  if (groupController.collapsed) {
    const positionStyle = {
      display: "block",
      zIndex: "0",
      width: "auto",
      height: "auto"
    };
    Object.assign(container.style, positionStyle);
    return groupNodeRender;
  } else if (!rendering) {
    const bounds = groupController.bounds;
    const positionStyle = {
      width: `${bounds.width}px`
    };
    Object.assign(container.style, positionStyle);
    return groupBoxHeader;
  } else {
    return /* @__PURE__ */ React.createElement(React.Fragment, null);
  }
};

// src/components/group-box.tsx
import { useEffect as useEffect3 } from "react";
import React2 from "react";
import { FlowGroupController as FlowGroupController2 } from "@flowgram.ai/document";

// src/components/hooks.ts
import { useEffect as useEffect2, useRef, useState as useState2 } from "react";
var useHover = () => {
  const ref = useRef(null);
  const [hover, setHover] = useState2(false);
  const checkMouseOver = (event) => {
    if (!ref.current) {
      return;
    }
    const { left, top, right, bottom } = ref.current.getBoundingClientRect();
    const isOver = event.clientX >= left && event.clientX <= right && event.clientY >= top && event.clientY <= bottom;
    setHover(isOver);
  };
  useEffect2(() => {
    window.addEventListener("mousemove", checkMouseOver);
    return () => {
      window.removeEventListener("mousemove", checkMouseOver);
    };
  }, []);
  return {
    hover,
    ref
  };
};

// src/components/group-box.tsx
var GroupBox = (props) => {
  const { groupNode } = props;
  const groupController = FlowGroupController2.create(groupNode);
  const bounds = groupController.bounds;
  const { hover, ref } = useHover();
  const positionStyle = {
    position: "absolute",
    left: bounds.left,
    top: bounds.top,
    width: bounds.width,
    height: bounds.height
  };
  const defaultBackgroundStyle = {
    borderRadius: 10,
    zIndex: -1,
    outline: `${hover ? 3 : 1}px solid rgb(97, 69, 211)`,
    backgroundColor: "rgb(236 233 247)"
  };
  const backgroundStyle = props.backgroundStyle ? props.backgroundStyle(groupController) : defaultBackgroundStyle;
  useEffect3(() => {
    groupController.hovered = hover;
  }, [hover]);
  if (!groupController || groupController.collapsed) {
    return /* @__PURE__ */ React2.createElement(React2.Fragment, null);
  }
  return /* @__PURE__ */ React2.createElement("div", { className: "gedit-group-box", "data-group-id": groupNode.id }, /* @__PURE__ */ React2.createElement(
    "div",
    {
      className: "gedit-group-background",
      ref,
      style: {
        ...positionStyle,
        ...backgroundStyle
      }
    }
  ));
};

// src/groups-layer.tsx
var GroupsLayer = class extends Layer {
  constructor() {
    super();
    this.className = "gedit-groups-layer";
    this.node = domUtils.createDivWithClass(this.className);
    this.node.style.zIndex = "0";
  }
  /** 缩放 */
  onZoom(scale) {
    this.node.style.transform = `scale(${scale})`;
  }
  render() {
    if (this.documentTransformer.loading) return /* @__PURE__ */ React3.createElement(React3.Fragment, null);
    this.documentTransformer.refresh();
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, this.renderGroups());
  }
  /** 渲染分组 */
  renderGroups() {
    const Box = this.renderer || GroupBox;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, this.groups.map((group) => /* @__PURE__ */ React3.createElement(
      Box,
      {
        key: group.groupNode.id,
        groupNode: group.groupNode,
        backgroundStyle: this.options.groupBoxStyle
      }
    )));
  }
  /** 所有分组 */
  get groups() {
    return this.groupService.getAllGroups();
  }
  get renderer() {
    return this.rendererRegistry.tryToGetRendererComponent("group_box" /* GroupBox */)?.renderer;
  }
};
__decorateClass([
  inject(FlowDocument2)
], GroupsLayer.prototype, "document", 2);
__decorateClass([
  inject(FlowRendererRegistry)
], GroupsLayer.prototype, "rendererRegistry", 2);
__decorateClass([
  inject(FlowGroupService)
], GroupsLayer.prototype, "groupService", 2);
__decorateClass([
  observeEntity(FlowDocumentTransformerEntity)
], GroupsLayer.prototype, "documentTransformer", 2);
__decorateClass([
  observeEntityDatas(FlowNodeEntity2, FlowNodeRenderData2)
], GroupsLayer.prototype, "renderStates", 2);
__decorateClass([
  observeEntityDatas(FlowNodeEntity2, FlowNodeTransformData)
], GroupsLayer.prototype, "transforms", 2);
GroupsLayer = __decorateClass([
  injectable()
], GroupsLayer);

// src/create-group-plugin.tsx
import { definePluginCreator } from "@flowgram.ai/core";

// src/registers/register-render.tsx
import React4 from "react";
import { FlowRendererRegistry as FlowRendererRegistry2 } from "@flowgram.ai/renderer";
var registerRender = (ctx, opts) => {
  const rendererRegistry = ctx.get(FlowRendererRegistry2);
  const renderer = (props) => /* @__PURE__ */ React4.createElement(
    GroupRender,
    {
      groupNode: props.node,
      GroupNode: opts.components.GroupNode,
      GroupBoxHeader: opts.components.GroupBoxHeader
    }
  );
  rendererRegistry.registerReactComponent("group_render" /* GroupRender */, renderer);
};

// src/registers/register-layer.ts
var registerLayer = (ctx, opts) => {
  ctx.playground.registerLayer(GroupsLayer, opts);
};

// src/registers/register-group-node.ts
import { FlowDocument as FlowDocument3 } from "@flowgram.ai/document";

// src/group-node-register.tsx
import { Point } from "@flowgram.ai/utils";
import {
  FlowGroupController as FlowGroupController4,
  FlowNodeBaseType,
  FlowTransitionLabelEnum,
  FlowTransitionLineEnum
} from "@flowgram.ai/document";
var GroupRegister = {
  type: FlowNodeBaseType.GROUP,
  meta: {
    exportJSON: true,
    renderKey: "group_render" /* GroupRender */,
    positionConfig: PositionConfig,
    padding: (transform) => {
      const groupController = FlowGroupController4.create(transform.entity);
      if (!groupController || groupController.collapsed || groupController.nodes.length === 0) {
        return {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0
        };
      }
      if (transform.entity.isVertical) {
        return {
          top: PositionConfig.paddingWithNote,
          bottom: PositionConfig.paddingWithAddLabel,
          left: PositionConfig.padding,
          right: PositionConfig.padding
        };
      }
      return {
        top: PositionConfig.paddingWithNote,
        bottom: PositionConfig.padding,
        left: PositionConfig.padding,
        right: PositionConfig.paddingWithAddLabel
      };
    }
  },
  getLines(transition) {
    const { transform } = transition;
    const lines = [];
    if (transform.firstChild) {
      lines.push({
        type: FlowTransitionLineEnum.STRAIGHT_LINE,
        from: transform.inputPoint,
        to: transform.firstChild.inputPoint
      });
    }
    if (transform.next) {
      lines.push({
        type: FlowTransitionLineEnum.STRAIGHT_LINE,
        from: transform.outputPoint,
        to: transform.next.inputPoint
      });
    } else {
      lines.push({
        type: FlowTransitionLineEnum.STRAIGHT_LINE,
        from: transform.outputPoint,
        to: transform.parent.outputPoint
      });
    }
    return lines;
  },
  getDelta(transform) {
    const groupController = FlowGroupController4.create(transform.entity);
    if (!groupController || groupController.collapsed) {
      return;
    }
    if (transform.entity.isVertical) {
      return {
        x: 0,
        y: PositionConfig.paddingWithNote
      };
    }
    return {
      x: PositionConfig.padding,
      y: 0
    };
  },
  getInputPoint(transform) {
    const child = transform.firstChild;
    if (!child) return transform.defaultInputPoint;
    if (transform.entity.isVertical) {
      return {
        x: child.inputPoint.x,
        y: transform.bounds.topCenter.y
      };
    }
    return {
      x: transform.bounds.leftCenter.x,
      y: child.inputPoint.y
    };
  },
  getOutputPoint(transform) {
    const child = transform.lastChild;
    if (!child) return transform.defaultOutputPoint;
    if (transform.entity.isVertical) {
      return {
        x: child.outputPoint.x,
        y: child.outputPoint.y + PositionConfig.paddingWithAddLabel / 2
      };
    }
    return {
      x: child.outputPoint.x + PositionConfig.paddingWithAddLabel / 2,
      y: child.outputPoint.y
    };
  },
  getLabels(transition) {
    const { transform } = transition;
    if (transform.next) {
      if (transform.entity.isVertical) {
        return [
          {
            offset: Point.getMiddlePoint(
              Point.move(transform.outputPoint, {
                x: 0,
                y: PositionConfig.paddingWithAddLabel / 2
              }),
              transform.next.inputPoint
            ),
            type: FlowTransitionLabelEnum.ADDER_LABEL
          }
        ];
      }
      return [
        {
          offset: Point.getMiddlePoint(
            Point.move(transform.outputPoint, { x: PositionConfig.paddingWithAddLabel / 2, y: 0 }),
            transform.next.inputPoint
          ),
          type: FlowTransitionLabelEnum.ADDER_LABEL
        }
      ];
    }
    return [
      {
        offset: transform.parent.outputPoint,
        type: FlowTransitionLabelEnum.ADDER_LABEL
      }
    ];
  },
  getOriginDeltaY(transform) {
    const { children } = transform;
    if (children.length === 0) {
      return -transform.size.height * transform.origin.y;
    }
    return -transform.size.height * transform.origin.y - PositionConfig.paddingWithNote;
  }
};

// src/registers/register-group-node.ts
var registerGroupNode = (ctx) => {
  const document = ctx.get(FlowDocument3);
  document.registerFlowNodes(GroupRegister);
};

// src/registers/register-clean-groups.ts
import { FlowDocument as FlowDocument4 } from "@flowgram.ai/document";
import { FlowGroupService as FlowGroupService2 } from "@flowgram.ai/document";
var registerCleanGroups = (ctx, opts) => {
  const groupService = ctx.get(FlowGroupService2);
  const document = ctx.get(FlowDocument4);
  const clearInvalidGroups = () => {
    groupService.getAllGroups().forEach((group) => {
      if (group?.nodes.length !== 0) {
        return;
      }
      if (!group.groupNode.pre) {
        return;
      }
      groupService.deleteGroup(group.groupNode);
    });
  };
  document.originTree.onTreeChange(() => {
    setTimeout(() => {
      clearInvalidGroups();
    }, 0);
  });
};

// src/registers/index.ts
var groupRegisters = {
  ["registerGroupNode" /* GroupNode */]: registerGroupNode,
  ["registerRender" /* Render */]: registerRender,
  ["registerLayer" /* Layer */]: registerLayer,
  ["registerCleanGroups" /* CleanGroups */]: registerCleanGroups
};

// src/create-group-plugin.tsx
var createGroupPlugin = definePluginCreator({
  onInit: (ctx, opts) => {
    const { registers: registerConfs = {} } = opts;
    Object.entries(groupRegisters).forEach(([key, register]) => {
      const registerName = key;
      const registerConf = registerConfs[registerName];
      if (registerConf === false) {
        return;
      }
      if (typeof registerConf === "function") {
        registerConf(ctx, opts);
        return;
      }
      register(ctx, opts);
    });
  }
});
export {
  FlowGroupController5 as FlowGroupController,
  GroupBox,
  GroupPluginRegister,
  GroupRegister,
  GroupRender,
  GroupRenderer,
  GroupsLayer,
  PositionConfig,
  createGroupPlugin
};
//# sourceMappingURL=index.js.map