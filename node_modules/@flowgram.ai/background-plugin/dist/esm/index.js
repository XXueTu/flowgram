var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/background-layer.tsx
import { Layer, observeEntity, PlaygroundConfigEntity, SCALE_WIDTH } from "@flowgram.ai/core";
import { domUtils } from "@flowgram.ai/utils";
var PATTERN_PREFIX = "gedit-background-pattern-";
var RENDER_SIZE = 20;
var DOT_SIZE = 1;
var id = 0;
var BackgroundLayer = class extends Layer {
  constructor() {
    super(...arguments);
    this._patternId = `${PATTERN_PREFIX}${id++}`;
    this.node = domUtils.createDivWithClass("gedit-flow-background-layer");
    this.grid = document.createElement("div");
  }
  /**
   * 当前缩放比
   */
  get zoom() {
    return this.config.finalScale;
  }
  onReady() {
    const { firstChild } = this.pipelineNode;
    this.pipelineNode.insertBefore(this.node, firstChild);
    this.playgroundConfigEntity.updateConfig({
      minZoom: 0.1,
      maxZoom: 2
    });
    this.grid.style.zIndex = "-1";
    this.grid.style.position = "relative";
    this.node.appendChild(this.grid);
    this.grid.className = "gedit-grid-svg";
  }
  /**
   * 最小单元格大小
   */
  getScaleUnit() {
    const { zoom } = this;
    return {
      realSize: RENDER_SIZE,
      // 一个单元格代表的真实大小
      renderSize: Math.round(RENDER_SIZE * zoom * 100) / 100,
      // 一个单元格渲染的大小值
      zoom
      // 缩放比
    };
  }
  /**
   * 绘制
   */
  autorun() {
    const playgroundConfig = this.playgroundConfigEntity.config;
    const scaleUnit = this.getScaleUnit();
    const mod = scaleUnit.renderSize * 10;
    const viewBoxWidth = playgroundConfig.width + mod * 2;
    const viewBoxHeight = playgroundConfig.height + mod * 2;
    const { scrollX } = playgroundConfig;
    const { scrollY } = playgroundConfig;
    const scrollXDelta = this.getScrollDelta(scrollX, mod);
    const scrollYDelta = this.getScrollDelta(scrollY, mod);
    domUtils.setStyle(this.node, {
      left: scrollX - SCALE_WIDTH,
      top: scrollY - SCALE_WIDTH
    });
    this.drawGrid(scaleUnit);
    this.setSVGStyle(this.grid, {
      width: viewBoxWidth,
      height: viewBoxHeight,
      left: SCALE_WIDTH - scrollXDelta - mod,
      top: SCALE_WIDTH - scrollYDelta - mod
    });
  }
  /**
   * 绘制网格
   */
  drawGrid(unit) {
    const minor = unit.renderSize;
    if (!this.grid) {
      return;
    }
    const patternSize = DOT_SIZE * this.zoom;
    const newContent = `
    <svg width="100%" height="100%">
      <pattern id="${this._patternId}" width="${minor}" height="${minor}" patternUnits="userSpaceOnUse">
        <circle
          cx="${patternSize}"
          cy="${patternSize}"
          r="${patternSize}"
          stroke="#eceeef"
          fill-opacity="0.5"
        />
      </pattern>
      <rect width="100%" height="100%" fill="url(#${this._patternId})"/>
    </svg>`;
    this.grid.innerHTML = newContent;
  }
  setSVGStyle(svgElement, style) {
    if (!svgElement) {
      return;
    }
    svgElement.style.width = `${style.width}px`;
    svgElement.style.height = `${style.height}px`;
    svgElement.style.left = `${style.left}px`;
    svgElement.style.top = `${style.top}px`;
  }
  /**
   * 获取相对滚动距离
   * @param realScroll
   * @param mod
   */
  getScrollDelta(realScroll, mod) {
    if (realScroll >= 0) {
      return realScroll % mod;
    }
    return mod - Math.abs(realScroll) % mod;
  }
};
BackgroundLayer.type = "WorkflowBackgroundLayer";
__decorateClass([
  observeEntity(PlaygroundConfigEntity)
], BackgroundLayer.prototype, "playgroundConfigEntity", 2);

// src/create-background-plugin.ts
import { definePluginCreator } from "@flowgram.ai/core";
var createBackgroundPlugin = definePluginCreator({
  onInit: (ctx, opts) => {
    ctx.playground.registerLayer(BackgroundLayer, opts);
  }
});
export {
  BackgroundLayer,
  createBackgroundPlugin
};
//# sourceMappingURL=index.js.map