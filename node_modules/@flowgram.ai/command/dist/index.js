"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Command: () => Command,
  CommandContainerModule: () => CommandContainerModule,
  CommandContribution: () => CommandContribution,
  CommandRegistry: () => CommandRegistry,
  CommandRegistryFactory: () => CommandRegistryFactory,
  CommandService: () => CommandService
});
module.exports = __toCommonJS(src_exports);

// src/command.ts
var import_inversify = require("inversify");
var import_utils = require("@flowgram.ai/utils");
var Command;
((Command2) => {
  let Default;
  ((Default2) => {
    Default2["ZOOM_IN"] = "ZOOM_IN";
    Default2["ZOOM_OUT"] = "ZOOM_OUT";
    Default2["DELETE"] = "DELETE";
    Default2["COPY"] = "COPY";
    Default2["PASTE"] = "PASTE";
    Default2["UNDO"] = "UNDO";
    Default2["REDO"] = "REDO";
    Default2["VIEW_CLOSE_ALL_WIDGET"] = "view.closeAllWidget";
    Default2["VIEW_CLOSE_CURRENT_WIDGET"] = "view.closeCurrentWidget";
    Default2["VIEW_REOPEN_LAST_WIDGET"] = "view.reopenLastWidget";
    Default2["VIEW_CLOSE_OTHER_WIDGET"] = "view.closeOtherWidget";
    Default2["VIEW_CLOSE_BOTTOM_PANEL"] = "view.closeBottomPannel";
    Default2["VIEW_OPEN_NEXT_TAB"] = "view.openNextTab";
    Default2["VIEW_OEPN_LAST_TAB"] = "view.openLastTab";
    Default2["VIEW_FULL_SCREEN"] = "view.fullScreen";
    Default2["VIEW_SAVING_WIDGET_CLOSE_CONFIRM"] = "view.savingWidgetCloseConfirm";
    Default2["VIEW_SHORTCUTS"] = "view.shortcuts";
    Default2["VIEW_PREFERENCES"] = "view.preferences";
    Default2["VIEW_LOG"] = "view.log";
    Default2["VIEW_PROBLEMS"] = "view.problems";
  })(Default = Command2.Default || (Command2.Default = {}));
  function is(arg) {
    return !!arg && arg === Object(arg) && "id" in arg;
  }
  Command2.is = is;
})(Command || (Command = {}));
var CommandContribution = Symbol("CommandContribution");
var CommandExecuting;
((CommandExecuting2) => {
  function findSimple(arrs, newCmd) {
    for (const item of arrs.values()) {
      if (item.id === newCmd.id && item.args.length === newCmd.args.length && item.args.every((arg, index) => newCmd[index] === arg)) {
        return item;
      }
    }
  }
  CommandExecuting2.findSimple = findSimple;
})(CommandExecuting || (CommandExecuting = {}));
var CommandRegistryFactory = "CommandRegistryFactory";
var CommandRegistry = class {
  constructor() {
    this._handlers = {};
    this._commands = {};
    this._commandExecutings = /* @__PURE__ */ new Set();
    this.toUnregisterCommands = /* @__PURE__ */ new Map();
    this.onDidExecuteCommandEmitter = new import_utils.Emitter();
    this.onDidExecuteCommand = this.onDidExecuteCommandEmitter.event;
    this.onWillExecuteCommandEmitter = new import_utils.Emitter();
    this.onWillExecuteCommand = this.onWillExecuteCommandEmitter.event;
  }
  init() {
    for (const contrib of this.contributions) {
      contrib.registerCommands(this);
    }
  }
  /**
   * 当前所有 command
   */
  get commands() {
    const commands = [];
    for (const id of this.commandIds) {
      const cmd = this.getCommand(id);
      if (cmd) {
        commands.push(cmd);
      }
    }
    return commands;
  }
  /**
   * 当前所有 commandid
   */
  get commandIds() {
    return Object.keys(this._commands);
  }
  registerCommand(commandOrId, handler) {
    const command = typeof commandOrId === "string" ? { id: commandOrId } : commandOrId;
    if (this._commands[command.id]) {
      console.warn(`A command ${command.id} is already registered.`);
      return import_utils.Disposable.NULL;
    }
    const toDispose = new import_utils.DisposableCollection(this.doRegisterCommand(command));
    if (handler) {
      toDispose.push(this.registerHandler(command.id, handler));
    }
    this.toUnregisterCommands.set(command.id, toDispose);
    toDispose.push(import_utils.Disposable.create(() => this.toUnregisterCommands.delete(command.id)));
    return toDispose;
  }
  unregisterCommand(commandOrId) {
    const id = Command.is(commandOrId) ? commandOrId.id : commandOrId;
    const toUnregister = this.toUnregisterCommands.get(id);
    if (toUnregister) {
      toUnregister.dispose();
    }
  }
  /**
   * 注册 handler
   */
  registerHandler(commandId, handler) {
    let handlers = this._handlers[commandId];
    if (!handlers) {
      this._handlers[commandId] = handlers = [];
    }
    handlers.unshift(handler);
    return {
      dispose: () => {
        const idx = handlers.indexOf(handler);
        if (idx >= 0) {
          handlers.splice(idx, 1);
        }
      }
    };
  }
  /**
   * 预留 contextMenu 用，该 handler 是否可见
   */
  isVisible(command, ...args) {
    return typeof this.getVisibleHandler(command, ...args) !== "undefined";
  }
  /**
   * command 是否可用
   */
  isEnabled(command, ...args) {
    return typeof this.getActiveHandler(command, ...args) !== "undefined";
  }
  /**
   * 预留 contextMenu 用，该 handler 是否可以触发
   */
  isToggled(command, ...args) {
    return typeof this.getToggledHandler(command, ...args) !== "undefined";
  }
  /**
   * 执行 command，会先判断是否可以执行，不会重复执行
   */
  async executeCommand(commandId, ...args) {
    const handler = this.getActiveHandler(commandId, ...args);
    const execInfo = { id: commandId, args };
    const simpleExecInfo = CommandExecuting.findSimple(this._commandExecutings, execInfo);
    if (simpleExecInfo) {
      return execInfo.promise;
    }
    if (handler) {
      try {
        this._commandExecutings.add(execInfo);
        this.onWillExecuteCommandEmitter.fire({ commandId, args });
        const promise = handler.execute(...args);
        execInfo.promise = promise;
        const result = await promise;
        this.onDidExecuteCommandEmitter.fire({ commandId, args });
        return result;
      } finally {
        this._commandExecutings.delete(execInfo);
      }
    }
  }
  getVisibleHandler(commandId, ...args) {
    const handlers = this._handlers[commandId];
    if (handlers) {
      for (const handler of handlers) {
        try {
          if (!handler.isVisible || handler.isVisible(...args)) {
            return handler;
          }
        } catch (error) {
          console.error(error);
        }
      }
    }
    return void 0;
  }
  getActiveHandler(commandId, ...args) {
    const handlers = this._handlers[commandId];
    if (handlers) {
      for (const handler of handlers) {
        try {
          if (!handler.isEnabled || handler.isEnabled(...args)) {
            return handler;
          }
        } catch (error) {
          console.error(error);
        }
      }
    }
    return void 0;
  }
  /**
   * 获取 command 对应的所有 handler
   */
  getAllHandlers(commandId) {
    const handlers = this._handlers[commandId];
    return handlers ? handlers.slice() : [];
  }
  getToggledHandler(commandId, ...args) {
    const handlers = this._handlers[commandId];
    if (handlers) {
      for (const handler of handlers) {
        try {
          if (handler.isToggled && handler.isToggled(...args)) {
            return handler;
          }
        } catch (error) {
          console.error(error);
        }
      }
    }
    return void 0;
  }
  /**
   * 获取 command
   */
  getCommand(id) {
    return this._commands[id];
  }
  doRegisterCommand(command) {
    this._commands[command.id] = command;
    return {
      dispose: () => {
        delete this._commands[command.id];
      }
    };
  }
  /**
   * 更新 command
   */
  updateCommand(id, command) {
    if (this._commands[id]) {
      this._commands[id] = {
        ...this._commands[id],
        ...command
      };
    }
  }
  dispose() {
    this.onWillExecuteCommandEmitter.dispose();
    this.onDidExecuteCommandEmitter.dispose();
  }
};
__decorateClass([
  (0, import_inversify.multiInject)(CommandContribution),
  (0, import_inversify.optional)()
], CommandRegistry.prototype, "contributions", 2);
CommandRegistry = __decorateClass([
  (0, import_inversify.injectable)()
], CommandRegistry);

// src/command-service.ts
var CommandService = Symbol("CommandService");

// src/command-container-module.ts
var import_inversify2 = require("inversify");
var import_utils2 = require("@flowgram.ai/utils");
var CommandContainerModule = new import_inversify2.ContainerModule((bind) => {
  (0, import_utils2.bindContributionProvider)(bind, CommandContribution);
  bind(CommandRegistry).toSelf().inSingletonScope();
  bind(CommandService).toService(CommandRegistry);
  bind(CommandRegistryFactory).toFactory((ctx) => () => ctx.container.get(CommandRegistry));
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Command,
  CommandContainerModule,
  CommandContribution,
  CommandRegistry,
  CommandRegistryFactory,
  CommandService
});
//# sourceMappingURL=index.js.map