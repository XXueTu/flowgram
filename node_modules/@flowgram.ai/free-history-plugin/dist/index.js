"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FreeHistoryConfig: () => FreeHistoryConfig,
  FreeHistoryRegisters: () => FreeHistoryRegisters,
  FreeOperationType: () => FreeOperationType,
  createFreeHistoryPlugin: () => createFreeHistoryPlugin,
  useUndoRedo: () => useUndoRedo
});
module.exports = __toCommonJS(src_exports);

// src/create-free-history-plugin.ts
var import_core5 = require("@flowgram.ai/core");
var import_history5 = require("@flowgram.ai/history");

// src/history-entity-manager.ts
var import_lodash = require("lodash");
var import_inversify = require("inversify");
var import_utils = require("@flowgram.ai/utils");
var HistoryEntityManager = class {
  constructor() {
    this._entityDataValues = /* @__PURE__ */ new Map();
    this._toDispose = new import_utils.DisposableCollection();
  }
  addEntityData(entityData) {
    this._entityDataValues.set(entityData, (0, import_lodash.cloneDeep)(entityData.toJSON()));
    this._toDispose.push(
      entityData.onWillChange((event) => {
        const value = event.toJSON();
        const oldValue = this._entityDataValues.get(entityData);
        if ((0, import_lodash.isEqual)(value, oldValue)) {
          return;
        }
        this._entityDataValues.set(entityData, (0, import_lodash.cloneDeep)(value));
      })
    );
  }
  getValue(entityData) {
    return this._entityDataValues.get(entityData);
  }
  setValue(entityData, value) {
    return this._entityDataValues.set(entityData, value);
  }
  dispose() {
    this._entityDataValues.clear();
    this._toDispose.dispose();
  }
};
HistoryEntityManager = __decorateClass([
  (0, import_inversify.injectable)()
], HistoryEntityManager);

// src/handlers/drag-nodes-handler.ts
var import_inversify2 = require("inversify");
var import_history = require("@flowgram.ai/history");
var import_core = require("@flowgram.ai/core");

// src/types.ts
var FreeOperationType = /* @__PURE__ */ ((FreeOperationType2) => {
  FreeOperationType2["addLine"] = "addLine";
  FreeOperationType2["deleteLine"] = "deleteLine";
  FreeOperationType2["moveNode"] = "moveNode";
  FreeOperationType2["addNode"] = "addNode";
  FreeOperationType2["deleteNode"] = "deleteNode";
  FreeOperationType2["changeNodeData"] = "changeNodeData";
  FreeOperationType2["resetLayout"] = "resetLayout";
  FreeOperationType2["dragNodes"] = "dragNodes";
  FreeOperationType2["moveChildNodes"] = "moveChildNodes";
  return FreeOperationType2;
})(FreeOperationType || {});

// src/handlers/drag-nodes-handler.ts
var DragNodesHandler = class {
  handle(event) {
    if (event.type === "onDragEnd") {
      this._dragNode(event);
    }
  }
  _dragNode(event) {
    this._historyService.pushOperation(
      {
        type: "dragNodes" /* dragNodes */,
        value: {
          ids: event.nodes.map((node) => node.id),
          value: event.nodes.map((node) => {
            const { x, y } = node.getData(import_core.TransformData).position;
            return {
              x,
              y
            };
          }),
          oldValue: event.startPositions
        }
      },
      { noApply: true }
    );
  }
};
__decorateClass([
  (0, import_inversify2.inject)(import_history.HistoryService)
], DragNodesHandler.prototype, "_historyService", 2);
DragNodesHandler = __decorateClass([
  (0, import_inversify2.injectable)()
], DragNodesHandler);

// src/handlers/change-node-data-handler.ts
var import_lodash2 = require("lodash");
var import_inversify4 = require("inversify");
var import_form_core = require("@flowgram.ai/form-core");
var import_free_layout_core = require("@flowgram.ai/free-layout-core");
var import_history2 = require("@flowgram.ai/history");

// src/free-history-config.ts
var import_inversify3 = require("inversify");
var FreeHistoryConfig = class {
  constructor() {
    this.enable = false;
    this.nodeToJSON = (node) => node.toJSON();
    this.getNodeLabelById = (id) => id;
    this.getNodeLabel = (node) => node.id;
    this.getBlockLabel = (node) => node.id;
    this.getNodeURI = (id) => `node:${id}`;
    this.getLineURI = (id) => `line:${id}`;
  }
  init(ctx, options) {
    this.enable = !!options?.enable;
    if (options.nodeToJSON) {
      this.nodeToJSON = options.nodeToJSON(ctx);
    }
    if (options.getNodeLabelById) {
      this.getNodeLabelById = options.getNodeLabelById(ctx);
    }
    if (options.getNodeLabel) {
      this.getNodeLabel = options.getNodeLabel(ctx);
    }
    if (options.getBlockLabel) {
      this.getBlockLabel = options.getBlockLabel(ctx);
    }
    if (options.getNodeURI) {
      this.getNodeURI = options.getNodeURI(ctx);
    }
    if (options.getLineURI) {
      this.getLineURI = options.getLineURI(ctx);
    }
  }
};
FreeHistoryConfig = __decorateClass([
  (0, import_inversify3.injectable)()
], FreeHistoryConfig);

// src/handlers/change-node-data-handler.ts
var ChangeNodeDataHandler = class {
  handle(event) {
    const { path, value, initialized, node } = event;
    const formData = node.getData(import_form_core.FlowNodeFormData);
    const oldValue = this._entityManager.getValue(formData);
    const propPath = path.split("/").filter(Boolean).join(".");
    const propOldValue = propPath ? (0, import_lodash2.get)(oldValue, propPath) : oldValue;
    if ((0, import_lodash2.isEqual)(value, propOldValue)) {
      return;
    }
    if (initialized) {
      let operationPath = path;
      let operationValue = (0, import_lodash2.cloneDeep)(value);
      let operationOldValue = propOldValue;
      if (path !== "/") {
        const clonedOldValue = (0, import_lodash2.cloneDeep)(oldValue);
        (0, import_lodash2.set)(clonedOldValue, propPath, value);
        operationPath = path.split("/").filter(Boolean)[0];
        operationValue = (0, import_lodash2.get)(clonedOldValue, operationPath);
        operationOldValue = (0, import_lodash2.get)(oldValue, operationPath);
      }
      this._historyService.pushOperation(
        {
          type: "changeNodeData" /* changeNodeData */,
          value: {
            id: node.id,
            path: operationPath,
            value: operationValue,
            oldValue: operationOldValue
          },
          uri: this._config.getNodeURI(node.id)
        },
        { noApply: true }
      );
    }
    if (propPath) {
      (0, import_lodash2.set)(oldValue, propPath, (0, import_lodash2.cloneDeep)(value));
    } else {
      this._entityManager.setValue(formData, (0, import_lodash2.cloneDeep)(value));
    }
  }
};
__decorateClass([
  (0, import_inversify4.inject)(import_history2.HistoryService)
], ChangeNodeDataHandler.prototype, "_historyService", 2);
__decorateClass([
  (0, import_inversify4.inject)(import_free_layout_core.WorkflowDocument)
], ChangeNodeDataHandler.prototype, "document", 2);
__decorateClass([
  (0, import_inversify4.inject)(HistoryEntityManager)
], ChangeNodeDataHandler.prototype, "_entityManager", 2);
__decorateClass([
  (0, import_inversify4.inject)(FreeHistoryConfig)
], ChangeNodeDataHandler.prototype, "_config", 2);
ChangeNodeDataHandler = __decorateClass([
  (0, import_inversify4.injectable)()
], ChangeNodeDataHandler);

// src/handlers/change-content-handler.ts
var import_inversify5 = require("inversify");
var import_history3 = require("@flowgram.ai/history");

// src/changes/delete-node-change.ts
var import_free_layout_core2 = require("@flowgram.ai/free-layout-core");
var deleteNodeChange = {
  type: import_free_layout_core2.WorkflowContentChangeType.DELETE_NODE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const node = event.entity;
    const json = event.toJSON();
    const parentID = node.parent?.id;
    return {
      type: "deleteNode" /* deleteNode */,
      value: {
        node: json,
        parentID
      },
      uri: config.getNodeURI(node.id)
    };
  }
};

// src/changes/delete-line-change.ts
var import_free_layout_core3 = require("@flowgram.ai/free-layout-core");
var deleteLineChange = {
  type: import_free_layout_core3.WorkflowContentChangeType.DELETE_LINE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const line = event.entity;
    const value = {
      from: line.info.from,
      to: line.info.to || "",
      fromPort: line.info.fromPort || "",
      toPort: line.info.toPort || "",
      id: line.id
    };
    return {
      type: "deleteLine" /* deleteLine */,
      value,
      uri: config.getNodeURI(line.id)
    };
  }
};

// src/changes/add-node-change.ts
var import_free_layout_core4 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core5 = require("@flowgram.ai/free-layout-core");
var addNodeChange = {
  type: import_free_layout_core5.WorkflowContentChangeType.ADD_NODE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const document = ctx.get(import_free_layout_core4.WorkflowDocument);
    const node = event.entity;
    const parentID = node.parent?.id;
    const json = document.toNodeJSON(node);
    return {
      type: "addNode" /* addNode */,
      value: {
        node: json,
        parentID
      },
      uri: config.getNodeURI(node.id)
    };
  }
};

// src/changes/add-line-change.ts
var import_free_layout_core6 = require("@flowgram.ai/free-layout-core");
var addLineChange = {
  type: import_free_layout_core6.WorkflowContentChangeType.ADD_LINE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const line = event.entity;
    const value = {
      from: line.info.from,
      to: line.info.to || "",
      fromPort: line.info.fromPort || "",
      toPort: line.info.toPort || "",
      id: line.id
    };
    return {
      type: "addLine" /* addLine */,
      value,
      uri: config.getLineURI(line.id)
    };
  }
};

// src/changes/index.ts
var changes_default = [addLineChange, deleteLineChange, addNodeChange, deleteNodeChange];

// src/handlers/change-content-handler.ts
var ChangeContentHandler = class {
  handle(event, ctx) {
    if (!this._historyService.undoRedoService.canPush()) {
      return;
    }
    const change = changes_default.find((c) => c.type === event.type);
    if (!change) {
      return;
    }
    const operation = change.toOperation(event, ctx);
    if (!operation) {
      return;
    }
    this._historyService.pushOperation(operation, { noApply: true });
  }
};
__decorateClass([
  (0, import_inversify5.inject)(import_history3.HistoryService)
], ChangeContentHandler.prototype, "_historyService", 2);
ChangeContentHandler = __decorateClass([
  (0, import_inversify5.injectable)()
], ChangeContentHandler);

// src/free-history-registers.ts
var import_inversify6 = require("inversify");

// src/operation-metas/reset-layout.ts
var import_free_layout_core7 = require("@flowgram.ai/free-layout-core");

// src/operation-metas/base.ts
var baseOperationMeta = {
  shouldMerge: (_op, prev, element) => {
    if (!prev) {
      return false;
    }
    if (
      // 合并500ms内的操作, 如删除节点会联动删除线条
      Date.now() - element.getTimestamp() < 500
    ) {
      return true;
    }
    return false;
  }
};

// src/operation-metas/reset-layout.ts
var resetLayoutOperationMeta = {
  ...baseOperationMeta,
  type: "resetLayout" /* resetLayout */,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      value: op.value.oldValue,
      oldValue: op.value.value
    }
  }),
  apply: async (operation, ctx) => {
    const reset = ctx.get(import_free_layout_core7.WorkflowResetLayoutService);
    await reset.layoutToPositions(operation.value.ids, operation.value.value);
  },
  shouldMerge: () => false
};

// src/operation-metas/move-child-nodes.ts
var import_free_layout_core8 = require("@flowgram.ai/free-layout-core");
var import_document = require("@flowgram.ai/document");
var import_document2 = require("@flowgram.ai/document");
var import_core2 = require("@flowgram.ai/core");
var moveChildNodesOperationMeta = {
  ...baseOperationMeta,
  type: import_document.OperationType.moveChildNodes,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      fromIndex: op.value.toIndex,
      toIndex: op.value.fromIndex,
      fromParentId: op.value.toParentId,
      toParentId: op.value.fromParentId
    }
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(import_free_layout_core8.WorkflowDocument);
    document.moveChildNodes(operation.value);
    const fromContainer = document.getNode(operation.value.fromParentId);
    requestAnimationFrame(() => {
      if (fromContainer && fromContainer.flowNodeType !== import_document2.FlowNodeBaseType.ROOT) {
        const fromContainerTransformData = fromContainer.getData(import_core2.TransformData);
        fromContainerTransformData.fireChange();
      }
    });
  }
};

// src/operation-metas/drag-nodes.ts
var import_free_layout_core9 = require("@flowgram.ai/free-layout-core");
var import_core3 = require("@flowgram.ai/core");
var dragNodesOperationMeta = {
  ...baseOperationMeta,
  type: "dragNodes" /* dragNodes */,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      value: op.value.oldValue,
      oldValue: op.value.value
    }
  }),
  apply: (operation, ctx) => {
    operation.value.ids.forEach((id, index) => {
      const document = ctx.get(import_free_layout_core9.WorkflowDocument);
      const node = document.getNode(id);
      if (!node) {
        return;
      }
      const transform = node.getData(import_core3.TransformData);
      const point = operation.value.value[index];
      transform.update({
        position: {
          x: point.x,
          y: point.y
        }
      });
      document.layout.updateAffectedTransform(node);
    });
  }
};

// src/operation-metas/delete-node.ts
var import_free_layout_core10 = require("@flowgram.ai/free-layout-core");
var deleteNodeOperationMeta = {
  ...baseOperationMeta,
  type: "deleteNode" /* deleteNode */,
  inverse: (op) => ({
    ...op,
    type: "addNode" /* addNode */
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(import_free_layout_core10.WorkflowDocument);
    const node = document.getNode(operation.value.node.id);
    if (node) {
      node.dispose();
    }
  },
  getLabel: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    return `Delete Node ${config.getNodeLabel(op.value.node)}`;
  },
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    let desc = `Delete Node ${config.getNodeLabel(op.value.node)}`;
    if (op.value.node.meta?.position) {
      desc += ` at ${op.value.node.meta.position.x},${op.value.node.meta.position.y}`;
    }
    return desc;
  }
};

// src/operation-metas/delete-line.ts
var import_free_layout_core11 = require("@flowgram.ai/free-layout-core");
var deleteLineOperationMeta = {
  ...baseOperationMeta,
  type: "deleteLine" /* deleteLine */,
  inverse: (op) => ({
    ...op,
    type: "addLine" /* addLine */
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(import_free_layout_core11.WorkflowDocument);
    document.removeNode(operation.value.id);
  },
  getLabel: (op, ctx) => "Delete Line",
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const { value } = op;
    if (!value.from || !value.to) {
      return "Delete Line";
    }
    const fromName = config.getNodeLabelById(value.from);
    const toName = config.getNodeLabelById(value.to);
    return `Delete Line from ${fromName} to ${toName}`;
  }
};

// src/operation-metas/change-node-data.ts
var import_form_core2 = require("@flowgram.ai/form-core");
var import_free_layout_core12 = require("@flowgram.ai/free-layout-core");
var changeNodeDataOperationMeta = {
  ...baseOperationMeta,
  type: "changeNodeData" /* changeNodeData */,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      value: op.value.oldValue,
      oldValue: op.value.value
    }
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(import_free_layout_core12.WorkflowDocument);
    const node = document.getNode(operation.value.id);
    if (!node) {
      return;
    }
    const formData = node.getData(import_form_core2.FlowNodeFormData);
    if (!formData) {
      return;
    }
    let { path } = operation.value;
    if (path.endsWith("/") && path !== "/") {
      path = path.slice(0, -1);
    }
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    const formItem = formData.formModel.getFormItemByPath(path);
    if (!formItem) {
      return;
    }
    formItem.value = operation.value.value;
  },
  shouldMerge: (op, prev, element) => {
    if (!prev) {
      return false;
    }
    if (Date.now() - element.getTimestamp() < 500) {
      if (op.type === prev.type && // 相同类型
      op.value.id === prev.value.id && // 相同节点
      op.value?.path === prev.value?.path) {
        return {
          type: op.type,
          value: {
            ...op.value,
            value: op.value.value,
            oldValue: prev.value.oldValue
          }
        };
      }
      return true;
    }
    return false;
  }
};

// src/operation-metas/add-node.ts
var import_lodash3 = require("lodash");
var import_free_layout_core13 = require("@flowgram.ai/free-layout-core");
var addNodeOperationMeta = {
  ...baseOperationMeta,
  type: "addNode" /* addNode */,
  inverse: (op) => ({
    ...op,
    type: "deleteNode" /* deleteNode */
  }),
  apply: async (operation, ctx) => {
    const document = ctx.get(import_free_layout_core13.WorkflowDocument);
    await document.createWorkflowNode(
      (0, import_lodash3.cloneDeep)(operation.value.node),
      false,
      operation.value.parentID
    );
  },
  getLabel: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    return `Create Node ${config.getNodeLabel(op.value.node)}`;
  },
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    let desc = `Create Node ${config.getNodeLabel(op.value.node)}`;
    if (op.value.node.meta?.position) {
      desc += ` at ${op.value.node.meta.position.x},${op.value.node.meta.position.y}`;
    }
    return desc;
  }
};

// src/operation-metas/add-line.ts
var import_free_layout_core14 = require("@flowgram.ai/free-layout-core");
var addLineOperationMeta = {
  ...baseOperationMeta,
  type: "addLine" /* addLine */,
  inverse: (op) => ({
    ...op,
    type: "deleteLine" /* deleteLine */
  }),
  apply: (operation, ctx) => {
    const linesManager = ctx.get(import_free_layout_core14.WorkflowLinesManager);
    linesManager.createLine({
      ...operation.value,
      key: operation.value.id
    });
  },
  getLabel: (op, ctx) => "Create Line",
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const { value } = op;
    if (!value.from || !value.to) {
      return "Create Line";
    }
    const fromName = config.getNodeLabelById(value.from);
    const toName = config.getNodeLabelById(value.to);
    return `Create Line from ${fromName} to ${toName}`;
  }
};

// src/operation-metas/index.ts
var operationMetas = [
  addLineOperationMeta,
  deleteLineOperationMeta,
  addNodeOperationMeta,
  deleteNodeOperationMeta,
  changeNodeDataOperationMeta,
  resetLayoutOperationMeta,
  dragNodesOperationMeta,
  moveChildNodesOperationMeta
];

// src/free-history-registers.ts
var FreeHistoryRegisters = class {
  registerOperationMeta(operationRegistry) {
    operationMetas.forEach((operationMeta) => {
      operationRegistry.registerOperationMeta(operationMeta);
    });
  }
};
FreeHistoryRegisters = __decorateClass([
  (0, import_inversify6.injectable)()
], FreeHistoryRegisters);

// src/free-history-manager.ts
var import_lodash4 = require("lodash");
var import_inversify7 = require("inversify");
var import_utils2 = require("@flowgram.ai/utils");
var import_history4 = require("@flowgram.ai/history");
var import_free_layout_core15 = require("@flowgram.ai/free-layout-core");
var import_form_core3 = require("@flowgram.ai/form-core");
var import_form_core4 = require("@flowgram.ai/form-core");
var import_document3 = require("@flowgram.ai/document");
var import_core4 = require("@flowgram.ai/core");
var FreeHistoryManager = class {
  constructor() {
    this._toDispose = new import_utils2.DisposableCollection();
  }
  onInit(ctx, opts) {
    const document = ctx.get(import_free_layout_core15.WorkflowDocument);
    const historyService = ctx.get(import_history4.HistoryService);
    const dragService = ctx.get(import_free_layout_core15.WorkflowDragService);
    const resetLayoutService = ctx.get(import_free_layout_core15.WorkflowResetLayoutService);
    if (opts?.limit) {
      historyService.limit(opts.limit);
    }
    historyService.context.source = ctx;
    this._toDispose.pushAll([
      dragService.onNodesDrag(async (event) => {
        if (event.type !== "onDragEnd") {
          return;
        }
        this._dragNodesHandler.handle(event);
      }),
      document.onNodeCreate(({ node, data }) => {
        const positionData = node.getData(import_core4.PositionData);
        if (positionData) {
          this._entityManager.addEntityData(positionData);
        }
      }),
      this._formManager ? this._formManager.onFormModelWillInit(({ model, data }) => {
        const node = model.flowNodeEntity;
        const formData = node.getData(import_form_core3.FlowNodeFormData);
        if (formData) {
          this._entityManager.setValue(formData, (0, import_lodash4.cloneDeep)(data));
          this._toDispose.push(
            formData.onDetailChange((event) => {
              this._changeNodeDataHandler.handle({
                ...event,
                node
              });
            })
          );
        }
      }) : import_utils2.Disposable.NULL,
      document.onContentChange((event) => {
        this._changeContentHandler.handle(event, ctx);
      }),
      document.onReload((_event) => {
        historyService.clear();
      }),
      resetLayoutService.onResetLayout((event) => {
        historyService.pushOperation(
          {
            type: "resetLayout" /* resetLayout */,
            value: {
              ids: event.nodeIds,
              value: event.positionMap,
              oldValue: event.oldPositionMap
            }
          },
          { noApply: true }
        );
      }),
      this._operationService.onNodeMove(({ node, fromParent, fromIndex, toParent, toIndex }) => {
        historyService.pushOperation(
          {
            type: import_document3.OperationType.moveChildNodes,
            value: {
              fromParentId: fromParent.id,
              fromIndex,
              nodeIds: [node.id],
              toParentId: toParent.id,
              toIndex
            }
          },
          {
            noApply: true
          }
        );
      }),
      this._operationService.onNodePostionUpdate((event) => {
        const value = {
          ids: [event.node.id],
          value: [event.newPosition],
          oldValue: [event.oldPosition]
        };
        historyService.pushOperation(
          {
            type: "dragNodes" /* dragNodes */,
            value
          },
          {
            noApply: true
          }
        );
      })
    ]);
  }
  dispose() {
    this._entityManager.dispose();
    this._toDispose.dispose();
  }
};
__decorateClass([
  (0, import_inversify7.inject)(DragNodesHandler)
], FreeHistoryManager.prototype, "_dragNodesHandler", 2);
__decorateClass([
  (0, import_inversify7.inject)(ChangeNodeDataHandler)
], FreeHistoryManager.prototype, "_changeNodeDataHandler", 2);
__decorateClass([
  (0, import_inversify7.inject)(ChangeContentHandler)
], FreeHistoryManager.prototype, "_changeContentHandler", 2);
__decorateClass([
  (0, import_inversify7.inject)(HistoryEntityManager)
], FreeHistoryManager.prototype, "_entityManager", 2);
__decorateClass([
  (0, import_inversify7.inject)(import_form_core4.FormManager),
  (0, import_inversify7.optional)()
], FreeHistoryManager.prototype, "_formManager", 2);
__decorateClass([
  (0, import_inversify7.inject)(import_free_layout_core15.WorkflowOperationBaseService)
], FreeHistoryManager.prototype, "_operationService", 2);
FreeHistoryManager = __decorateClass([
  (0, import_inversify7.injectable)()
], FreeHistoryManager);

// src/create-free-history-plugin.ts
var createFreeHistoryPlugin = (0, import_core5.definePluginCreator)({
  onBind: ({ bind }) => {
    (0, import_core5.bindContributions)(bind, FreeHistoryRegisters, [import_history5.OperationContribution]);
    bind(FreeHistoryConfig).toSelf().inSingletonScope();
    bind(FreeHistoryManager).toSelf().inSingletonScope();
    bind(HistoryEntityManager).toSelf().inSingletonScope();
    bind(DragNodesHandler).toSelf().inSingletonScope();
    bind(ChangeNodeDataHandler).toSelf().inSingletonScope();
    bind(ChangeContentHandler).toSelf().inSingletonScope();
  },
  onInit(ctx, opts) {
    ctx.get(FreeHistoryConfig).init(ctx, opts);
    if (!opts.enable) {
      return;
    }
    ctx.get(FreeHistoryManager).onInit(ctx, opts);
  },
  onDispose(ctx) {
    ctx.get(HistoryEntityManager).dispose();
  },
  containerModules: [import_history5.HistoryContainerModule]
});

// src/index.ts
__reExport(src_exports, require("@flowgram.ai/history"), module.exports);

// src/hooks/use-undo-redo.tsx
var import_react = require("react");
var import_core6 = require("@flowgram.ai/core");
var import_history6 = require("@flowgram.ai/history");
function useUndoRedo() {
  const historyService = (0, import_core6.useService)(import_history6.HistoryService);
  const [canUndo, setCanUndo] = (0, import_react.useState)(false);
  const [canRedo, setCanRedo] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    const toDispose = historyService.undoRedoService.onChange(() => {
      setCanUndo(historyService.canUndo());
      setCanRedo(historyService.canRedo());
    });
    return () => {
      toDispose.dispose();
    };
  }, []);
  return {
    canUndo,
    canRedo,
    undo: () => historyService.undo(),
    redo: () => historyService.redo()
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FreeHistoryConfig,
  FreeHistoryRegisters,
  FreeOperationType,
  createFreeHistoryPlugin,
  useUndoRedo,
  ...require("@flowgram.ai/history")
});
//# sourceMappingURL=index.js.map