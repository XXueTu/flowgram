var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/create-free-history-plugin.ts
import { bindContributions, definePluginCreator } from "@flowgram.ai/core";
import { HistoryContainerModule, OperationContribution } from "@flowgram.ai/history";

// src/history-entity-manager.ts
import { cloneDeep, isEqual } from "lodash";
import { injectable } from "inversify";
import { DisposableCollection } from "@flowgram.ai/utils";
var HistoryEntityManager = class {
  constructor() {
    this._entityDataValues = /* @__PURE__ */ new Map();
    this._toDispose = new DisposableCollection();
  }
  addEntityData(entityData) {
    this._entityDataValues.set(entityData, cloneDeep(entityData.toJSON()));
    this._toDispose.push(
      entityData.onWillChange((event) => {
        const value = event.toJSON();
        const oldValue = this._entityDataValues.get(entityData);
        if (isEqual(value, oldValue)) {
          return;
        }
        this._entityDataValues.set(entityData, cloneDeep(value));
      })
    );
  }
  getValue(entityData) {
    return this._entityDataValues.get(entityData);
  }
  setValue(entityData, value) {
    return this._entityDataValues.set(entityData, value);
  }
  dispose() {
    this._entityDataValues.clear();
    this._toDispose.dispose();
  }
};
HistoryEntityManager = __decorateClass([
  injectable()
], HistoryEntityManager);

// src/handlers/drag-nodes-handler.ts
import { injectable as injectable2, inject } from "inversify";
import { HistoryService } from "@flowgram.ai/history";
import { TransformData } from "@flowgram.ai/core";

// src/types.ts
var FreeOperationType = /* @__PURE__ */ ((FreeOperationType2) => {
  FreeOperationType2["addLine"] = "addLine";
  FreeOperationType2["deleteLine"] = "deleteLine";
  FreeOperationType2["moveNode"] = "moveNode";
  FreeOperationType2["addNode"] = "addNode";
  FreeOperationType2["deleteNode"] = "deleteNode";
  FreeOperationType2["changeNodeData"] = "changeNodeData";
  FreeOperationType2["resetLayout"] = "resetLayout";
  FreeOperationType2["dragNodes"] = "dragNodes";
  FreeOperationType2["moveChildNodes"] = "moveChildNodes";
  return FreeOperationType2;
})(FreeOperationType || {});

// src/handlers/drag-nodes-handler.ts
var DragNodesHandler = class {
  handle(event) {
    if (event.type === "onDragEnd") {
      this._dragNode(event);
    }
  }
  _dragNode(event) {
    this._historyService.pushOperation(
      {
        type: "dragNodes" /* dragNodes */,
        value: {
          ids: event.nodes.map((node) => node.id),
          value: event.nodes.map((node) => {
            const { x, y } = node.getData(TransformData).position;
            return {
              x,
              y
            };
          }),
          oldValue: event.startPositions
        }
      },
      { noApply: true }
    );
  }
};
__decorateClass([
  inject(HistoryService)
], DragNodesHandler.prototype, "_historyService", 2);
DragNodesHandler = __decorateClass([
  injectable2()
], DragNodesHandler);

// src/handlers/change-node-data-handler.ts
import { cloneDeep as cloneDeep2, get, isEqual as isEqual2, set } from "lodash";
import { injectable as injectable4, inject as inject2 } from "inversify";
import { FlowNodeFormData } from "@flowgram.ai/form-core";
import { WorkflowDocument } from "@flowgram.ai/free-layout-core";
import { HistoryService as HistoryService2 } from "@flowgram.ai/history";

// src/free-history-config.ts
import { injectable as injectable3 } from "inversify";
var FreeHistoryConfig = class {
  constructor() {
    this.enable = false;
    this.nodeToJSON = (node) => node.toJSON();
    this.getNodeLabelById = (id) => id;
    this.getNodeLabel = (node) => node.id;
    this.getBlockLabel = (node) => node.id;
    this.getNodeURI = (id) => `node:${id}`;
    this.getLineURI = (id) => `line:${id}`;
  }
  init(ctx, options) {
    this.enable = !!options?.enable;
    if (options.nodeToJSON) {
      this.nodeToJSON = options.nodeToJSON(ctx);
    }
    if (options.getNodeLabelById) {
      this.getNodeLabelById = options.getNodeLabelById(ctx);
    }
    if (options.getNodeLabel) {
      this.getNodeLabel = options.getNodeLabel(ctx);
    }
    if (options.getBlockLabel) {
      this.getBlockLabel = options.getBlockLabel(ctx);
    }
    if (options.getNodeURI) {
      this.getNodeURI = options.getNodeURI(ctx);
    }
    if (options.getLineURI) {
      this.getLineURI = options.getLineURI(ctx);
    }
  }
};
FreeHistoryConfig = __decorateClass([
  injectable3()
], FreeHistoryConfig);

// src/handlers/change-node-data-handler.ts
var ChangeNodeDataHandler = class {
  handle(event) {
    const { path, value, initialized, node } = event;
    const formData = node.getData(FlowNodeFormData);
    const oldValue = this._entityManager.getValue(formData);
    const propPath = path.split("/").filter(Boolean).join(".");
    const propOldValue = propPath ? get(oldValue, propPath) : oldValue;
    if (isEqual2(value, propOldValue)) {
      return;
    }
    if (initialized) {
      let operationPath = path;
      let operationValue = cloneDeep2(value);
      let operationOldValue = propOldValue;
      if (path !== "/") {
        const clonedOldValue = cloneDeep2(oldValue);
        set(clonedOldValue, propPath, value);
        operationPath = path.split("/").filter(Boolean)[0];
        operationValue = get(clonedOldValue, operationPath);
        operationOldValue = get(oldValue, operationPath);
      }
      this._historyService.pushOperation(
        {
          type: "changeNodeData" /* changeNodeData */,
          value: {
            id: node.id,
            path: operationPath,
            value: operationValue,
            oldValue: operationOldValue
          },
          uri: this._config.getNodeURI(node.id)
        },
        { noApply: true }
      );
    }
    if (propPath) {
      set(oldValue, propPath, cloneDeep2(value));
    } else {
      this._entityManager.setValue(formData, cloneDeep2(value));
    }
  }
};
__decorateClass([
  inject2(HistoryService2)
], ChangeNodeDataHandler.prototype, "_historyService", 2);
__decorateClass([
  inject2(WorkflowDocument)
], ChangeNodeDataHandler.prototype, "document", 2);
__decorateClass([
  inject2(HistoryEntityManager)
], ChangeNodeDataHandler.prototype, "_entityManager", 2);
__decorateClass([
  inject2(FreeHistoryConfig)
], ChangeNodeDataHandler.prototype, "_config", 2);
ChangeNodeDataHandler = __decorateClass([
  injectable4()
], ChangeNodeDataHandler);

// src/handlers/change-content-handler.ts
import { injectable as injectable5, inject as inject3 } from "inversify";
import { HistoryService as HistoryService3 } from "@flowgram.ai/history";

// src/changes/delete-node-change.ts
import { WorkflowContentChangeType } from "@flowgram.ai/free-layout-core";
var deleteNodeChange = {
  type: WorkflowContentChangeType.DELETE_NODE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const node = event.entity;
    const json = event.toJSON();
    const parentID = node.parent?.id;
    return {
      type: "deleteNode" /* deleteNode */,
      value: {
        node: json,
        parentID
      },
      uri: config.getNodeURI(node.id)
    };
  }
};

// src/changes/delete-line-change.ts
import { WorkflowContentChangeType as WorkflowContentChangeType2 } from "@flowgram.ai/free-layout-core";
var deleteLineChange = {
  type: WorkflowContentChangeType2.DELETE_LINE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const line = event.entity;
    const value = {
      from: line.info.from,
      to: line.info.to || "",
      fromPort: line.info.fromPort || "",
      toPort: line.info.toPort || "",
      id: line.id
    };
    return {
      type: "deleteLine" /* deleteLine */,
      value,
      uri: config.getNodeURI(line.id)
    };
  }
};

// src/changes/add-node-change.ts
import { WorkflowDocument as WorkflowDocument2 } from "@flowgram.ai/free-layout-core";
import { WorkflowContentChangeType as WorkflowContentChangeType3 } from "@flowgram.ai/free-layout-core";
var addNodeChange = {
  type: WorkflowContentChangeType3.ADD_NODE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const document = ctx.get(WorkflowDocument2);
    const node = event.entity;
    const parentID = node.parent?.id;
    const json = document.toNodeJSON(node);
    return {
      type: "addNode" /* addNode */,
      value: {
        node: json,
        parentID
      },
      uri: config.getNodeURI(node.id)
    };
  }
};

// src/changes/add-line-change.ts
import { WorkflowContentChangeType as WorkflowContentChangeType4 } from "@flowgram.ai/free-layout-core";
var addLineChange = {
  type: WorkflowContentChangeType4.ADD_LINE,
  toOperation: (event, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const line = event.entity;
    const value = {
      from: line.info.from,
      to: line.info.to || "",
      fromPort: line.info.fromPort || "",
      toPort: line.info.toPort || "",
      id: line.id
    };
    return {
      type: "addLine" /* addLine */,
      value,
      uri: config.getLineURI(line.id)
    };
  }
};

// src/changes/index.ts
var changes_default = [addLineChange, deleteLineChange, addNodeChange, deleteNodeChange];

// src/handlers/change-content-handler.ts
var ChangeContentHandler = class {
  handle(event, ctx) {
    if (!this._historyService.undoRedoService.canPush()) {
      return;
    }
    const change = changes_default.find((c) => c.type === event.type);
    if (!change) {
      return;
    }
    const operation = change.toOperation(event, ctx);
    if (!operation) {
      return;
    }
    this._historyService.pushOperation(operation, { noApply: true });
  }
};
__decorateClass([
  inject3(HistoryService3)
], ChangeContentHandler.prototype, "_historyService", 2);
ChangeContentHandler = __decorateClass([
  injectable5()
], ChangeContentHandler);

// src/free-history-registers.ts
import { injectable as injectable6 } from "inversify";

// src/operation-metas/reset-layout.ts
import { WorkflowResetLayoutService } from "@flowgram.ai/free-layout-core";

// src/operation-metas/base.ts
var baseOperationMeta = {
  shouldMerge: (_op, prev, element) => {
    if (!prev) {
      return false;
    }
    if (
      // 合并500ms内的操作, 如删除节点会联动删除线条
      Date.now() - element.getTimestamp() < 500
    ) {
      return true;
    }
    return false;
  }
};

// src/operation-metas/reset-layout.ts
var resetLayoutOperationMeta = {
  ...baseOperationMeta,
  type: "resetLayout" /* resetLayout */,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      value: op.value.oldValue,
      oldValue: op.value.value
    }
  }),
  apply: async (operation, ctx) => {
    const reset = ctx.get(WorkflowResetLayoutService);
    await reset.layoutToPositions(operation.value.ids, operation.value.value);
  },
  shouldMerge: () => false
};

// src/operation-metas/move-child-nodes.ts
import { WorkflowDocument as WorkflowDocument3 } from "@flowgram.ai/free-layout-core";
import { OperationType } from "@flowgram.ai/document";
import { FlowNodeBaseType } from "@flowgram.ai/document";
import { TransformData as TransformData2 } from "@flowgram.ai/core";
var moveChildNodesOperationMeta = {
  ...baseOperationMeta,
  type: OperationType.moveChildNodes,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      fromIndex: op.value.toIndex,
      toIndex: op.value.fromIndex,
      fromParentId: op.value.toParentId,
      toParentId: op.value.fromParentId
    }
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(WorkflowDocument3);
    document.moveChildNodes(operation.value);
    const fromContainer = document.getNode(operation.value.fromParentId);
    requestAnimationFrame(() => {
      if (fromContainer && fromContainer.flowNodeType !== FlowNodeBaseType.ROOT) {
        const fromContainerTransformData = fromContainer.getData(TransformData2);
        fromContainerTransformData.fireChange();
      }
    });
  }
};

// src/operation-metas/drag-nodes.ts
import { WorkflowDocument as WorkflowDocument4 } from "@flowgram.ai/free-layout-core";
import { TransformData as TransformData3 } from "@flowgram.ai/core";
var dragNodesOperationMeta = {
  ...baseOperationMeta,
  type: "dragNodes" /* dragNodes */,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      value: op.value.oldValue,
      oldValue: op.value.value
    }
  }),
  apply: (operation, ctx) => {
    operation.value.ids.forEach((id, index) => {
      const document = ctx.get(WorkflowDocument4);
      const node = document.getNode(id);
      if (!node) {
        return;
      }
      const transform = node.getData(TransformData3);
      const point = operation.value.value[index];
      transform.update({
        position: {
          x: point.x,
          y: point.y
        }
      });
      document.layout.updateAffectedTransform(node);
    });
  }
};

// src/operation-metas/delete-node.ts
import { WorkflowDocument as WorkflowDocument5 } from "@flowgram.ai/free-layout-core";
var deleteNodeOperationMeta = {
  ...baseOperationMeta,
  type: "deleteNode" /* deleteNode */,
  inverse: (op) => ({
    ...op,
    type: "addNode" /* addNode */
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(WorkflowDocument5);
    const node = document.getNode(operation.value.node.id);
    if (node) {
      node.dispose();
    }
  },
  getLabel: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    return `Delete Node ${config.getNodeLabel(op.value.node)}`;
  },
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    let desc = `Delete Node ${config.getNodeLabel(op.value.node)}`;
    if (op.value.node.meta?.position) {
      desc += ` at ${op.value.node.meta.position.x},${op.value.node.meta.position.y}`;
    }
    return desc;
  }
};

// src/operation-metas/delete-line.ts
import { WorkflowDocument as WorkflowDocument6 } from "@flowgram.ai/free-layout-core";
var deleteLineOperationMeta = {
  ...baseOperationMeta,
  type: "deleteLine" /* deleteLine */,
  inverse: (op) => ({
    ...op,
    type: "addLine" /* addLine */
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(WorkflowDocument6);
    document.removeNode(operation.value.id);
  },
  getLabel: (op, ctx) => "Delete Line",
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const { value } = op;
    if (!value.from || !value.to) {
      return "Delete Line";
    }
    const fromName = config.getNodeLabelById(value.from);
    const toName = config.getNodeLabelById(value.to);
    return `Delete Line from ${fromName} to ${toName}`;
  }
};

// src/operation-metas/change-node-data.ts
import { FlowNodeFormData as FlowNodeFormData2 } from "@flowgram.ai/form-core";
import { WorkflowDocument as WorkflowDocument7 } from "@flowgram.ai/free-layout-core";
var changeNodeDataOperationMeta = {
  ...baseOperationMeta,
  type: "changeNodeData" /* changeNodeData */,
  inverse: (op) => ({
    ...op,
    value: {
      ...op.value,
      value: op.value.oldValue,
      oldValue: op.value.value
    }
  }),
  apply: (operation, ctx) => {
    const document = ctx.get(WorkflowDocument7);
    const node = document.getNode(operation.value.id);
    if (!node) {
      return;
    }
    const formData = node.getData(FlowNodeFormData2);
    if (!formData) {
      return;
    }
    let { path } = operation.value;
    if (path.endsWith("/") && path !== "/") {
      path = path.slice(0, -1);
    }
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    const formItem = formData.formModel.getFormItemByPath(path);
    if (!formItem) {
      return;
    }
    formItem.value = operation.value.value;
  },
  shouldMerge: (op, prev, element) => {
    if (!prev) {
      return false;
    }
    if (Date.now() - element.getTimestamp() < 500) {
      if (op.type === prev.type && // 相同类型
      op.value.id === prev.value.id && // 相同节点
      op.value?.path === prev.value?.path) {
        return {
          type: op.type,
          value: {
            ...op.value,
            value: op.value.value,
            oldValue: prev.value.oldValue
          }
        };
      }
      return true;
    }
    return false;
  }
};

// src/operation-metas/add-node.ts
import { cloneDeep as cloneDeep3 } from "lodash";
import { WorkflowDocument as WorkflowDocument8 } from "@flowgram.ai/free-layout-core";
var addNodeOperationMeta = {
  ...baseOperationMeta,
  type: "addNode" /* addNode */,
  inverse: (op) => ({
    ...op,
    type: "deleteNode" /* deleteNode */
  }),
  apply: async (operation, ctx) => {
    const document = ctx.get(WorkflowDocument8);
    await document.createWorkflowNode(
      cloneDeep3(operation.value.node),
      false,
      operation.value.parentID
    );
  },
  getLabel: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    return `Create Node ${config.getNodeLabel(op.value.node)}`;
  },
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    let desc = `Create Node ${config.getNodeLabel(op.value.node)}`;
    if (op.value.node.meta?.position) {
      desc += ` at ${op.value.node.meta.position.x},${op.value.node.meta.position.y}`;
    }
    return desc;
  }
};

// src/operation-metas/add-line.ts
import { WorkflowLinesManager } from "@flowgram.ai/free-layout-core";
var addLineOperationMeta = {
  ...baseOperationMeta,
  type: "addLine" /* addLine */,
  inverse: (op) => ({
    ...op,
    type: "deleteLine" /* deleteLine */
  }),
  apply: (operation, ctx) => {
    const linesManager = ctx.get(WorkflowLinesManager);
    linesManager.createLine({
      ...operation.value,
      key: operation.value.id
    });
  },
  getLabel: (op, ctx) => "Create Line",
  getDescription: (op, ctx) => {
    const config = ctx.get(FreeHistoryConfig);
    const { value } = op;
    if (!value.from || !value.to) {
      return "Create Line";
    }
    const fromName = config.getNodeLabelById(value.from);
    const toName = config.getNodeLabelById(value.to);
    return `Create Line from ${fromName} to ${toName}`;
  }
};

// src/operation-metas/index.ts
var operationMetas = [
  addLineOperationMeta,
  deleteLineOperationMeta,
  addNodeOperationMeta,
  deleteNodeOperationMeta,
  changeNodeDataOperationMeta,
  resetLayoutOperationMeta,
  dragNodesOperationMeta,
  moveChildNodesOperationMeta
];

// src/free-history-registers.ts
var FreeHistoryRegisters = class {
  registerOperationMeta(operationRegistry) {
    operationMetas.forEach((operationMeta) => {
      operationRegistry.registerOperationMeta(operationMeta);
    });
  }
};
FreeHistoryRegisters = __decorateClass([
  injectable6()
], FreeHistoryRegisters);

// src/free-history-manager.ts
import { cloneDeep as cloneDeep4 } from "lodash";
import { injectable as injectable7, inject as inject4, optional } from "inversify";
import { DisposableCollection as DisposableCollection2, Disposable } from "@flowgram.ai/utils";
import { HistoryService as HistoryService4 } from "@flowgram.ai/history";
import {
  WorkflowDocument as WorkflowDocument9,
  WorkflowResetLayoutService as WorkflowResetLayoutService2,
  WorkflowDragService,
  WorkflowOperationBaseService
} from "@flowgram.ai/free-layout-core";
import { FlowNodeFormData as FlowNodeFormData3 } from "@flowgram.ai/form-core";
import { FormManager } from "@flowgram.ai/form-core";
import { OperationType as OperationType2 } from "@flowgram.ai/document";
import { PositionData } from "@flowgram.ai/core";
var FreeHistoryManager = class {
  constructor() {
    this._toDispose = new DisposableCollection2();
  }
  onInit(ctx, opts) {
    const document = ctx.get(WorkflowDocument9);
    const historyService = ctx.get(HistoryService4);
    const dragService = ctx.get(WorkflowDragService);
    const resetLayoutService = ctx.get(WorkflowResetLayoutService2);
    if (opts?.limit) {
      historyService.limit(opts.limit);
    }
    historyService.context.source = ctx;
    this._toDispose.pushAll([
      dragService.onNodesDrag(async (event) => {
        if (event.type !== "onDragEnd") {
          return;
        }
        this._dragNodesHandler.handle(event);
      }),
      document.onNodeCreate(({ node, data }) => {
        const positionData = node.getData(PositionData);
        if (positionData) {
          this._entityManager.addEntityData(positionData);
        }
      }),
      this._formManager ? this._formManager.onFormModelWillInit(({ model, data }) => {
        const node = model.flowNodeEntity;
        const formData = node.getData(FlowNodeFormData3);
        if (formData) {
          this._entityManager.setValue(formData, cloneDeep4(data));
          this._toDispose.push(
            formData.onDetailChange((event) => {
              this._changeNodeDataHandler.handle({
                ...event,
                node
              });
            })
          );
        }
      }) : Disposable.NULL,
      document.onContentChange((event) => {
        this._changeContentHandler.handle(event, ctx);
      }),
      document.onReload((_event) => {
        historyService.clear();
      }),
      resetLayoutService.onResetLayout((event) => {
        historyService.pushOperation(
          {
            type: "resetLayout" /* resetLayout */,
            value: {
              ids: event.nodeIds,
              value: event.positionMap,
              oldValue: event.oldPositionMap
            }
          },
          { noApply: true }
        );
      }),
      this._operationService.onNodeMove(({ node, fromParent, fromIndex, toParent, toIndex }) => {
        historyService.pushOperation(
          {
            type: OperationType2.moveChildNodes,
            value: {
              fromParentId: fromParent.id,
              fromIndex,
              nodeIds: [node.id],
              toParentId: toParent.id,
              toIndex
            }
          },
          {
            noApply: true
          }
        );
      }),
      this._operationService.onNodePostionUpdate((event) => {
        const value = {
          ids: [event.node.id],
          value: [event.newPosition],
          oldValue: [event.oldPosition]
        };
        historyService.pushOperation(
          {
            type: "dragNodes" /* dragNodes */,
            value
          },
          {
            noApply: true
          }
        );
      })
    ]);
  }
  dispose() {
    this._entityManager.dispose();
    this._toDispose.dispose();
  }
};
__decorateClass([
  inject4(DragNodesHandler)
], FreeHistoryManager.prototype, "_dragNodesHandler", 2);
__decorateClass([
  inject4(ChangeNodeDataHandler)
], FreeHistoryManager.prototype, "_changeNodeDataHandler", 2);
__decorateClass([
  inject4(ChangeContentHandler)
], FreeHistoryManager.prototype, "_changeContentHandler", 2);
__decorateClass([
  inject4(HistoryEntityManager)
], FreeHistoryManager.prototype, "_entityManager", 2);
__decorateClass([
  inject4(FormManager),
  optional()
], FreeHistoryManager.prototype, "_formManager", 2);
__decorateClass([
  inject4(WorkflowOperationBaseService)
], FreeHistoryManager.prototype, "_operationService", 2);
FreeHistoryManager = __decorateClass([
  injectable7()
], FreeHistoryManager);

// src/create-free-history-plugin.ts
var createFreeHistoryPlugin = definePluginCreator({
  onBind: ({ bind }) => {
    bindContributions(bind, FreeHistoryRegisters, [OperationContribution]);
    bind(FreeHistoryConfig).toSelf().inSingletonScope();
    bind(FreeHistoryManager).toSelf().inSingletonScope();
    bind(HistoryEntityManager).toSelf().inSingletonScope();
    bind(DragNodesHandler).toSelf().inSingletonScope();
    bind(ChangeNodeDataHandler).toSelf().inSingletonScope();
    bind(ChangeContentHandler).toSelf().inSingletonScope();
  },
  onInit(ctx, opts) {
    ctx.get(FreeHistoryConfig).init(ctx, opts);
    if (!opts.enable) {
      return;
    }
    ctx.get(FreeHistoryManager).onInit(ctx, opts);
  },
  onDispose(ctx) {
    ctx.get(HistoryEntityManager).dispose();
  },
  containerModules: [HistoryContainerModule]
});

// src/index.ts
export * from "@flowgram.ai/history";

// src/hooks/use-undo-redo.tsx
import { useEffect, useState } from "react";
import { useService } from "@flowgram.ai/core";
import { HistoryService as HistoryService5 } from "@flowgram.ai/history";
function useUndoRedo() {
  const historyService = useService(HistoryService5);
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  useEffect(() => {
    const toDispose = historyService.undoRedoService.onChange(() => {
      setCanUndo(historyService.canUndo());
      setCanRedo(historyService.canRedo());
    });
    return () => {
      toDispose.dispose();
    };
  }, []);
  return {
    canUndo,
    canRedo,
    undo: () => historyService.undo(),
    redo: () => historyService.redo()
  };
}
export {
  FreeHistoryConfig,
  FreeHistoryRegisters,
  FreeOperationType,
  createFreeHistoryPlugin,
  useUndoRedo
};
//# sourceMappingURL=index.js.map