var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
import "reflect-metadata";
import { useRefresh, Emitter, Event, Disposable } from "@flowgram.ai/utils";
export * from "@flowgram.ai/core";

// src/hooks/use-playground-tools.ts
import { useCallback, useEffect, useState } from "react";
import {
  EditorState,
  EditorStateConfigEntity,
  useConfigEntity,
  usePlayground
} from "@flowgram.ai/core";
import { DisposableCollection } from "@flowgram.ai/utils";
function usePlaygroundTools(props) {
  const { maxZoom = 2, minZoom = 0.25 } = props || {};
  const playground = usePlayground();
  const editorState = useConfigEntity(EditorStateConfigEntity, true);
  const [zoom, setZoom] = useState(1);
  const handleZoomOut = useCallback(
    (easing) => {
      if (zoom < minZoom) {
        return;
      }
      playground.config.zoomout(easing);
    },
    [zoom, playground, minZoom]
  );
  const handleZoomIn = useCallback(
    (easing) => {
      if (zoom > maxZoom) {
        return;
      }
      playground.config.zoomin(easing);
    },
    [zoom, playground, maxZoom]
  );
  const handleUpdateZoom = useCallback(
    (value, easing, easingDuration) => {
      playground.config.updateZoom(value, easing, easingDuration);
    },
    [playground]
  );
  const handleToggleIneractiveType = useCallback(() => {
    if (editorState.isMouseFriendlyMode()) {
      editorState.changeState(EditorState.STATE_SELECT.id);
    } else {
      editorState.changeState(EditorState.STATE_MOUSE_FRIENDLY_SELECT.id);
    }
  }, [editorState]);
  useEffect(() => {
    const dispose = new DisposableCollection();
    dispose.push(playground.onZoom((z) => setZoom(z)));
    return () => dispose.dispose();
  }, [playground]);
  return {
    zoomin: handleZoomIn,
    zoomout: handleZoomOut,
    updateZoom: handleUpdateZoom,
    zoom,
    interactiveType: editorState.isMouseFriendlyMode() ? "MOUSE" : "PAD",
    toggleIneractiveType: handleToggleIneractiveType
  };
}

// src/components/playground-react.tsx
import React2, { useMemo, forwardRef } from "react";
import {
  createPlaygroundPlugin as createPlaygroundPlugin2,
  PlaygroundReactProvider,
  PlaygroundReactRenderer
} from "@flowgram.ai/core";

// src/preset/playground-react-preset.ts
import { createShortcutsPlugin } from "@flowgram.ai/shortcuts-plugin";
import {
  createPlaygroundPlugin,
  PlaygroundConfig,
  PlaygroundLayer
} from "@flowgram.ai/core";
import { createBackgroundPlugin } from "@flowgram.ai/background-plugin";
function createPlaygroundReactPreset(opts, plugins = []) {
  return (ctx) => {
    plugins = plugins.slice();
    if (opts.background || opts.background === void 0) {
      plugins.push(createBackgroundPlugin(opts.background || {}));
    }
    if (opts.shortcuts) {
      plugins.push(
        createShortcutsPlugin({
          registerShortcuts: (registry) => opts.shortcuts(registry, ctx)
        })
      );
    }
    if (opts.plugins) {
      plugins.push(...opts.plugins(ctx));
    }
    plugins.push(
      createPlaygroundPlugin({
        onBind: (bindConfig) => {
          opts.onBind?.(bindConfig);
        },
        onInit: (ctx2) => {
          const playgroundConfig = ctx2.get(PlaygroundConfig);
          if (opts.playground) {
            if (opts.playground.autoFocus !== void 0) {
              playgroundConfig.autoFocus = opts.playground.autoFocus;
            }
            if (opts.playground.autoResize !== void 0) {
              playgroundConfig.autoResize = opts.playground.autoResize;
            }
          }
          playgroundConfig.autoFocus = false;
          ctx2.playground.registerLayer(PlaygroundLayer, opts.playground);
          if (opts.layers) {
            ctx2.playground.registerLayers(...opts.layers);
          }
          if (opts.onInit) opts.onInit(ctx2);
        },
        onReady(ctx2) {
          if (opts.onReady) opts.onReady(ctx2);
        },
        onAllLayersRendered() {
          if (opts.onAllLayersRendered) opts.onAllLayersRendered(ctx);
        },
        onDispose() {
          if (opts.onDispose) opts.onDispose(ctx);
        },
        containerModules: opts.containerModules || []
      })
    );
    return plugins;
  };
}

// src/layers/playground-content-layer.tsx
import React from "react";
import { injectable } from "inversify";
import { Layer } from "@flowgram.ai/core";
import { domUtils } from "@flowgram.ai/utils";
var PlaygroundContentLayer = class extends Layer {
  constructor() {
    super(...arguments);
    this.node = domUtils.createDivWithClass(
      "gedit-playground-layer gedit-playground-content-layer"
    );
  }
  onZoom(scale) {
    this.node.style.transform = `scale(${scale})`;
  }
  onReady() {
    this.node.style.left = "0px";
    this.node.style.top = "0px";
  }
  updateOptions(opts) {
    this.options = opts;
    this.render();
  }
  render() {
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: this.options.className,
        style: { position: "absolute", ...this.options.style }
      },
      this.options.children
    );
  }
};
PlaygroundContentLayer.type = "PlaygroundContentLayer";
PlaygroundContentLayer = __decorateClass([
  injectable()
], PlaygroundContentLayer);

// src/components/playground-react.tsx
var PlaygroundReact = forwardRef(
  function PlaygroundReact2(props, ref) {
    const { parentContainer, children, ...others } = props;
    const contentLoadPlugin = useMemo(
      () => createPlaygroundPlugin2({
        onInit(ctx) {
          ctx.playground.registerLayer(PlaygroundContentLayer);
        }
      }),
      []
    );
    const preset = useMemo(() => createPlaygroundReactPreset(others, [contentLoadPlugin]), []);
    return /* @__PURE__ */ React2.createElement(PlaygroundReactProvider, { ref, plugins: preset, parentContainer }, /* @__PURE__ */ React2.createElement(PlaygroundReactRenderer, null, children));
  }
);

// src/components/playground-react-content.tsx
import React3, { useMemo as useMemo2 } from "react";
import { usePlayground as usePlayground2 } from "@flowgram.ai/core";
var PlaygroundReactContent = (props) => {
  const playground = usePlayground2();
  useMemo2(() => {
    const layer = playground.getLayer(PlaygroundContentLayer);
    layer.updateOptions(props);
  }, [props]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null);
};
export {
  Disposable,
  Emitter,
  Event,
  PlaygroundReact,
  PlaygroundReactContent,
  createPlaygroundReactPreset,
  usePlaygroundTools,
  useRefresh
};
//# sourceMappingURL=index.js.map