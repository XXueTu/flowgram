"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Disposable: () => import_utils3.Disposable,
  Emitter: () => import_utils3.Emitter,
  Event: () => import_utils3.Event,
  PlaygroundReact: () => PlaygroundReact,
  PlaygroundReactContent: () => PlaygroundReactContent,
  createPlaygroundReactPreset: () => createPlaygroundReactPreset,
  usePlaygroundTools: () => usePlaygroundTools,
  useRefresh: () => import_utils3.useRefresh
});
module.exports = __toCommonJS(src_exports);
var import_reflect_metadata = require("reflect-metadata");
var import_utils3 = require("@flowgram.ai/utils");
__reExport(src_exports, require("@flowgram.ai/core"), module.exports);

// src/hooks/use-playground-tools.ts
var import_react = require("react");
var import_core = require("@flowgram.ai/core");
var import_utils = require("@flowgram.ai/utils");
function usePlaygroundTools(props) {
  const { maxZoom = 2, minZoom = 0.25 } = props || {};
  const playground = (0, import_core.usePlayground)();
  const editorState = (0, import_core.useConfigEntity)(import_core.EditorStateConfigEntity, true);
  const [zoom, setZoom] = (0, import_react.useState)(1);
  const handleZoomOut = (0, import_react.useCallback)(
    (easing) => {
      if (zoom < minZoom) {
        return;
      }
      playground.config.zoomout(easing);
    },
    [zoom, playground, minZoom]
  );
  const handleZoomIn = (0, import_react.useCallback)(
    (easing) => {
      if (zoom > maxZoom) {
        return;
      }
      playground.config.zoomin(easing);
    },
    [zoom, playground, maxZoom]
  );
  const handleUpdateZoom = (0, import_react.useCallback)(
    (value, easing, easingDuration) => {
      playground.config.updateZoom(value, easing, easingDuration);
    },
    [playground]
  );
  const handleToggleIneractiveType = (0, import_react.useCallback)(() => {
    if (editorState.isMouseFriendlyMode()) {
      editorState.changeState(import_core.EditorState.STATE_SELECT.id);
    } else {
      editorState.changeState(import_core.EditorState.STATE_MOUSE_FRIENDLY_SELECT.id);
    }
  }, [editorState]);
  (0, import_react.useEffect)(() => {
    const dispose = new import_utils.DisposableCollection();
    dispose.push(playground.onZoom((z) => setZoom(z)));
    return () => dispose.dispose();
  }, [playground]);
  return {
    zoomin: handleZoomIn,
    zoomout: handleZoomOut,
    updateZoom: handleUpdateZoom,
    zoom,
    interactiveType: editorState.isMouseFriendlyMode() ? "MOUSE" : "PAD",
    toggleIneractiveType: handleToggleIneractiveType
  };
}

// src/components/playground-react.tsx
var import_react3 = __toESM(require("react"));
var import_core4 = require("@flowgram.ai/core");

// src/preset/playground-react-preset.ts
var import_shortcuts_plugin = require("@flowgram.ai/shortcuts-plugin");
var import_core2 = require("@flowgram.ai/core");
var import_background_plugin = require("@flowgram.ai/background-plugin");
function createPlaygroundReactPreset(opts, plugins = []) {
  return (ctx) => {
    plugins = plugins.slice();
    if (opts.background || opts.background === void 0) {
      plugins.push((0, import_background_plugin.createBackgroundPlugin)(opts.background || {}));
    }
    if (opts.shortcuts) {
      plugins.push(
        (0, import_shortcuts_plugin.createShortcutsPlugin)({
          registerShortcuts: (registry) => opts.shortcuts(registry, ctx)
        })
      );
    }
    if (opts.plugins) {
      plugins.push(...opts.plugins(ctx));
    }
    plugins.push(
      (0, import_core2.createPlaygroundPlugin)({
        onBind: (bindConfig) => {
          opts.onBind?.(bindConfig);
        },
        onInit: (ctx2) => {
          const playgroundConfig = ctx2.get(import_core2.PlaygroundConfig);
          if (opts.playground) {
            if (opts.playground.autoFocus !== void 0) {
              playgroundConfig.autoFocus = opts.playground.autoFocus;
            }
            if (opts.playground.autoResize !== void 0) {
              playgroundConfig.autoResize = opts.playground.autoResize;
            }
          }
          playgroundConfig.autoFocus = false;
          ctx2.playground.registerLayer(import_core2.PlaygroundLayer, opts.playground);
          if (opts.layers) {
            ctx2.playground.registerLayers(...opts.layers);
          }
          if (opts.onInit) opts.onInit(ctx2);
        },
        onReady(ctx2) {
          if (opts.onReady) opts.onReady(ctx2);
        },
        onAllLayersRendered() {
          if (opts.onAllLayersRendered) opts.onAllLayersRendered(ctx);
        },
        onDispose() {
          if (opts.onDispose) opts.onDispose(ctx);
        },
        containerModules: opts.containerModules || []
      })
    );
    return plugins;
  };
}

// src/layers/playground-content-layer.tsx
var import_react2 = __toESM(require("react"));
var import_inversify = require("inversify");
var import_core3 = require("@flowgram.ai/core");
var import_utils2 = require("@flowgram.ai/utils");
var PlaygroundContentLayer = class extends import_core3.Layer {
  constructor() {
    super(...arguments);
    this.node = import_utils2.domUtils.createDivWithClass(
      "gedit-playground-layer gedit-playground-content-layer"
    );
  }
  onZoom(scale) {
    this.node.style.transform = `scale(${scale})`;
  }
  onReady() {
    this.node.style.left = "0px";
    this.node.style.top = "0px";
  }
  updateOptions(opts) {
    this.options = opts;
    this.render();
  }
  render() {
    return /* @__PURE__ */ import_react2.default.createElement(
      "div",
      {
        className: this.options.className,
        style: { position: "absolute", ...this.options.style }
      },
      this.options.children
    );
  }
};
PlaygroundContentLayer.type = "PlaygroundContentLayer";
PlaygroundContentLayer = __decorateClass([
  (0, import_inversify.injectable)()
], PlaygroundContentLayer);

// src/components/playground-react.tsx
var PlaygroundReact = (0, import_react3.forwardRef)(
  function PlaygroundReact2(props, ref) {
    const { parentContainer, children, ...others } = props;
    const contentLoadPlugin = (0, import_react3.useMemo)(
      () => (0, import_core4.createPlaygroundPlugin)({
        onInit(ctx) {
          ctx.playground.registerLayer(PlaygroundContentLayer);
        }
      }),
      []
    );
    const preset = (0, import_react3.useMemo)(() => createPlaygroundReactPreset(others, [contentLoadPlugin]), []);
    return /* @__PURE__ */ import_react3.default.createElement(import_core4.PlaygroundReactProvider, { ref, plugins: preset, parentContainer }, /* @__PURE__ */ import_react3.default.createElement(import_core4.PlaygroundReactRenderer, null, children));
  }
);

// src/components/playground-react-content.tsx
var import_react4 = __toESM(require("react"));
var import_core5 = require("@flowgram.ai/core");
var PlaygroundReactContent = (props) => {
  const playground = (0, import_core5.usePlayground)();
  (0, import_react4.useMemo)(() => {
    const layer = playground.getLayer(PlaygroundContentLayer);
    layer.updateOptions(props);
  }, [props]);
  return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Disposable,
  Emitter,
  Event,
  PlaygroundReact,
  PlaygroundReactContent,
  createPlaygroundReactPreset,
  usePlaygroundTools,
  useRefresh,
  ...require("@flowgram.ai/core")
});
//# sourceMappingURL=index.js.map