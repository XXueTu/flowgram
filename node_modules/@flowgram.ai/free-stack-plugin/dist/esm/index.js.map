{"version":3,"sources":["../../src/create-free-stack-plugin.ts","../../src/manager.ts","../../src/stacking-computing.ts","../../src/constant.ts","../../src/layers-computing.ts"],"sourcesContent":["import { definePluginCreator } from '@flowgram.ai/core';\n\nimport { StackingContextManager } from './manager';\n\nexport const createFreeStackPlugin = definePluginCreator({\n  onBind({ bind }) {\n    bind(StackingContextManager).toSelf().inSingletonScope();\n  },\n  onInit(ctx) {\n    const stackingContextManager = ctx.get<StackingContextManager>(StackingContextManager);\n    stackingContextManager.init();\n  },\n  onReady(ctx) {\n    const stackingContextManager = ctx.get<StackingContextManager>(StackingContextManager);\n    stackingContextManager.ready();\n  },\n  onDispose(ctx) {\n    const stackingContextManager = ctx.get<StackingContextManager>(StackingContextManager);\n    stackingContextManager.dispose();\n  },\n});\n","import { debounce } from 'lodash';\nimport { inject, injectable } from 'inversify';\nimport { domUtils } from '@flowgram.ai/utils';\nimport { Disposable } from '@flowgram.ai/utils';\nimport {\n  WorkflowHoverService,\n  WorkflowNodeEntity,\n  WorkflowSelectService,\n} from '@flowgram.ai/free-layout-core';\nimport { WorkflowLineEntity } from '@flowgram.ai/free-layout-core';\nimport { WorkflowDocument } from '@flowgram.ai/free-layout-core';\nimport { FlowNodeRenderData } from '@flowgram.ai/document';\nimport { EntityManager, PipelineRegistry, PipelineRenderer } from '@flowgram.ai/core';\n\nimport type { StackingContext } from './type';\nimport { StackingComputing } from './stacking-computing';\nimport { StackingConfig } from './constant';\n\n@injectable()\nexport class StackingContextManager {\n  @inject(WorkflowDocument) private readonly document: WorkflowDocument;\n\n  @inject(EntityManager) private readonly entityManager: EntityManager;\n\n  @inject(PipelineRenderer)\n  private readonly pipelineRenderer: PipelineRenderer;\n\n  @inject(PipelineRegistry)\n  private readonly pipelineRegistry: PipelineRegistry;\n\n  @inject(WorkflowHoverService)\n  private readonly hoverService: WorkflowHoverService;\n\n  @inject(WorkflowSelectService)\n  private readonly selectService: WorkflowSelectService;\n\n  public readonly node = domUtils.createDivWithClass(\n    'gedit-playground-layer gedit-flow-render-layer'\n  );\n\n  private disposers: Disposable[] = [];\n\n  constructor() {}\n\n  public init(): void {\n    this.pipelineRenderer.node.appendChild(this.node);\n    this.mountListener();\n  }\n\n  public ready(): void {\n    this.compute();\n  }\n\n  public dispose(): void {\n    this.disposers.forEach((disposer) => disposer.dispose());\n  }\n\n  /**\n   * 触发计算\n   * 10ms内仅计算一次\n   */\n  private compute = debounce(this._compute, 10);\n\n  private _compute(): void {\n    const context = this.context;\n    const stackingComputing = new StackingComputing();\n    const { nodeLevel, lineLevel } = stackingComputing.compute({\n      root: this.document.root,\n      nodes: this.nodes,\n      context,\n    });\n    this.nodes.forEach((node) => {\n      const level = nodeLevel.get(node.id);\n      const nodeRenderData = node.getData<FlowNodeRenderData>(FlowNodeRenderData);\n      const element = nodeRenderData.node;\n      element.style.position = 'absolute';\n      if (level === undefined) {\n        element.style.zIndex = 'auto';\n        nodeRenderData.stackIndex = 0;\n        return;\n      }\n      const stackIndex = StackingConfig.startIndex + level;\n      element.style.zIndex = String(stackIndex);\n      nodeRenderData.stackIndex = stackIndex;\n    });\n    this.lines.forEach((line) => {\n      const level = lineLevel.get(line.id);\n      const element = line.node;\n      element.style.position = 'absolute';\n      if (level === undefined) {\n        element.style.zIndex = 'auto';\n        return;\n      }\n      element.style.zIndex = String(StackingConfig.startIndex + level);\n    });\n  }\n\n  private get nodes(): WorkflowNodeEntity[] {\n    return this.entityManager.getEntities<WorkflowNodeEntity>(WorkflowNodeEntity);\n  }\n\n  private get lines(): WorkflowLineEntity[] {\n    return this.entityManager.getEntities<WorkflowLineEntity>(WorkflowLineEntity);\n  }\n\n  private get context(): StackingContext {\n    return {\n      hoveredEntity: this.hoverService.hoveredNode,\n      hoveredEntityID: this.hoverService.hoveredNode?.id,\n      selectedEntities: this.selectService.selection,\n      selectedIDs: this.selectService.selection.map((entity) => entity.id),\n    };\n  }\n\n  private mountListener(): void {\n    const entityChangeDisposer = this.onEntityChange();\n    const zoomDisposer = this.onZoom();\n    const hoverDisposer = this.onHover();\n    const selectDisposer = this.onSelect();\n    this.disposers = [entityChangeDisposer, zoomDisposer, hoverDisposer, selectDisposer];\n  }\n\n  private onZoom(): Disposable {\n    return this.pipelineRegistry.onZoom((scale: number) => {\n      this.node.style.transform = `scale(${scale})`;\n    });\n  }\n\n  private onHover(): Disposable {\n    return this.hoverService.onHoveredChange(() => {\n      this.compute();\n    });\n  }\n\n  private onEntityChange(): Disposable {\n    return this.entityManager.onEntityChange(() => {\n      this.compute();\n    });\n  }\n\n  private onSelect(): Disposable {\n    return this.selectService.onSelectionChanged(() => {\n      this.compute();\n    });\n  }\n}\n","import {\n  WorkflowLineEntity,\n  WorkflowNodeEntity,\n  WorkflowNodeLinesData,\n} from '@flowgram.ai/free-layout-core';\nimport { FlowNodeBaseType } from '@flowgram.ai/document';\n\nimport type { StackingContext } from './type';\n\nexport class StackingComputing {\n  private currentLevel: number;\n\n  private topLevel: number;\n\n  private maxLevel: number;\n\n  private nodeIndexes: Map<string, number>;\n\n  private nodeLevel: Map<string, number>;\n\n  private lineLevel: Map<string, number>;\n\n  private context: StackingContext;\n\n  public compute(params: {\n    root: WorkflowNodeEntity;\n    nodes: WorkflowNodeEntity[];\n    context: StackingContext;\n  }): {\n    /** 节点层级 */\n    nodeLevel: Map<string, number>;\n    /** 线条层级 */\n    lineLevel: Map<string, number>;\n    /** 正常渲染的最高层级 */\n    topLevel: number;\n    /** 选中计算叠加后可能计算出的最高层级 */\n    maxLevel: number;\n  } {\n    this.clearCache();\n    const { root, nodes, context } = params;\n    this.context = context;\n    this.nodeIndexes = this.computeNodeIndexesMap(nodes);\n    this.topLevel = this.computeTopLevel(nodes);\n    this.maxLevel = this.topLevel * 2;\n    this.layerHandler(root.blocks);\n    return {\n      nodeLevel: this.nodeLevel,\n      lineLevel: this.lineLevel,\n      topLevel: this.topLevel,\n      maxLevel: this.maxLevel,\n    };\n  }\n\n  private clearCache(): void {\n    this.currentLevel = 0;\n    this.topLevel = 0;\n    this.maxLevel = 0;\n    this.nodeIndexes = new Map();\n    this.nodeLevel = new Map();\n    this.lineLevel = new Map();\n  }\n\n  private computeNodeIndexesMap(nodes: WorkflowNodeEntity[]): Map<string, number> {\n    const nodeIndexMap = new Map<string, number>();\n    nodes.forEach((node, index) => {\n      nodeIndexMap.set(node.id, index);\n    });\n    return nodeIndexMap;\n  }\n\n  private computeTopLevel(nodes: WorkflowNodeEntity[]): number {\n    const nodesWithoutRoot = nodes.filter((node) => node.id !== FlowNodeBaseType.ROOT);\n    const nodeHasChildren = nodesWithoutRoot.reduce((count, node) => {\n      if (node.blocks.length > 0) {\n        return count + 1;\n      } else {\n        return count;\n      }\n    }, 0);\n    // 最高层数 = 节点个数 + 容器节点个数（线条单独占一层） + 抬高一层\n    return nodesWithoutRoot.length + nodeHasChildren + 1;\n  }\n\n  private layerHandler(layerNodes: WorkflowNodeEntity[], pinTop: boolean = false): void {\n    const nodes = this.sortNodes(layerNodes);\n    const lines = this.getNodesAllLines(nodes);\n\n    // 线条统一设为当前层级最低\n    lines.forEach((line) => {\n      if (\n        line.isDrawing || // 正在绘制\n        this.context.hoveredEntityID === line.id || // hover\n        this.context.selectedIDs.includes(line.id) // 选中\n      ) {\n        // 线条置顶条件：正在绘制 / hover / 选中\n        this.lineLevel.set(line.id, this.maxLevel);\n      } else {\n        this.lineLevel.set(line.id, this.getLevel(pinTop));\n      }\n    });\n    this.levelIncrease();\n    nodes.forEach((node) => {\n      const selected = this.context.selectedIDs.includes(node.id);\n      if (selected) {\n        // 节点置顶条件：选中\n        this.nodeLevel.set(node.id, this.topLevel);\n      } else {\n        this.nodeLevel.set(node.id, this.getLevel(pinTop));\n      }\n      // 节点层级逐层增高\n      this.levelIncrease();\n      if (node.blocks.length > 0) {\n        // 子节点层级需低于后续兄弟节点，因此需要先进行计算\n        this.layerHandler(node.blocks, pinTop || selected);\n      }\n    });\n  }\n\n  private sortNodes(nodes: WorkflowNodeEntity[]): WorkflowNodeEntity[] {\n    return nodes.sort((a, b) => {\n      const aIndex = this.nodeIndexes.get(a.id);\n      const bIndex = this.nodeIndexes.get(b.id);\n      if (aIndex === undefined || bIndex === undefined) {\n        return 0;\n      }\n      return aIndex - bIndex;\n    });\n  }\n\n  private getNodesAllLines(nodes: WorkflowNodeEntity[]): WorkflowLineEntity[] {\n    const lines = nodes\n      .map((node) => {\n        const linesData = node.getData<WorkflowNodeLinesData>(WorkflowNodeLinesData);\n        const outputLines = linesData.outputLines.filter(Boolean);\n        const inputLines = linesData.inputLines.filter(Boolean);\n        return [...outputLines, ...inputLines];\n      })\n      .flat();\n\n    // 过滤出未计算层级的线条，以及高度优先（需要覆盖计算）的线条\n    const filteredLines = lines.filter(\n      (line) => this.lineLevel.get(line.id) === undefined || this.isHigherFirstLine(line)\n    );\n\n    return filteredLines;\n  }\n\n  private isHigherFirstLine(line: WorkflowLineEntity): boolean {\n    // 父子相连的线条，需要作为高度优先的线条，避免线条不可见\n    return line.to?.parent === line.from || line.from?.parent === line.to;\n  }\n\n  private getLevel(pinTop: boolean): number {\n    if (pinTop) {\n      return this.topLevel + this.currentLevel;\n    }\n    return this.currentLevel;\n  }\n\n  private levelIncrease(): void {\n    this.currentLevel += 1;\n  }\n}\n","export enum StackingItem {\n  Line = 'line',\n  Node = 'node',\n}\n\nexport enum StackingType {\n  Line = StackingItem.Line,\n  Node = StackingItem.Node,\n}\n\nexport const StackingBaseIndex: Record<StackingType, number> = {\n  [StackingType.Line]: 0,\n  [StackingType.Node]: 1,\n};\n\n// 常量\nconst startIndex = 8;\nconst allowLevel = 2;\n\n// 计算值\nconst levelIndexStep = Object.keys(StackingType).length;\nconst maxLevel = allowLevel * 2;\nconst maxIndex = startIndex + maxLevel * levelIndexStep;\n\nexport const StackingConfig = {\n  /** index 起始值 */\n  startIndex,\n  /** 允许存在的层级 */\n  allowLevel,\n  /** 每层 index 跨度 */\n  levelIndexStep,\n  /** 叠加计算后出现的最深层级 */\n  maxLevel,\n  /** 最大 index */\n  maxIndex,\n};\n","import type { WorkflowNodeEntity } from '@flowgram.ai/free-layout-core';\nimport type { WorkflowLineEntity } from '@flowgram.ai/free-layout-core';\nimport { FlowNodeRenderData } from '@flowgram.ai/document';\n\nimport type { StackingContext } from './type';\nimport { StackingBaseIndex, StackingConfig, StackingType } from './constant';\n\nnamespace NodeComputing {\n  export const compute = (node: WorkflowNodeEntity, context: StackingContext): void => {\n    const zIndex = nodeZIndex(node, context);\n    const element = nodeElement(node);\n    element.style.position = 'absolute';\n    element.style.zIndex = zIndexStringify(zIndex);\n  };\n\n  export const stackingIndex = (stackingType: StackingType, level: number): number | undefined => {\n    if (level < 1) {\n      // root节点\n      return undefined;\n    }\n    const baseZIndex = StackingBaseIndex[stackingType];\n    const zIndex =\n      StackingConfig.startIndex + StackingConfig.levelIndexStep * (level - 1) + baseZIndex;\n    return zIndex;\n  };\n\n  export const nodeStackingLevel = (\n    node: WorkflowNodeEntity,\n    context: StackingContext,\n    disableTopLevel = false\n  ): number => {\n    // TODO 后续支持多层级时这个计算逻辑应该去掉，level信息应该直接由 FlowNodeEntity 缓存给出\n    // 多层时这里的计算会有 O(logN) 时间复杂度，并且在多层级联同计算时会有BUG，本次需求不处理这种情况\n    const unReversedLinage: WorkflowNodeEntity[] = [];\n    let currentNode: WorkflowNodeEntity | undefined = node;\n    while (currentNode) {\n      unReversedLinage.push(currentNode);\n      currentNode = currentNode.parent;\n    }\n    const linage = unReversedLinage.reverse();\n    const nodeLevel = linage.length - 1;\n\n    const topLevelIndex = linage.findIndex((node: WorkflowNodeEntity) => {\n      if (context.selectedIDs.includes(node.id)) {\n        // 存在被选中的父级或自身被选中，直接置顶\n        return true;\n      }\n      return false;\n    });\n    const topLevel = StackingConfig.allowLevel + (linage.length - topLevelIndex);\n\n    if (!disableTopLevel && topLevelIndex !== -1) {\n      // 置顶\n      return topLevel;\n    }\n\n    return nodeLevel;\n  };\n\n  export const zIndexStringify = (zIndex?: number): string => {\n    if (zIndex === undefined) {\n      return 'auto';\n    }\n    return zIndex.toString();\n  };\n\n  const nodeZIndex = (node: WorkflowNodeEntity, context: StackingContext): number | undefined => {\n    const level = nodeStackingLevel(node, context);\n    const zIndex = stackingIndex(StackingType.Node, level);\n    return zIndex;\n  };\n\n  const nodeElement = (node: WorkflowNodeEntity): HTMLDivElement => {\n    const nodeRenderData = node.getData<FlowNodeRenderData>(FlowNodeRenderData);\n    return nodeRenderData.node;\n  };\n}\n\nnamespace LineComputing {\n  export const compute = (line: WorkflowLineEntity, context: StackingContext): void => {\n    const zIndex = lineZIndex(line, context);\n    const element = line.node;\n    element.style.position = 'absolute';\n    element.style.zIndex = NodeComputing.zIndexStringify(zIndex);\n  };\n\n  const lineStackingLevel = (line: WorkflowLineEntity, context: StackingContext): number => {\n    if (\n      line.isDrawing || // 正在绘制\n      context.hoveredEntityID === line.id || // hover\n      context.selectedIDs.includes(line.id) // 选中\n    ) {\n      // 线条置顶条件：正在绘制 / hover / 选中\n      return StackingConfig.maxLevel + 1;\n    }\n    const fromLevel = NodeComputing.nodeStackingLevel(line.from, context, true);\n    if (!line.to) {\n      // 还处于连线中\n      return fromLevel;\n    }\n    const toLevel = NodeComputing.nodeStackingLevel(line.to, context, true);\n    const level = Math.min(fromLevel, toLevel);\n    return level;\n  };\n\n  const lineZIndex = (line: WorkflowLineEntity, context: StackingContext): number | undefined => {\n    const level = lineStackingLevel(line, context);\n    const zIndex = NodeComputing.stackingIndex(StackingType.Line, level);\n    return zIndex;\n  };\n}\n\nexport const layersComputing = (params: {\n  nodes: WorkflowNodeEntity[];\n  lines: WorkflowLineEntity[];\n  context: StackingContext;\n}) => {\n  const { nodes, lines, context } = params;\n  nodes.forEach((node) => {\n    NodeComputing.compute(node, context);\n  });\n  lines.forEach((line) => {\n    LineComputing.compute(line, context);\n  });\n};\n"],"mappings":"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","names":["WorkflowNodeEntity","WorkflowLineEntity","StackingItem","StackingType","WorkflowNodeEntity","WorkflowLineEntity","FlowNodeRenderData","NodeComputing","node","FlowNodeRenderData","LineComputing"]}