"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  StackingBaseIndex: () => StackingBaseIndex,
  StackingComputing: () => StackingComputing,
  StackingConfig: () => StackingConfig,
  StackingContextManager: () => StackingContextManager,
  StackingItem: () => StackingItem,
  StackingType: () => StackingType,
  createFreeStackPlugin: () => createFreeStackPlugin,
  layersComputing: () => layersComputing
});
module.exports = __toCommonJS(src_exports);

// src/create-free-stack-plugin.ts
var import_core2 = require("@flowgram.ai/core");

// src/manager.ts
var import_lodash = require("lodash");
var import_inversify = require("inversify");
var import_utils = require("@flowgram.ai/utils");
var import_free_layout_core2 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core3 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core4 = require("@flowgram.ai/free-layout-core");
var import_document2 = require("@flowgram.ai/document");
var import_core = require("@flowgram.ai/core");

// src/stacking-computing.ts
var import_free_layout_core = require("@flowgram.ai/free-layout-core");
var import_document = require("@flowgram.ai/document");
var StackingComputing = class {
  compute(params) {
    this.clearCache();
    const { root, nodes, context } = params;
    this.context = context;
    this.nodeIndexes = this.computeNodeIndexesMap(nodes);
    this.topLevel = this.computeTopLevel(nodes);
    this.maxLevel = this.topLevel * 2;
    this.layerHandler(root.blocks);
    return {
      nodeLevel: this.nodeLevel,
      lineLevel: this.lineLevel,
      topLevel: this.topLevel,
      maxLevel: this.maxLevel
    };
  }
  clearCache() {
    this.currentLevel = 0;
    this.topLevel = 0;
    this.maxLevel = 0;
    this.nodeIndexes = /* @__PURE__ */ new Map();
    this.nodeLevel = /* @__PURE__ */ new Map();
    this.lineLevel = /* @__PURE__ */ new Map();
  }
  computeNodeIndexesMap(nodes) {
    const nodeIndexMap = /* @__PURE__ */ new Map();
    nodes.forEach((node, index) => {
      nodeIndexMap.set(node.id, index);
    });
    return nodeIndexMap;
  }
  computeTopLevel(nodes) {
    const nodesWithoutRoot = nodes.filter((node) => node.id !== import_document.FlowNodeBaseType.ROOT);
    const nodeHasChildren = nodesWithoutRoot.reduce((count, node) => {
      if (node.blocks.length > 0) {
        return count + 1;
      } else {
        return count;
      }
    }, 0);
    return nodesWithoutRoot.length + nodeHasChildren + 1;
  }
  layerHandler(layerNodes, pinTop = false) {
    const nodes = this.sortNodes(layerNodes);
    const lines = this.getNodesAllLines(nodes);
    lines.forEach((line) => {
      if (line.isDrawing || // 正在绘制
      this.context.hoveredEntityID === line.id || // hover
      this.context.selectedIDs.includes(line.id)) {
        this.lineLevel.set(line.id, this.maxLevel);
      } else {
        this.lineLevel.set(line.id, this.getLevel(pinTop));
      }
    });
    this.levelIncrease();
    nodes.forEach((node) => {
      const selected = this.context.selectedIDs.includes(node.id);
      if (selected) {
        this.nodeLevel.set(node.id, this.topLevel);
      } else {
        this.nodeLevel.set(node.id, this.getLevel(pinTop));
      }
      this.levelIncrease();
      if (node.blocks.length > 0) {
        this.layerHandler(node.blocks, pinTop || selected);
      }
    });
  }
  sortNodes(nodes) {
    return nodes.sort((a, b) => {
      const aIndex = this.nodeIndexes.get(a.id);
      const bIndex = this.nodeIndexes.get(b.id);
      if (aIndex === void 0 || bIndex === void 0) {
        return 0;
      }
      return aIndex - bIndex;
    });
  }
  getNodesAllLines(nodes) {
    const lines = nodes.map((node) => {
      const linesData = node.getData(import_free_layout_core.WorkflowNodeLinesData);
      const outputLines = linesData.outputLines.filter(Boolean);
      const inputLines = linesData.inputLines.filter(Boolean);
      return [...outputLines, ...inputLines];
    }).flat();
    const filteredLines = lines.filter(
      (line) => this.lineLevel.get(line.id) === void 0 || this.isHigherFirstLine(line)
    );
    return filteredLines;
  }
  isHigherFirstLine(line) {
    return line.to?.parent === line.from || line.from?.parent === line.to;
  }
  getLevel(pinTop) {
    if (pinTop) {
      return this.topLevel + this.currentLevel;
    }
    return this.currentLevel;
  }
  levelIncrease() {
    this.currentLevel += 1;
  }
};

// src/constant.ts
var StackingItem = /* @__PURE__ */ ((StackingItem2) => {
  StackingItem2["Line"] = "line";
  StackingItem2["Node"] = "node";
  return StackingItem2;
})(StackingItem || {});
var StackingType = /* @__PURE__ */ ((StackingType2) => {
  StackingType2["Line"] = "line" /* Line */;
  StackingType2["Node"] = "node" /* Node */;
  return StackingType2;
})(StackingType || {});
var StackingBaseIndex = {
  ["line" /* Line */]: 0,
  ["node" /* Node */]: 1
};
var startIndex = 8;
var allowLevel = 2;
var levelIndexStep = Object.keys(StackingType).length;
var maxLevel = allowLevel * 2;
var maxIndex = startIndex + maxLevel * levelIndexStep;
var StackingConfig = {
  /** index 起始值 */
  startIndex,
  /** 允许存在的层级 */
  allowLevel,
  /** 每层 index 跨度 */
  levelIndexStep,
  /** 叠加计算后出现的最深层级 */
  maxLevel,
  /** 最大 index */
  maxIndex
};

// src/manager.ts
var StackingContextManager = class {
  constructor() {
    this.node = import_utils.domUtils.createDivWithClass(
      "gedit-playground-layer gedit-flow-render-layer"
    );
    this.disposers = [];
    /**
     * 触发计算
     * 10ms内仅计算一次
     */
    this.compute = (0, import_lodash.debounce)(this._compute, 10);
  }
  init() {
    this.pipelineRenderer.node.appendChild(this.node);
    this.mountListener();
  }
  ready() {
    this.compute();
  }
  dispose() {
    this.disposers.forEach((disposer) => disposer.dispose());
  }
  _compute() {
    const context = this.context;
    const stackingComputing = new StackingComputing();
    const { nodeLevel, lineLevel } = stackingComputing.compute({
      root: this.document.root,
      nodes: this.nodes,
      context
    });
    this.nodes.forEach((node) => {
      const level = nodeLevel.get(node.id);
      const nodeRenderData = node.getData(import_document2.FlowNodeRenderData);
      const element = nodeRenderData.node;
      element.style.position = "absolute";
      if (level === void 0) {
        element.style.zIndex = "auto";
        nodeRenderData.stackIndex = 0;
        return;
      }
      const stackIndex = StackingConfig.startIndex + level;
      element.style.zIndex = String(stackIndex);
      nodeRenderData.stackIndex = stackIndex;
    });
    this.lines.forEach((line) => {
      const level = lineLevel.get(line.id);
      const element = line.node;
      element.style.position = "absolute";
      if (level === void 0) {
        element.style.zIndex = "auto";
        return;
      }
      element.style.zIndex = String(StackingConfig.startIndex + level);
    });
  }
  get nodes() {
    return this.entityManager.getEntities(import_free_layout_core2.WorkflowNodeEntity);
  }
  get lines() {
    return this.entityManager.getEntities(import_free_layout_core3.WorkflowLineEntity);
  }
  get context() {
    return {
      hoveredEntity: this.hoverService.hoveredNode,
      hoveredEntityID: this.hoverService.hoveredNode?.id,
      selectedEntities: this.selectService.selection,
      selectedIDs: this.selectService.selection.map((entity) => entity.id)
    };
  }
  mountListener() {
    const entityChangeDisposer = this.onEntityChange();
    const zoomDisposer = this.onZoom();
    const hoverDisposer = this.onHover();
    const selectDisposer = this.onSelect();
    this.disposers = [entityChangeDisposer, zoomDisposer, hoverDisposer, selectDisposer];
  }
  onZoom() {
    return this.pipelineRegistry.onZoom((scale) => {
      this.node.style.transform = `scale(${scale})`;
    });
  }
  onHover() {
    return this.hoverService.onHoveredChange(() => {
      this.compute();
    });
  }
  onEntityChange() {
    return this.entityManager.onEntityChange(() => {
      this.compute();
    });
  }
  onSelect() {
    return this.selectService.onSelectionChanged(() => {
      this.compute();
    });
  }
};
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core4.WorkflowDocument)
], StackingContextManager.prototype, "document", 2);
__decorateClass([
  (0, import_inversify.inject)(import_core.EntityManager)
], StackingContextManager.prototype, "entityManager", 2);
__decorateClass([
  (0, import_inversify.inject)(import_core.PipelineRenderer)
], StackingContextManager.prototype, "pipelineRenderer", 2);
__decorateClass([
  (0, import_inversify.inject)(import_core.PipelineRegistry)
], StackingContextManager.prototype, "pipelineRegistry", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowHoverService)
], StackingContextManager.prototype, "hoverService", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowSelectService)
], StackingContextManager.prototype, "selectService", 2);
StackingContextManager = __decorateClass([
  (0, import_inversify.injectable)()
], StackingContextManager);

// src/create-free-stack-plugin.ts
var createFreeStackPlugin = (0, import_core2.definePluginCreator)({
  onBind({ bind }) {
    bind(StackingContextManager).toSelf().inSingletonScope();
  },
  onInit(ctx) {
    const stackingContextManager = ctx.get(StackingContextManager);
    stackingContextManager.init();
  },
  onReady(ctx) {
    const stackingContextManager = ctx.get(StackingContextManager);
    stackingContextManager.ready();
  },
  onDispose(ctx) {
    const stackingContextManager = ctx.get(StackingContextManager);
    stackingContextManager.dispose();
  }
});

// src/layers-computing.ts
var import_document3 = require("@flowgram.ai/document");
var NodeComputing;
((NodeComputing2) => {
  NodeComputing2.compute = (node, context) => {
    const zIndex = nodeZIndex(node, context);
    const element = nodeElement(node);
    element.style.position = "absolute";
    element.style.zIndex = (0, NodeComputing2.zIndexStringify)(zIndex);
  };
  NodeComputing2.stackingIndex = (stackingType, level) => {
    if (level < 1) {
      return void 0;
    }
    const baseZIndex = StackingBaseIndex[stackingType];
    const zIndex = StackingConfig.startIndex + StackingConfig.levelIndexStep * (level - 1) + baseZIndex;
    return zIndex;
  };
  NodeComputing2.nodeStackingLevel = (node, context, disableTopLevel = false) => {
    const unReversedLinage = [];
    let currentNode = node;
    while (currentNode) {
      unReversedLinage.push(currentNode);
      currentNode = currentNode.parent;
    }
    const linage = unReversedLinage.reverse();
    const nodeLevel = linage.length - 1;
    const topLevelIndex = linage.findIndex((node2) => {
      if (context.selectedIDs.includes(node2.id)) {
        return true;
      }
      return false;
    });
    const topLevel = StackingConfig.allowLevel + (linage.length - topLevelIndex);
    if (!disableTopLevel && topLevelIndex !== -1) {
      return topLevel;
    }
    return nodeLevel;
  };
  NodeComputing2.zIndexStringify = (zIndex) => {
    if (zIndex === void 0) {
      return "auto";
    }
    return zIndex.toString();
  };
  const nodeZIndex = (node, context) => {
    const level = (0, NodeComputing2.nodeStackingLevel)(node, context);
    const zIndex = (0, NodeComputing2.stackingIndex)("node" /* Node */, level);
    return zIndex;
  };
  const nodeElement = (node) => {
    const nodeRenderData = node.getData(import_document3.FlowNodeRenderData);
    return nodeRenderData.node;
  };
})(NodeComputing || (NodeComputing = {}));
var LineComputing;
((LineComputing2) => {
  LineComputing2.compute = (line, context) => {
    const zIndex = lineZIndex(line, context);
    const element = line.node;
    element.style.position = "absolute";
    element.style.zIndex = NodeComputing.zIndexStringify(zIndex);
  };
  const lineStackingLevel = (line, context) => {
    if (line.isDrawing || // 正在绘制
    context.hoveredEntityID === line.id || // hover
    context.selectedIDs.includes(line.id)) {
      return StackingConfig.maxLevel + 1;
    }
    const fromLevel = NodeComputing.nodeStackingLevel(line.from, context, true);
    if (!line.to) {
      return fromLevel;
    }
    const toLevel = NodeComputing.nodeStackingLevel(line.to, context, true);
    const level = Math.min(fromLevel, toLevel);
    return level;
  };
  const lineZIndex = (line, context) => {
    const level = lineStackingLevel(line, context);
    const zIndex = NodeComputing.stackingIndex("line" /* Line */, level);
    return zIndex;
  };
})(LineComputing || (LineComputing = {}));
var layersComputing = (params) => {
  const { nodes, lines, context } = params;
  nodes.forEach((node) => {
    NodeComputing.compute(node, context);
  });
  lines.forEach((line) => {
    LineComputing.compute(line, context);
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  StackingBaseIndex,
  StackingComputing,
  StackingConfig,
  StackingContextManager,
  StackingItem,
  StackingType,
  createFreeStackPlugin,
  layersComputing
});
//# sourceMappingURL=index.js.map