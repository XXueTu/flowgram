var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FreeLayoutEditor: () => FreeLayoutEditor,
  FreeLayoutEditorProvider: () => FreeLayoutEditorProvider,
  FreeLayoutPluginContext: () => FreeLayoutPluginContext,
  FreeLayoutProps: () => FreeLayoutProps,
  WorkflowNodeRenderer: () => WorkflowNodeRenderer,
  WorkflowPortRender: () => WorkflowPortRender2,
  createFreeLayoutPreset: () => createFreeLayoutPreset,
  useAutoLayout: () => useAutoLayout,
  useClientContext: () => useClientContext,
  usePlaygroundTools: () => usePlaygroundTools
});
import "reflect-metadata";
export * from "@flowgram.ai/editor";
export * from "@flowgram.ai/free-layout-core";

// src/components/index.ts
var components_exports = {};
__export(components_exports, {
  FreeLayoutEditor: () => FreeLayoutEditor,
  FreeLayoutEditorProvider: () => FreeLayoutEditorProvider,
  WorkflowNodeRenderer: () => WorkflowNodeRenderer,
  WorkflowPortRender: () => WorkflowPortRender2
});

// src/components/free-layout-editor-provider.tsx
import React, { useMemo, useCallback, forwardRef } from "react";
import { WorkflowDocument as WorkflowDocument2 } from "@flowgram.ai/free-layout-core";
import { HistoryService as HistoryService2 } from "@flowgram.ai/free-history-plugin";
import {
  PlaygroundReactProvider,
  createPluginContextDefault,
  ClipboardService as ClipboardService2,
  SelectionService as SelectionService3
} from "@flowgram.ai/editor";

// src/preset/free-layout-preset.ts
import { createSelectBoxPlugin } from "@flowgram.ai/select-box-plugin";
import { createFreeStackPlugin, StackingContextManager } from "@flowgram.ai/free-stack-plugin";
import { createFreeLinesPlugin } from "@flowgram.ai/free-lines-plugin";
import {
  WorkflowCommands,
  WorkflowNodeEntity,
  WorkflowLineEntity,
  WorkflowDocumentContainerModule,
  WorkflowHoverService,
  WorkflowDocumentOptions,
  WorkflowDocumentOptionsDefault as WorkflowDocumentOptionsDefault2
} from "@flowgram.ai/free-layout-core";
import { createFreeHoverPlugin } from "@flowgram.ai/free-hover-plugin";
import { HistoryService, createFreeHistoryPlugin } from "@flowgram.ai/free-history-plugin";
import { createFreeAutoLayoutPlugin } from "@flowgram.ai/free-auto-layout-plugin";
import {
  createDefaultPreset,
  SelectionService as SelectionService2,
  createShortcutsPlugin,
  createVariablePlugin,
  createPlaygroundPlugin,
  Command,
  FlowNodesContentLayer,
  FlowNodesTransformLayer,
  FlowScrollBarLayer,
  FlowScrollLimitLayer,
  createPlaygroundReactPreset
} from "@flowgram.ai/editor";

// src/preset/node-serialize.ts
import {
  WorkflowContentChangeType,
  WorkflowDocumentOptionsDefault
} from "@flowgram.ai/free-layout-core";
import { FlowNodeFormData } from "@flowgram.ai/editor";
function fromNodeJSON(opts, node, json, isFirstCreate) {
  json = opts.fromNodeJSON ? opts.fromNodeJSON(node, json, isFirstCreate) : json;
  const formData = node.getData(FlowNodeFormData);
  if (!formData) {
    if (json.data) {
      node.updateExtInfo(json.data);
    }
    if (isFirstCreate) {
      node.onExtInfoChange(() => {
        node.document.fireContentChange({
          type: WorkflowContentChangeType.NODE_DATA_CHANGE,
          toJSON: () => node.getExtInfo(),
          entity: node
        });
      });
    }
    return;
  }
  return WorkflowDocumentOptionsDefault.fromNodeJSON(node, json, isFirstCreate);
}
function toNodeJSON(opts, node) {
  const formData = node.getData(FlowNodeFormData);
  const position = node.transform.position;
  let json;
  if (!formData) {
    json = {
      id: node.id,
      type: node.flowNodeType,
      meta: {
        position: { x: position.x, y: position.y }
      },
      data: node.getExtInfo()
    };
  } else {
    json = WorkflowDocumentOptionsDefault.toNodeJSON(node);
  }
  return opts.toNodeJSON ? opts.toNodeJSON(node, json) : json;
}

// src/preset/free-layout-props.ts
import {
  EditorProps,
  PluginContext
} from "@flowgram.ai/editor";
var FreeLayoutPluginContext = PluginContext;
var FreeLayoutProps;
((FreeLayoutProps3) => {
  FreeLayoutProps3.DEFAULT = {
    ...EditorProps.DEFAULT
  };
})(FreeLayoutProps || (FreeLayoutProps = {}));

// src/preset/free-layout-preset.ts
var renderElement = (ctx) => {
  const stackingContextManager = ctx.get(StackingContextManager);
  if (stackingContextManager.node) {
    return stackingContextManager.node;
  }
};
function createFreeLayoutPreset(opts) {
  return (ctx) => {
    opts = {
      ...FreeLayoutProps.DEFAULT,
      ...opts,
      playground: {
        ...opts.playground,
        // 这里要把自由布局的 hoverService 注入进去
        get hoverService() {
          return ctx.get(WorkflowHoverService);
        }
      }
    };
    let plugins = [];
    plugins.push(
      createShortcutsPlugin({
        registerShortcuts(registry) {
          const selection = ctx.get(SelectionService2);
          registry.addHandlers({
            commandId: WorkflowCommands.DELETE_NODES,
            shortcuts: ["backspace", "delete"],
            isEnabled: () => selection.selection.length > 0 && !ctx.playground.config.readonlyOrDisabled,
            execute: () => {
              selection.selection.forEach((entity) => {
                if (entity instanceof WorkflowNodeEntity) {
                  if (!ctx.document.canRemove(entity)) {
                    return;
                  }
                  const nodeMeta = entity.getNodeMeta();
                  const subCanvas = nodeMeta.subCanvas?.(entity);
                  if (subCanvas?.isCanvas) {
                    subCanvas.parentNode.dispose();
                    return;
                  }
                  entity.dispose();
                } else if (entity instanceof WorkflowLineEntity) {
                  if (!ctx.document.linesManager.canRemove(entity)) {
                    return;
                  }
                  entity.dispose();
                }
              });
              selection.selection = selection.selection.filter((s) => !s.disposed);
            }
          });
          if (opts?.history?.enable) {
            const fixedHistoryService = ctx.get(HistoryService);
            if (!opts.history.disableShortcuts) {
              registry.addHandlers({
                commandId: Command.Default.UNDO,
                shortcuts: ["meta z", "ctrl z"],
                isEnabled: () => true,
                execute: () => {
                  fixedHistoryService.undo();
                }
              });
              registry.addHandlers({
                commandId: Command.Default.REDO,
                shortcuts: ["meta shift z", "ctrl shift z"],
                isEnabled: () => true,
                execute: () => {
                  fixedHistoryService.redo();
                }
              });
            }
          }
        }
      })
    );
    plugins = createDefaultPreset(opts, plugins)(ctx);
    if (opts.variableEngine?.enable) {
      plugins.push(
        createVariablePlugin({
          ...opts.variableEngine,
          layout: "free"
        })
      );
    }
    if (opts.history?.enable) {
      plugins.push(createFreeHistoryPlugin(opts.history));
    }
    plugins.push(
      createPlaygroundPlugin({
        onBind: (bindConfig) => {
          bindConfig.rebind(WorkflowDocumentOptions).toConstantValue({
            canAddLine: opts.canAddLine?.bind(null, ctx),
            canDeleteLine: opts.canDeleteLine?.bind(null, ctx),
            isErrorLine: opts.isErrorLine?.bind(null, ctx),
            isErrorPort: opts.isErrorPort?.bind(null, ctx),
            isDisabledPort: opts.isDisabledPort?.bind(null, ctx),
            isReverseLine: opts.isReverseLine?.bind(null, ctx),
            isHideArrowLine: opts.isHideArrowLine?.bind(null, ctx),
            isFlowingLine: opts.isFlowingLine?.bind(null, ctx),
            isDisabledLine: opts.isDisabledLine?.bind(null, ctx),
            isVerticalLine: opts.isVerticalLine?.bind(null, ctx),
            onDragLineEnd: opts.onDragLineEnd?.bind(null, ctx),
            setLineRenderType: opts.setLineRenderType?.bind(null, ctx),
            setLineClassName: opts.setLineClassName?.bind(null, ctx),
            canDeleteNode: opts.canDeleteNode?.bind(null, ctx),
            canResetLine: opts.canResetLine?.bind(null, ctx),
            cursors: opts.cursors ?? WorkflowDocumentOptionsDefault2.cursors,
            lineColor: opts.lineColor ?? WorkflowDocumentOptionsDefault2.lineColor,
            allNodesDefaultExpanded: opts.allNodesDefaultExpanded,
            toNodeJSON: (node) => toNodeJSON(opts, node),
            fromNodeJSON: (node, json, isFirstCreate) => fromNodeJSON(opts, node, json, isFirstCreate)
          });
        },
        onInit: (ctx2) => {
          ctx2.playground.registerLayer(FlowNodesContentLayer);
          ctx2.playground.registerLayer(FlowNodesTransformLayer, {
            renderElement: () => {
              if (typeof renderElement === "function") {
                return renderElement(ctx2);
              } else {
                return renderElement;
              }
            }
          });
          if (!opts.scroll?.disableScrollLimit) {
            ctx2.playground.registerLayer(FlowScrollLimitLayer);
          }
          if (!opts.scroll?.disableScrollBar) {
            ctx2.playground.registerLayer(FlowScrollBarLayer);
          }
          if (opts.onContentChange) {
            ctx2.document.onContentChange((event) => opts.onContentChange(ctx2, event));
          }
        },
        containerModules: [WorkflowDocumentContainerModule]
      }),
      /**
       * 渲染层级管理
       */
      createFreeStackPlugin({}),
      /**
       * 线条渲染插件
       */
      createFreeLinesPlugin({}),
      /**
       * 节点 hover 插件
       */
      createFreeHoverPlugin({}),
      /**
       * 自动布局插件
       */
      createFreeAutoLayoutPlugin({}),
      /**
       * 选择框插件
       */
      createSelectBoxPlugin({
        canSelect: (e) => {
          if (e.button !== 0) {
            return false;
          }
          const element = e.target;
          if (element) {
            if (element.classList.contains("gedit-flow-background-layer")) {
              return true;
            }
            if (element.closest('[data-flow-editor-selectable="true"]')) {
              return true;
            }
            if (element.closest('[data-flow-editor-selectable="false"]')) {
              return false;
            }
          }
          const hoverService = ctx.get(WorkflowHoverService);
          if (hoverService.isSomeHovered()) {
            return false;
          }
          return true;
        },
        ignoreOneSelect: true,
        // 自由布局不选择单个节点
        ignoreChildrenLength: true,
        // 自由布局忽略子节点数量
        ...opts.selectBox || {}
      })
    );
    return createPlaygroundReactPreset(opts, plugins)(ctx);
  };
}

// src/components/free-layout-editor-provider.tsx
var FreeLayoutEditorProvider = forwardRef(
  function FreeLayoutEditorProvider2(props, ref) {
    const { children, ...others } = props;
    const preset = useMemo(() => createFreeLayoutPreset(others), []);
    const customPluginContext = useCallback(
      (container) => ({
        ...createPluginContextDefault(container),
        get document() {
          return container.get(WorkflowDocument2);
        },
        get clipboard() {
          return container.get(ClipboardService2);
        },
        get selection() {
          return container.get(SelectionService3);
        },
        get history() {
          return container.get(HistoryService2);
        }
      }),
      []
    );
    return /* @__PURE__ */ React.createElement(PlaygroundReactProvider, { ref, plugins: preset, customPluginContext }, children);
  }
);

// src/components/workflow-node-renderer.tsx
import React2 from "react";
import clx from "clsx";
import { WorkflowPortRender } from "@flowgram.ai/free-lines-plugin";
import {
  useNodeRender
} from "@flowgram.ai/free-layout-core";
var WorkflowNodeRenderer = (props) => {
  const { selected, activated, startDrag, ports, selectNode, nodeRef, onFocus, onBlur } = useNodeRender();
  const className = clx(props.className || "", {
    activated,
    selected
  });
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(
    "div",
    {
      className,
      style: props.style,
      ref: nodeRef,
      draggable: true,
      onDragStart: startDrag,
      onClick: selectNode,
      onFocus,
      onBlur,
      "data-node-selected": String(selected)
    },
    props.children
  ), ports.map((p) => /* @__PURE__ */ React2.createElement(
    WorkflowPortRender,
    {
      key: p.id,
      entity: p,
      onClick: props.onPortClick ? (e) => props.onPortClick(p, e) : void 0,
      className: props.portClassName,
      style: props.portStyle
    }
  )));
};

// src/components/free-layout-editor.tsx
import React3, { forwardRef as forwardRef2 } from "react";
import { EditorRenderer } from "@flowgram.ai/editor";
var FreeLayoutEditor = forwardRef2(
  function FreeLayoutEditor2(props, ref) {
    const { children, ...otherProps } = props;
    return /* @__PURE__ */ React3.createElement(FreeLayoutEditorProvider, { ref, ...otherProps }, /* @__PURE__ */ React3.createElement(EditorRenderer, null, children));
  }
);

// src/components/index.ts
__reExport(components_exports, free_stack_plugin_star);
import * as free_stack_plugin_star from "@flowgram.ai/free-stack-plugin";
import {
  WorkflowPortRender as WorkflowPortRender2
} from "@flowgram.ai/free-lines-plugin";

// src/index.ts
__reExport(src_exports, components_exports);

// src/hooks/use-auto-layout.ts
import { useCallback as useCallback2 } from "react";
import {
  fitView,
  usePlayground,
  usePlaygroundContainer,
  useService,
  WorkflowDocument as WorkflowDocument3
} from "@flowgram.ai/free-layout-core";
import { FreeOperationType, HistoryService as HistoryService3 } from "@flowgram.ai/free-history-plugin";
import { AutoLayoutService } from "@flowgram.ai/free-auto-layout-plugin";
import { TransformData } from "@flowgram.ai/editor";
var getNodePosition = (node) => {
  const transform = node.getData(TransformData);
  return {
    x: transform.position.x,
    y: transform.position.y
  };
};
var useHistoryService = () => {
  const container = usePlaygroundContainer();
  try {
    return container.get(HistoryService3);
  } catch (e) {
    return {
      pushOperation: () => {
      }
    };
  }
};
var useUpdateHistory = () => {
  const historyService = useHistoryService();
  const update = useCallback2(
    (params) => {
      const { nodes, startPositions: oldValue, endPositions: value } = params;
      const ids = nodes.map((node) => node.id);
      historyService.pushOperation(
        {
          type: FreeOperationType.dragNodes,
          value: {
            ids,
            value,
            oldValue
          }
        },
        {
          noApply: true
        }
      );
    },
    [historyService]
  );
  return update;
};
var createResetFn = (params) => {
  const { nodes, startPositions } = params;
  return () => {
    nodes.forEach((node, index) => {
      const transform = node.getData(TransformData);
      const position = startPositions[index];
      transform.update({
        position
      });
    });
  };
};
var useApplyLayout = () => {
  const document = useService(WorkflowDocument3);
  const autoLayoutService = useService(AutoLayoutService);
  const updateHistory = useUpdateHistory();
  const handleAutoLayout = useCallback2(
    async (options) => {
      const nodes = document.getAllNodes();
      const startPositions = nodes.map(getNodePosition);
      await autoLayoutService.layout(options);
      const endPositions = nodes.map(getNodePosition);
      updateHistory({
        nodes,
        startPositions,
        endPositions
      });
      return createResetFn({
        nodes,
        startPositions
      });
    },
    [autoLayoutService, document, updateHistory]
  );
  return handleAutoLayout;
};
var useAutoLayout = () => {
  const document = useService(WorkflowDocument3);
  const playground = usePlayground();
  const applyLayout = useApplyLayout();
  const handleFitView = useCallback2(
    (easing) => {
      fitView(document, playground.config, easing);
    },
    [document, playground]
  );
  const autoLayout = useCallback2(
    async (options) => {
      handleFitView();
      const resetFn = await applyLayout(options);
      handleFitView();
      return resetFn;
    },
    [applyLayout]
  );
  return autoLayout;
};

// src/hooks/use-client-context.ts
import { useService as useService2, PluginContext as PluginContext3 } from "@flowgram.ai/editor";
function useClientContext() {
  return useService2(PluginContext3);
}

// src/hooks/use-playground-tools.ts
import { useCallback as useCallback3, useEffect, useState } from "react";
import {
  EditorCursorState,
  InteractiveType,
  WorkflowDocument as WorkflowDocument4,
  fitView as fitView2,
  usePlayground as usePlayground2,
  useService as useService3
} from "@flowgram.ai/free-layout-core";
import { EditorState } from "@flowgram.ai/editor";
function usePlaygroundTools() {
  const playground = usePlayground2();
  const doc = useService3(WorkflowDocument4);
  const [zoom, setZoom] = useState(1);
  const [lineType, setLineType] = useState(doc.linesManager.lineType);
  const [cursorState, setCursorState] = useState(EditorCursorState.SELECT);
  const [interactiveType, setInteractiveType] = useState(InteractiveType.PAD);
  const handleZoomOut = useCallback3(
    (easing) => {
      if (zoom < 0.1) {
        return;
      }
      playground?.config.zoomout(easing);
    },
    [zoom, playground]
  );
  const handleZoomIn = useCallback3(
    (easing) => {
      if (zoom > 1.9) {
        return;
      }
      playground?.config.zoomin(easing);
    },
    [zoom, playground]
  );
  const handleLineTypeChange = useCallback3(
    (lineType2) => {
      const newLineType = doc.linesManager.switchLineType(lineType2);
      setLineType(newLineType);
      return newLineType;
    },
    [doc]
  );
  const handleFitView = useCallback3(
    (easing) => {
      fitView2(doc, playground.config, easing);
    },
    [doc, playground]
  );
  const handleAutoLayout = useAutoLayout();
  useEffect(() => {
    let dispose = null;
    if (playground) {
      dispose = playground.onZoom((z) => setZoom(z));
    }
    return () => {
      if (dispose) {
        dispose.dispose();
      }
    };
  }, [playground]);
  useEffect(() => {
    const disposable = playground.editorState.onStateChange((e) => {
      setCursorState(
        e.state === EditorState.STATE_GRAB || e.state === EditorState.STATE_MOUSE_FRIENDLY_SELECT ? EditorCursorState.GRAB : EditorCursorState.SELECT
      );
      setInteractiveType(
        e.state === EditorState.STATE_MOUSE_FRIENDLY_SELECT ? InteractiveType.MOUSE : InteractiveType.PAD
      );
    });
    return () => {
      disposable.dispose();
    };
  }, [playground]);
  function handleUpdateCursorState(stateId) {
    let finalStateId;
    if (typeof stateId === "function") {
      finalStateId = stateId({
        isPressingSpaceBar: playground.editorState.isPressingSpaceBar,
        cursorState
      });
    } else {
      finalStateId = stateId;
    }
    if (typeof finalStateId === "undefined") {
      return;
    }
    if (finalStateId === EditorCursorState.GRAB) {
      playground.editorState.changeState(EditorState.STATE_GRAB.id);
      setCursorState(finalStateId);
    } else if (finalStateId = EditorCursorState.SELECT) {
      playground.editorState.changeState(EditorState.STATE_SELECT.id);
      setCursorState(finalStateId);
    }
  }
  function handleUpdateInteractiveType(interactiveType2) {
    if (interactiveType2 === InteractiveType.MOUSE) {
      playground.editorState.changeState(EditorState.STATE_MOUSE_FRIENDLY_SELECT.id);
      setCursorState(EditorCursorState.GRAB);
    } else if (interactiveType2 === InteractiveType.PAD) {
      playground.editorState.changeState(EditorState.STATE_SELECT.id);
      setCursorState(EditorCursorState.SELECT);
    }
    setInteractiveType(interactiveType2);
    return;
  }
  function handleUpdateMouseScrollDelta(delta) {
    playground.config.updateConfig({
      mouseScrollDelta: delta
    });
  }
  return {
    zoomin: handleZoomIn,
    zoomout: handleZoomOut,
    fitView: handleFitView,
    autoLayout: handleAutoLayout,
    switchLineType: handleLineTypeChange,
    zoom,
    lineType,
    cursorState,
    setCursorState: handleUpdateCursorState,
    interactiveType,
    setInteractiveType: handleUpdateInteractiveType,
    setMouseScrollDelta: handleUpdateMouseScrollDelta
  };
}

// src/index.ts
export * from "@flowgram.ai/free-history-plugin";
export {
  FreeLayoutEditor,
  FreeLayoutEditorProvider,
  FreeLayoutPluginContext,
  FreeLayoutProps,
  WorkflowNodeRenderer,
  WorkflowPortRender2 as WorkflowPortRender,
  createFreeLayoutPreset,
  useAutoLayout,
  useClientContext,
  usePlaygroundTools
};
//# sourceMappingURL=index.js.map