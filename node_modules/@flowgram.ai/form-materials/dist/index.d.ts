import React$1 from 'react';
import { TriggerRenderProps } from '@douyinfe/semi-ui/lib/es/treeSelect';
import { EffectOptions, ASTNodeJSON, ASTNode, BaseType } from '@flowgram.ai/editor';

type JsonSchemaBasicType = 'boolean' | 'string' | 'integer' | 'number' | 'object' | 'array' | 'map';
interface IJsonSchema<T = string> {
    type?: T;
    default?: any;
    title?: string;
    description?: string;
    enum?: (string | number)[];
    properties?: Record<string, IJsonSchema<T>>;
    additionalProperties?: IJsonSchema<T>;
    items?: IJsonSchema<T>;
    required?: string[];
    $ref?: string;
    extra?: {
        index?: number;
        weak?: boolean;
        formComponent?: string;
        [key: string]: any;
    };
}
type IBasicJsonSchema = IJsonSchema<JsonSchemaBasicType>;

interface PropTypes$2 {
    value?: string[];
    config?: {
        placeholder?: string;
        notFoundContent?: string;
    };
    onChange: (value?: string[]) => void;
    includeSchema?: IJsonSchema | IJsonSchema[];
    excludeSchema?: IJsonSchema | IJsonSchema[];
    readonly?: boolean;
    hasError?: boolean;
    style?: React$1.CSSProperties;
    triggerRender?: (props: TriggerRenderProps) => React$1.ReactNode;
}
type VariableSelectorProps = PropTypes$2;
declare const VariableSelector: ({ value, config, onChange, style, readonly, includeSchema, excludeSchema, hasError, triggerRender, }: PropTypes$2) => React$1.JSX.Element;

interface IFlowConstantValue {
    type: 'constant';
    content?: string | number | boolean;
}
interface IFlowRefValue {
    type: 'ref';
    content?: string[];
}
interface IFlowExpressionValue {
    type: 'expression';
    content?: string;
}
interface IFlowTemplateValue {
    type: 'template';
    content?: string;
}
type IFlowValue = IFlowConstantValue | IFlowRefValue | IFlowExpressionValue | IFlowTemplateValue;
type IFlowConstantRefValue = IFlowConstantValue | IFlowRefValue;

declare const VariableTypeIcons: {
    [key: string]: React$1.ReactNode;
};
declare const ArrayIcons: {
    [key: string]: React$1.ReactNode;
};
declare const getSchemaIcon: (value?: Partial<IJsonSchema>) => React$1.ReactNode;

interface PropTypes$1 {
    value?: Partial<IJsonSchema>;
    onChange: (value?: Partial<IJsonSchema>) => void;
    disabled?: boolean;
    style?: React$1.CSSProperties;
}
declare const getTypeSelectValue: (value?: Partial<IJsonSchema>) => string[] | undefined;
declare const parseTypeSelectValue: (value?: string[]) => Partial<IJsonSchema> | undefined;
declare function TypeSelector(props: PropTypes$1): React$1.JSX.Element;

interface ConfigType {
    placeholder?: string;
    descTitle?: string;
    descPlaceholder?: string;
    addButtonText?: string;
}

declare function JsonSchemaEditor(props: {
    value?: IJsonSchema;
    onChange?: (value: IJsonSchema) => void;
    config?: ConfigType;
}): React$1.JSX.Element;

declare function BatchVariableSelector(props: VariableSelectorProps): React$1.JSX.Element;

interface Strategy<Value = any> {
    hit: (schema: IJsonSchema) => boolean;
    Renderer: React.FC<RendererProps<Value>>;
}
interface RendererProps<Value = any> {
    value?: Value;
    onChange?: (value: Value) => void;
    readonly?: boolean;
}
interface PropsType$1 extends RendererProps {
    schema: IJsonSchema;
    strategies?: Strategy[];
    [key: string]: any;
}

declare function ConstantInput(props: PropsType$1): React$1.JSX.Element;

interface PropsType {
    value?: IFlowConstantRefValue;
    onChange: (value?: IFlowConstantRefValue) => void;
    readonly?: boolean;
    hasError?: boolean;
    style?: React$1.CSSProperties;
    schema?: IJsonSchema;
    constantProps?: {
        strategies?: Strategy[];
        [key: string]: any;
    };
}
declare function DynamicValueInput({ value, onChange, readonly, style, schema, constantProps, }: PropsType): React$1.JSX.Element;

declare enum Op {
    EQ = "eq",
    NEQ = "neq",
    GT = "gt",
    GTE = "gte",
    LT = "lt",
    LTE = "lte",
    IN = "in",
    NIN = "nin",
    CONTAINS = "contains",
    NOT_CONTAINS = "not_contains",
    IS_EMPTY = "is_empty",
    IS_NOT_EMPTY = "is_not_empty",
    IS_TRUE = "is_true",
    IS_FALSE = "is_false"
}
interface ConditionRowValueType {
    left?: IFlowRefValue;
    operator?: Op;
    right?: IFlowConstantRefValue;
}

interface PropTypes {
    value?: ConditionRowValueType;
    onChange: (value?: ConditionRowValueType) => void;
    style?: React$1.CSSProperties;
    readonly?: boolean;
}
declare function ConditionRow({ style, value, onChange, readonly }: PropTypes): React$1.JSX.Element;

declare const provideBatchInputEffect: EffectOptions[];

declare const provideBatchOutputsEffect: EffectOptions[];

/**
 * Auto rename ref when form item's key is renamed
 *
 * Example:
 *
 * formMeta: {
 *  effects: {
 *    "inputsValues": autoRenameRefEffect,
 *  }
 * }
 */
declare const autoRenameRefEffect: EffectOptions[];

interface LegacyFlowRefValueSchema {
    type: 'ref';
    content: string;
}
interface NewFlowRefValueSchema {
    type: 'ref';
    content: string[];
}
/**
 * In flowgram 0.2.0, for introducing Loop variable functionality,
 * the FlowRefValueSchema type definition is updated:
 *
 * interface LegacyFlowRefValueSchema {
 *  type: 'ref';
 *  content: string;
 * }
 *
 * interface NewFlowRefValueSchema {
 *  type: 'ref';
 *  content: string[];
 * }
 *
 *
 * For making sure backend json will not be changed, we provide format legacy ref utils for updating the formData
 *
 * How to use:
 *
 * 1. Call formatLegacyRefOnSubmit on the formData before submitting
 * 2. Call formatLegacyRefOnInit on the formData after submitting
 *
 * Example:
 * import { formatLegacyRefOnSubmit, formatLegacyRefOnInit } from '@flowgram.ai/form-materials';
 * formMeta: {
 *  formatOnSubmit: (data) => formatLegacyRefOnSubmit(data),
 *  formatOnInit: (data) => formatLegacyRefOnInit(data),
 * }
 */
declare function formatLegacyRefOnSubmit(value: any): any;
/**
 * In flowgram 0.2.0, for introducing Loop variable functionality,
 * the FlowRefValueSchema type definition is updated:
 *
 * interface LegacyFlowRefValueSchema {
 *  type: 'ref';
 *  content: string;
 * }
 *
 * interface NewFlowRefValueSchema {
 *  type: 'ref';
 *  content: string[];
 * }
 *
 *
 * For making sure backend json will not be changed, we provide format legacy ref utils for updating the formData
 *
 * How to use:
 *
 * 1. Call formatLegacyRefOnSubmit on the formData before submitting
 * 2. Call formatLegacyRefOnInit on the formData after submitting
 *
 * Example:
 * import { formatLegacyRefOnSubmit, formatLegacyRefOnInit } from '@flowgram.ai/form-materials';
 *
 * formMeta: {
 *  formatOnSubmit: (data) => formatLegacyRefOnSubmit(data),
 *  formatOnInit: (data) => formatLegacyRefOnInit(data),
 * }
 */
declare function formatLegacyRefOnInit(value: any): any;
declare function isLegacyFlowRefValueSchema(value: any): value is LegacyFlowRefValueSchema;
declare function isNewFlowRefValueSchema(value: any): value is NewFlowRefValueSchema;
declare function formatLegacyRefToNewRef(value: LegacyFlowRefValueSchema): {
    type: string;
    content: string[];
};
declare function formatNewRefToLegacyRef(value: NewFlowRefValueSchema): {
    type: string;
    content: string;
};

declare namespace JsonSchemaUtils {
    /**
     * Converts a JSON schema to an Abstract Syntax Tree (AST) representation.
     * This function recursively processes the JSON schema and creates corresponding AST nodes.
     *
     * For more information on JSON Schema, refer to the official documentation:
     * https://json-schema.org/
     *
     * @param jsonSchema - The JSON schema to convert.
     * @returns An AST node representing the JSON schema, or undefined if the schema type is not recognized.
     */
    function schemaToAST(jsonSchema: IJsonSchema): ASTNodeJSON | undefined;
    /**
     * Convert AST To JSON Schema
     * @param typeAST
     * @returns
     */
    function astToSchema(typeAST: ASTNode, options?: {
        drilldown?: boolean;
    }): IJsonSchema | undefined;
    /**
     * Check if the AST type is match the JSON Schema
     * @param typeAST
     * @param schema
     * @returns
     */
    function isASTMatchSchema(typeAST: BaseType, schema: IJsonSchema | IJsonSchema[]): boolean;
}

export { ArrayIcons, BatchVariableSelector, ConditionRow, type ConditionRowValueType, ConstantInput, DynamicValueInput, type IBasicJsonSchema, type IFlowConstantRefValue, type IFlowConstantValue, type IFlowExpressionValue, type IFlowRefValue, type IFlowTemplateValue, type IFlowValue, type IJsonSchema, type JsonSchemaBasicType, JsonSchemaEditor, JsonSchemaUtils, TypeSelector, VariableSelector, type VariableSelectorProps, VariableTypeIcons, autoRenameRefEffect, formatLegacyRefOnInit, formatLegacyRefOnSubmit, formatLegacyRefToNewRef, formatNewRefToLegacyRef, getSchemaIcon, getTypeSelectValue, isLegacyFlowRefValueSchema, isNewFlowRefValueSchema, parseTypeSelectValue, provideBatchInputEffect, provideBatchOutputsEffect };
