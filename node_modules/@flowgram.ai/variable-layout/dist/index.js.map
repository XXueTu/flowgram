{"version":3,"sources":["../src/index.ts","../src/flow-node-variable-data.ts","../src/types.ts","../src/chains/free-layout-scope-chain.ts","../src/variable-layout-config.ts","../src/scopes/global-scope.ts","../src/chains/fixed-layout-scope-chain.ts"],"sourcesContent":["export { FlowNodeVariableData } from './flow-node-variable-data';\nexport { FreeLayoutScopeChain } from './chains/free-layout-scope-chain';\nexport { VariableLayoutConfig } from './variable-layout-config';\nexport { FixedLayoutScopeChain } from './chains/fixed-layout-scope-chain';\nexport {\n  type FlowNodeScopeMeta,\n  type FlowNodeScope,\n  FlowNodeScopeTypeEnum as FlowNodeScopeType,\n} from './types';\nexport { GlobalScope, bindGlobalScope } from './scopes/global-scope';\n","import { VariableEngine } from '@flowgram.ai/variable-core';\nimport { type ASTNode, ASTNodeJSON } from '@flowgram.ai/variable-core';\nimport { FlowNodeEntity } from '@flowgram.ai/document';\nimport { EntityData } from '@flowgram.ai/core';\n\nimport { FlowNodeScope, FlowNodeScopeMeta, FlowNodeScopeTypeEnum } from './types';\n\ninterface Options {\n  variableEngine: VariableEngine;\n}\n\nexport class FlowNodeVariableData extends EntityData {\n  static type: string = 'FlowNodeVariableData';\n\n  declare entity: FlowNodeEntity;\n\n  readonly variableEngine: VariableEngine;\n\n  /**\n   * Private variables can be accessed by public ones, but not the other way around.\n   */\n  protected _private?: FlowNodeScope;\n\n  protected _public: FlowNodeScope;\n\n  get private() {\n    return this._private;\n  }\n\n  get public() {\n    return this._public;\n  }\n\n  /**\n   * Sets a variable in the public AST (Abstract Syntax Tree) with the given key and JSON value.\n   *\n   * @param key - The key under which the variable will be stored.\n   * @param json - The JSON value to store.\n   * @returns The updated AST node.\n   */\n  public setVar(key: string, json: ASTNodeJSON): ASTNode;\n\n  /**\n   * Sets a variable in the public AST (Abstract Syntax Tree) with the default key 'outputs'.\n   *\n   * @param json - The JSON value to store.\n   * @returns The updated AST node.\n   */\n  public setVar(json: ASTNodeJSON): ASTNode;\n\n  public setVar(arg1: string | ASTNodeJSON, arg2?: ASTNodeJSON): ASTNode {\n    if (typeof arg1 === 'string' && arg2 !== undefined) {\n      return this.public.ast.set(arg1, arg2);\n    }\n\n    if (typeof arg1 === 'object' && arg2 === undefined) {\n      return this.public.ast.set('outputs', arg1);\n    }\n\n    throw new Error('Invalid arguments');\n  }\n\n  /**\n   * Retrieves a variable from the public AST (Abstract Syntax Tree) by key.\n   *\n   * @param key - The key of the variable to retrieve. Defaults to 'outputs'.\n   * @returns The value of the variable, or undefined if not found.\n   */\n  public getVar(key: string = 'outputs') {\n    return this.public.ast.get(key);\n  }\n\n  /**\n   * Clears a variable from the public AST (Abstract Syntax Tree) by key.\n   *\n   * @param key - The key of the variable to clear. Defaults to 'outputs'.\n   * @returns The updated AST node.\n   */\n  public clearVar(key: string = 'outputs') {\n    return this.public.ast.remove(key);\n  }\n\n  /**\n   * Sets a variable in the private AST (Abstract Syntax Tree) with the given key and JSON value.\n   *\n   * @param key - The key under which the variable will be stored.\n   * @param json - The JSON value to store.\n   * @returns The updated AST node.\n   */\n  public setPrivateVar(key: string, json: ASTNodeJSON): ASTNode;\n\n  /**\n   * Sets a variable in the private AST (Abstract Syntax Tree) with the default key 'outputs'.\n   *\n   * @param json - The JSON value to store.\n   * @returns The updated AST node.\n   */\n  public setPrivateVar(json: ASTNodeJSON): ASTNode;\n\n  public setPrivateVar(arg1: string | ASTNodeJSON, arg2?: ASTNodeJSON): ASTNode {\n    if (typeof arg1 === 'string' && arg2 !== undefined) {\n      return this.initPrivate().ast.set(arg1, arg2);\n    }\n\n    if (typeof arg1 === 'object' && arg2 === undefined) {\n      return this.initPrivate().ast.set('outputs', arg1);\n    }\n\n    throw new Error('Invalid arguments');\n  }\n\n  /**\n   * Retrieves a variable from the private AST (Abstract Syntax Tree) by key.\n   *\n   * @param key - The key of the variable to retrieve. Defaults to 'outputs'.\n   * @returns The value of the variable, or undefined if not found.\n   */\n  public getPrivateVar(key: string = 'outputs') {\n    return this.private?.ast.get(key);\n  }\n\n  /**\n   * Clears a variable from the private AST (Abstract Syntax Tree) by key.\n   *\n   * @param key - The key of the variable to clear. Defaults to 'outputs'.\n   * @returns The updated AST node.\n   */\n  public clearPrivateVar(key: string = 'outputs') {\n    return this.private?.ast.remove(key);\n  }\n\n  get allScopes(): FlowNodeScope[] {\n    const res = [];\n\n    if (this._public) {\n      res.push(this._public);\n    }\n    if (this._private) {\n      res.push(this._private);\n    }\n\n    return res;\n  }\n\n  getDefaultData() {\n    return {};\n  }\n\n  constructor(entity: FlowNodeEntity, readonly opts: Options) {\n    super(entity);\n\n    const { variableEngine } = opts || {};\n    this.variableEngine = variableEngine;\n    this._public = this.variableEngine.createScope(this.entity.id, {\n      node: this.entity,\n      type: FlowNodeScopeTypeEnum.public,\n    } as FlowNodeScopeMeta);\n    this.toDispose.push(this._public);\n  }\n\n  initPrivate(): FlowNodeScope {\n    if (!this._private) {\n      this._private = this.variableEngine.createScope(`${this.entity.id}_private`, {\n        node: this.entity,\n        type: FlowNodeScopeTypeEnum.private,\n      } as FlowNodeScopeMeta);\n      // 1. Notify the covering scopes of private to update dependencies\n      this._private.coverScopes.forEach((_scope) => {\n        _scope.refreshDeps();\n      });\n      // 2. Notify the dependent scopes of private to update their covers\n      this._private.depScopes.forEach((_scope) => {\n        _scope.refreshCovers();\n      });\n      // 3. The private scope itself needs to refresh its dependencies\n      this._private.available.refresh();\n\n      this.toDispose.push(this._private);\n    }\n    return this._private;\n  }\n}\n","import { Scope } from '@flowgram.ai/variable-core';\nimport { FlowNodeEntity } from '@flowgram.ai/document';\n\nexport enum FlowNodeScopeTypeEnum {\n  public = 'public',\n  private = 'private',\n}\n\nexport interface FlowNodeScopeMeta {\n  node?: FlowNodeEntity;\n  type?: FlowNodeScopeTypeEnum;\n}\n\nexport interface ScopeVirtualNode {\n  id: string;\n  flowNodeType: 'virtualNode';\n}\n\nexport type ScopeChainNode = FlowNodeEntity | ScopeVirtualNode;\n\n// 节点内部的作用域\nexport type FlowNodeScope = Scope<FlowNodeScopeMeta>;\n","import { inject, optional, postConstruct } from 'inversify';\nimport { Scope, ScopeChain } from '@flowgram.ai/variable-core';\nimport { WorkflowNodeLinesData, WorkflowNodeMeta } from '@flowgram.ai/free-layout-core';\nimport { FlowNodeEntity, FlowDocument, FlowVirtualTree } from '@flowgram.ai/document';\nimport { EntityManager } from '@flowgram.ai/core';\n\nimport { VariableLayoutConfig } from '../variable-layout-config';\nimport { FlowNodeScope, FlowNodeScopeTypeEnum } from '../types';\nimport { GlobalScope } from '../scopes/global-scope';\nimport { FlowNodeVariableData } from '../flow-node-variable-data';\n\n/**\n * 自由布局作用域链实现\n */\nexport class FreeLayoutScopeChain extends ScopeChain {\n  @inject(EntityManager) entityManager: EntityManager;\n\n  @inject(FlowDocument)\n  protected flowDocument: FlowDocument;\n\n  @optional()\n  @inject(VariableLayoutConfig)\n  protected configs?: VariableLayoutConfig;\n\n  get tree(): FlowVirtualTree<FlowNodeEntity> {\n    return this.flowDocument.originTree;\n  }\n\n  @postConstruct()\n  onInit() {\n    this.toDispose.pushAll([\n      // 线条发生变化时，会触发作用域链的更新\n      this.entityManager.onEntityDataChange(({ entityDataType }) => {\n        if (entityDataType === WorkflowNodeLinesData.type) {\n          this.refreshAllChange();\n        }\n      }),\n      // 树变化时候刷新作用域\n      this.tree.onTreeChange(() => {\n        this.refreshAllChange();\n      }),\n    ]);\n  }\n\n  // 获取同一层级所有输入节点\n  protected getAllInputLayerNodes(curr: FlowNodeEntity): FlowNodeEntity[] {\n    return (curr.getData(WorkflowNodeLinesData)?.allInputNodes || []).filter(\n      (_node) => _node.parent === curr.parent\n    );\n  }\n\n  // 获取同一层级所有输出节点\n  protected getAllOutputLayerNodes(curr: FlowNodeEntity): FlowNodeEntity[] {\n    return (curr.getData(WorkflowNodeLinesData)?.allOutputNodes || []).filter(\n      (_node) => _node.parent === curr.parent\n    );\n  }\n\n  getDeps(scope: FlowNodeScope): FlowNodeScope[] {\n    const { node } = scope.meta || {};\n    if (!node) {\n      return this.transformDeps([], { scope });\n    }\n\n    const deps: FlowNodeScope[] = [];\n\n    // 1. 找到依赖的节点\n    let curr: FlowNodeEntity | undefined = node;\n\n    while (curr) {\n      const allInputNodes: FlowNodeEntity[] = this.getAllInputLayerNodes(curr);\n\n      // 2. 获取所有依赖节点的 public 作用域\n      deps.push(\n        ...allInputNodes.map((_node) => _node.getData(FlowNodeVariableData).public).filter(Boolean)\n      );\n\n      // 父节点的 private 也可以访问\n      const currVarData: FlowNodeVariableData = curr.getData(FlowNodeVariableData);\n      if (currVarData?.private && scope !== currVarData.private) {\n        deps.push(currVarData.private);\n      }\n\n      curr = this.getParent(curr);\n    }\n\n    // If scope is GlobalScope, add globalScope to deps\n    const globalScope = this.variableEngine.getScopeById(GlobalScope.ID);\n    if (globalScope) {\n      deps.unshift(globalScope);\n    }\n\n    const uniqDeps = Array.from(new Set(deps));\n    return this.transformDeps(uniqDeps, { scope });\n  }\n\n  getCovers(scope: FlowNodeScope): FlowNodeScope[] {\n    // If scope is GlobalScope, return all scopes except GlobalScope\n    if (GlobalScope.is(scope)) {\n      return this.variableEngine\n        .getAllScopes({ sort: true })\n        .filter((_scope) => !GlobalScope.is(_scope));\n    }\n\n    const { node } = scope.meta || {};\n    if (!node) {\n      return this.transformCovers([], { scope });\n    }\n\n    const isPrivate = scope.meta.type === FlowNodeScopeTypeEnum.private;\n\n    // 1. BFS 找到所有覆盖的节点\n    const queue: FlowNodeEntity[] = [];\n\n    if (isPrivate) {\n      // private 只能覆盖其子节点\n      queue.push(...this.getChildren(node));\n    } else {\n      // 否则覆盖其所有输出线的节点\n      queue.push(...(this.getAllOutputLayerNodes(node) || []));\n    }\n\n    // 2. 获取所有覆盖节点的 public、private 作用域\n    const scopes: FlowNodeScope[] = [];\n\n    while (queue.length) {\n      const _node = queue.shift()!;\n      const variableData: FlowNodeVariableData = _node.getData(FlowNodeVariableData);\n      scopes.push(...variableData.allScopes);\n      const children = _node && this.getChildren(_node);\n\n      if (children?.length) {\n        queue.push(...children);\n      }\n    }\n\n    // 3. 如果当前 scope 是 private，则当前节点的 public 也可覆盖\n    const currentVariableData: FlowNodeVariableData = node.getData(FlowNodeVariableData);\n    if (isPrivate && currentVariableData.public) {\n      scopes.push(currentVariableData.public);\n    }\n\n    const uniqScopes = Array.from(new Set(scopes));\n\n    return this.transformCovers(uniqScopes, { scope });\n  }\n\n  protected transformCovers(covers: Scope[], { scope }: { scope: Scope }): Scope[] {\n    return this.configs?.transformCovers\n      ? this.configs.transformCovers(covers, {\n          scope,\n          document: this.flowDocument,\n          variableEngine: this.variableEngine,\n        })\n      : covers;\n  }\n\n  protected transformDeps(deps: Scope[], { scope }: { scope: Scope }): Scope[] {\n    return this.configs?.transformDeps\n      ? this.configs.transformDeps(deps, {\n          scope,\n          document: this.flowDocument,\n          variableEngine: this.variableEngine,\n        })\n      : deps;\n  }\n\n  getChildren(node: FlowNodeEntity): FlowNodeEntity[] {\n    if (this.configs?.getFreeChildren) {\n      return this.configs.getFreeChildren?.(node);\n    }\n    const nodeMeta = node.getNodeMeta<WorkflowNodeMeta>();\n    const subCanvas = nodeMeta.subCanvas?.(node);\n\n    if (subCanvas) {\n      // 子画布本身不存在 children\n      if (subCanvas.isCanvas) {\n        return [];\n      } else {\n        return subCanvas.canvasNode.collapsedChildren;\n      }\n    }\n\n    // 部分场景通过连线来表达父子关系，因此需要上层配置\n    return this.tree.getChildren(node);\n  }\n\n  getParent(node: FlowNodeEntity): FlowNodeEntity | undefined {\n    // 部分场景通过连线来表达父子关系，因此需要上层配置\n    if (this.configs?.getFreeParent) {\n      return this.configs.getFreeParent(node);\n    }\n    const initParent = node.document.originTree.getParent(node);\n\n    if (!initParent) {\n      return initParent;\n    }\n\n    const nodeMeta = initParent.getNodeMeta<WorkflowNodeMeta>();\n    const subCanvas = nodeMeta.subCanvas?.(initParent);\n    if (subCanvas?.isCanvas) {\n      return subCanvas.parentNode;\n    }\n\n    return initParent;\n  }\n\n  sortAll(): Scope[] {\n    // 暂未实现\n    console.warn('FreeLayoutScopeChain.sortAll is not implemented');\n    return [];\n  }\n}\n","import { Scope } from '@flowgram.ai/variable-core';\nimport { VariableEngine } from '@flowgram.ai/variable-core';\nimport { FlowNodeEntity, FlowDocument } from '@flowgram.ai/document';\n\nimport { type FlowNodeScope, type ScopeChainNode } from './types';\n\ninterface TransformerContext {\n  scope: FlowNodeScope;\n  document: FlowDocument;\n  variableEngine: VariableEngine;\n}\n\nexport interface VariableLayoutConfig {\n  /**\n   * 节点的子节点输出变量，不能被后续节点所访问，用于固定布局场景\n   * @param node\n   * @returns\n   */\n  isNodeChildrenPrivate?: (node: ScopeChainNode) => boolean;\n\n  /**\n   * 用于自由画布场景，部分场景通过连线或者其他交互形式来表达节点之间的父子关系，需要可配置化\n   */\n  getFreeChildren?: (node: FlowNodeEntity) => FlowNodeEntity[];\n  getFreeParent?: (node: FlowNodeEntity) => FlowNodeEntity | undefined;\n\n  /**\n   * 对依赖作用域进行微调\n   */\n  transformDeps?: (scopes: Scope[], ctx: TransformerContext) => Scope[];\n\n  /**\n   * 对依赖作用域进行微调\n   */\n  transformCovers?: (scopes: Scope[], ctx: TransformerContext) => Scope[];\n}\n\nexport const VariableLayoutConfig = Symbol('VariableLayoutConfig');\n","import { injectable, interfaces } from 'inversify';\nimport { ASTNode, ASTNodeJSON, Scope, VariableEngine } from '@flowgram.ai/variable-core';\n\n@injectable()\nexport class GlobalScope extends Scope {\n  static readonly ID = Symbol('GlobalScope');\n\n  static is(scope: Scope): scope is GlobalScope {\n    return scope.id === GlobalScope.ID;\n  }\n\n  /**\n   * Sets a variable in the Global Scope with the given key and JSON value.\n   *\n   * @param key - The key under which the variable will be stored.\n   * @param json - The JSON value to store.\n   * @returns The updated AST node.\n   */\n  public setVar(key: string, json: ASTNodeJSON): ASTNode;\n\n  /**\n   * Sets a variable in the Global Scope with the default key 'outputs'.\n   *\n   * @param json - The JSON value to store.\n   * @returns The updated AST node.\n   */\n  public setVar(json: ASTNodeJSON): ASTNode;\n\n  public setVar(arg1: string | ASTNodeJSON, arg2?: ASTNodeJSON): ASTNode {\n    if (typeof arg1 === 'string' && arg2 !== undefined) {\n      return this.ast.set(arg1, arg2);\n    }\n\n    if (typeof arg1 === 'object' && arg2 === undefined) {\n      return this.ast.set('outputs', arg1);\n    }\n\n    throw new Error('Invalid arguments');\n  }\n\n  /**\n   * Retrieves a variable from the Global Scope by key.\n   *\n   * @param key - The key of the variable to retrieve. Defaults to 'outputs'.\n   * @returns The value of the variable, or undefined if not found.\n   */\n  public getVar(key: string = 'outputs') {\n    return this.ast.get(key);\n  }\n\n  /**\n   * Clears a variable from the Global Scope by key.\n   *\n   * @param key - The key of the variable to clear. Defaults to 'outputs'.\n   * @returns The updated AST node.\n   */\n  public clearVar(key: string = 'outputs') {\n    return this.ast.remove(key);\n  }\n}\n\nexport const bindGlobalScope = (bind: interfaces.Bind) => {\n  bind(GlobalScope).toDynamicValue((ctx) => {\n    const variableEngine = ctx.container.get(VariableEngine);\n    let scope = variableEngine.getScopeById(GlobalScope.ID) as GlobalScope;\n\n    if (!scope) {\n      scope = variableEngine.createScope(\n        GlobalScope.ID,\n        {},\n        { ScopeConstructor: GlobalScope }\n      ) as GlobalScope;\n      variableEngine.chain.refreshAllChange();\n    }\n\n    return scope;\n  });\n};\n","import { inject, optional } from 'inversify';\nimport { Scope, ScopeChain } from '@flowgram.ai/variable-core';\nimport { FlowDocument, type FlowVirtualTree } from '@flowgram.ai/document';\nimport { FlowNodeEntity } from '@flowgram.ai/document';\n\nimport { VariableLayoutConfig } from '../variable-layout-config';\nimport { FlowNodeScope, FlowNodeScopeTypeEnum, ScopeChainNode } from '../types';\nimport { GlobalScope } from '../scopes/global-scope';\nimport { FlowNodeVariableData } from '../flow-node-variable-data';\n\n/**\n * 基于 FlowVirtualTree 的 ScopeOrder 实现\n */\nexport class FixedLayoutScopeChain extends ScopeChain {\n  // 增加  { id: string } 使得可以灵活添加自定义虚拟节点\n  tree: FlowVirtualTree<ScopeChainNode> | undefined;\n\n  constructor(\n    @inject(FlowDocument)\n    protected flowDocument: FlowDocument,\n    @optional()\n    @inject(VariableLayoutConfig)\n    protected configs?: VariableLayoutConfig\n  ) {\n    super();\n\n    // 绑定 flowDocument 里面的树\n    this.bindTree(flowDocument.originTree);\n\n    // originTree 发生变化时，触发依赖关系的变化\n    this.toDispose.push(\n      // REFRACTOR: onTreeChange 触发时机精细化\n      flowDocument.originTree.onTreeChange(() => {\n        this.refreshAllChange();\n      })\n    );\n  }\n\n  // 绑定树\n  bindTree(tree: FlowVirtualTree<ScopeChainNode>): void {\n    this.tree = tree;\n  }\n\n  // 获取依赖作用域\n  getDeps(scope: FlowNodeScope): FlowNodeScope[] {\n    if (!this.tree) {\n      return this.transformDeps([], { scope });\n    }\n\n    const node = scope.meta.node;\n    if (!node) {\n      return this.transformDeps([], { scope });\n    }\n\n    const deps: FlowNodeScope[] = [];\n\n    let curr: ScopeChainNode | undefined = node;\n\n    while (curr) {\n      const { parent, pre } = this.tree.getInfo(curr);\n      const currData = this.getVariableData(curr);\n\n      // 包含子节点，且不是私有作用域\n\n      if (curr === node) {\n        // public 可以依赖 private\n        if (scope.meta.type === FlowNodeScopeTypeEnum.public && currData?.private) {\n          deps.unshift(currData.private);\n        }\n      } else if (this.hasChildren(curr) && !this.isNodeChildrenPrivate(curr)) {\n        // 有子元素的节点，则将子元素纳入依赖作用域\n        deps.unshift(\n          ...this.getAllSortedChildScope(curr, {\n            ignoreNodeChildrenPrivate: true,\n          })\n        );\n      }\n\n      // 节点的 public 都可以被访问\n      if (currData && curr !== node) {\n        deps.unshift(currData.public);\n      }\n\n      // 上个节点处理\n      if (pre) {\n        curr = pre;\n        continue;\n      }\n\n      // 父节点处理\n      if (parent) {\n        let currParent: ScopeChainNode | undefined = parent;\n        let currParentPre: ScopeChainNode | undefined = this.tree.getPre(currParent);\n\n        while (currParent) {\n          // 父节点的 private 和 public 都能被子节点访问\n          const currParentData = this.getVariableData(currParent);\n          if (currParentData) {\n            deps.unshift(...currParentData.allScopes);\n          }\n\n          // 当前 parent 有 pre 节点，则停止向上查找\n          if (currParentPre) {\n            break;\n          }\n\n          currParent = this.tree.getParent(currParent);\n          currParentPre = currParent ? this.tree.getPre(currParent) : undefined;\n        }\n        curr = currParentPre;\n        continue;\n      }\n\n      // next 和 parent 都没有，直接结束循环\n      curr = undefined;\n    }\n\n    // If scope is GlobalScope, add globalScope to deps\n    const globalScope = this.variableEngine.getScopeById(GlobalScope.ID);\n    if (globalScope) {\n      deps.unshift(globalScope);\n    }\n\n    return this.transformDeps(deps, { scope });\n  }\n\n  // 获取覆盖作用域\n  getCovers(scope: FlowNodeScope): FlowNodeScope[] {\n    if (!this.tree) {\n      return this.transformCovers([], { scope });\n    }\n\n    // If scope is GlobalScope, return all scopes except GlobalScope\n    if (GlobalScope.is(scope)) {\n      return this.variableEngine\n        .getAllScopes({ sort: true })\n        .filter((_scope) => !GlobalScope.is(_scope));\n    }\n\n    const node = scope.meta.node;\n    if (!node) {\n      return this.transformCovers([], { scope });\n    }\n\n    const covers: FlowNodeScope[] = [];\n\n    // 如果是 private 作用域，则只能子节点访问\n    if (scope.meta.type === FlowNodeScopeTypeEnum.private) {\n      covers.push(\n        ...this.getAllSortedChildScope(node, {\n          addNodePrivateScope: true,\n        })\n      );\n      return this.transformCovers(covers, { scope });\n    }\n\n    let curr: ScopeChainNode | undefined = node;\n\n    while (curr) {\n      const { next, parent } = this.tree.getInfo(curr);\n      const currData = this.getVariableData(curr);\n\n      // 有子元素的节点，则将子元素纳入覆盖作用域\n      if (curr !== node) {\n        if (this.hasChildren(curr)) {\n          covers.push(\n            ...this.getAllSortedChildScope(curr, {\n              addNodePrivateScope: true,\n            })\n          );\n        } else if (currData) {\n          covers.push(...currData.allScopes);\n        }\n      }\n\n      // 下个节点处理\n      if (next) {\n        curr = next;\n        continue;\n      }\n\n      if (parent) {\n        let currParent: ScopeChainNode | undefined = parent;\n        let currParentNext: ScopeChainNode | undefined = this.tree.getNext(currParent);\n\n        while (currParent) {\n          // 私有作用域不能被后续节点访问\n          if (this.isNodeChildrenPrivate(currParent)) {\n            return this.transformCovers(covers, { scope });\n          }\n\n          // 当前 parent 有 next 节点，则停止向上查找\n          if (currParentNext) {\n            break;\n          }\n\n          currParent = this.tree.getParent(currParent);\n          currParentNext = currParent ? this.tree.getNext(currParent) : undefined;\n        }\n        if (!currParentNext && currParent) {\n          break;\n        }\n\n        curr = currParentNext;\n        continue;\n      }\n\n      // next 和 parent 都没有，直接结束循环\n      curr = undefined;\n    }\n\n    return this.transformCovers(covers, { scope });\n  }\n\n  protected transformCovers(covers: Scope[], { scope }: { scope: Scope }): Scope[] {\n    return this.configs?.transformCovers\n      ? this.configs.transformCovers(covers, {\n          scope,\n          document: this.flowDocument,\n          variableEngine: this.variableEngine,\n        })\n      : covers;\n  }\n\n  protected transformDeps(deps: Scope[], { scope }: { scope: Scope }): Scope[] {\n    return this.configs?.transformDeps\n      ? this.configs.transformDeps(deps, {\n          scope,\n          document: this.flowDocument,\n          variableEngine: this.variableEngine,\n        })\n      : deps;\n  }\n\n  // 排序所有作用域\n  sortAll(): Scope[] {\n    const startNode = this.flowDocument.getAllNodes().find((_node) => _node.isStart);\n    if (!startNode) {\n      return [];\n    }\n\n    const startVariableData = startNode.getData(FlowNodeVariableData);\n    const startPublicScope = startVariableData.public;\n    const deps = this.getDeps(startPublicScope);\n\n    const covers = this.getCovers(startPublicScope).filter(\n      (_scope) => !deps.includes(_scope) && _scope !== startPublicScope\n    );\n\n    return [...deps, startPublicScope, ...covers];\n  }\n\n  // 获取变量 Data 数据\n  private getVariableData(node: ScopeChainNode): FlowNodeVariableData | undefined {\n    if (node.flowNodeType === 'virtualNode') {\n      return;\n    }\n    // TODO 包含 $ 的节点不注册 variableData\n    if (node.id.startsWith('$')) {\n      return;\n    }\n\n    return (node as FlowNodeEntity).getData(FlowNodeVariableData);\n  }\n\n  // privateScope：子节点不可以被后续节点访问\n  private isNodeChildrenPrivate(node?: ScopeChainNode): boolean {\n    if (this.configs?.isNodeChildrenPrivate) {\n      return node ? this.configs?.isNodeChildrenPrivate(node) : false;\n    }\n\n    const isSystemNode = node?.id.startsWith('$');\n    // 兜底：有子节点（节点 id 没有 $ 开头）的全部为私有作用域\n    return !isSystemNode && this.hasChildren(node);\n  }\n\n  private hasChildren(node?: ScopeChainNode): boolean {\n    return Boolean(this.tree && node && this.tree.getChildren(node).length > 0);\n  }\n\n  // 子节点按照顺序进行排序（含自身）\n  private getAllSortedChildScope(\n    node: ScopeChainNode,\n    {\n      ignoreNodeChildrenPrivate,\n      addNodePrivateScope,\n    }: { ignoreNodeChildrenPrivate?: boolean; addNodePrivateScope?: boolean } = {}\n  ): FlowNodeScope[] {\n    const scopes: FlowNodeScope[] = [];\n\n    const variableData = this.getVariableData(node);\n\n    if (variableData) {\n      scopes.push(variableData.public);\n    }\n\n    // 私有作用域，子节点的变量不对外输出\n    //（父节点如果存在 public 变量则对外输出）\n    if (ignoreNodeChildrenPrivate && this.isNodeChildrenPrivate(node)) {\n      return scopes;\n    }\n\n    if (addNodePrivateScope && variableData?.private) {\n      scopes.push(variableData.private);\n    }\n\n    const children = this.tree?.getChildren(node) || [];\n    scopes.push(\n      ...children\n        .map((child) =>\n          this.getAllSortedChildScope(child, { ignoreNodeChildrenPrivate, addNodePrivateScope })\n        )\n        .flat()\n    );\n\n    return scopes;\n  }\n}\n"],"mappings":"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","names":["FlowNodeScopeTypeEnum","import_inversify","import_variable_core","import_core","import_inversify","import_variable_core","import_document"]}