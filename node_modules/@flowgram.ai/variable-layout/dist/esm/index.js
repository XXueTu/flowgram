var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

// src/flow-node-variable-data.ts
import { EntityData } from "@flowgram.ai/core";

// src/types.ts
var FlowNodeScopeTypeEnum = /* @__PURE__ */ ((FlowNodeScopeTypeEnum2) => {
  FlowNodeScopeTypeEnum2["public"] = "public";
  FlowNodeScopeTypeEnum2["private"] = "private";
  return FlowNodeScopeTypeEnum2;
})(FlowNodeScopeTypeEnum || {});

// src/flow-node-variable-data.ts
var FlowNodeVariableData = class extends EntityData {
  constructor(entity, opts) {
    super(entity);
    this.opts = opts;
    const { variableEngine } = opts || {};
    this.variableEngine = variableEngine;
    this._public = this.variableEngine.createScope(this.entity.id, {
      node: this.entity,
      type: "public" /* public */
    });
    this.toDispose.push(this._public);
  }
  get private() {
    return this._private;
  }
  get public() {
    return this._public;
  }
  setVar(arg1, arg2) {
    if (typeof arg1 === "string" && arg2 !== void 0) {
      return this.public.ast.set(arg1, arg2);
    }
    if (typeof arg1 === "object" && arg2 === void 0) {
      return this.public.ast.set("outputs", arg1);
    }
    throw new Error("Invalid arguments");
  }
  /**
   * Retrieves a variable from the public AST (Abstract Syntax Tree) by key.
   *
   * @param key - The key of the variable to retrieve. Defaults to 'outputs'.
   * @returns The value of the variable, or undefined if not found.
   */
  getVar(key = "outputs") {
    return this.public.ast.get(key);
  }
  /**
   * Clears a variable from the public AST (Abstract Syntax Tree) by key.
   *
   * @param key - The key of the variable to clear. Defaults to 'outputs'.
   * @returns The updated AST node.
   */
  clearVar(key = "outputs") {
    return this.public.ast.remove(key);
  }
  setPrivateVar(arg1, arg2) {
    if (typeof arg1 === "string" && arg2 !== void 0) {
      return this.initPrivate().ast.set(arg1, arg2);
    }
    if (typeof arg1 === "object" && arg2 === void 0) {
      return this.initPrivate().ast.set("outputs", arg1);
    }
    throw new Error("Invalid arguments");
  }
  /**
   * Retrieves a variable from the private AST (Abstract Syntax Tree) by key.
   *
   * @param key - The key of the variable to retrieve. Defaults to 'outputs'.
   * @returns The value of the variable, or undefined if not found.
   */
  getPrivateVar(key = "outputs") {
    return this.private?.ast.get(key);
  }
  /**
   * Clears a variable from the private AST (Abstract Syntax Tree) by key.
   *
   * @param key - The key of the variable to clear. Defaults to 'outputs'.
   * @returns The updated AST node.
   */
  clearPrivateVar(key = "outputs") {
    return this.private?.ast.remove(key);
  }
  get allScopes() {
    const res = [];
    if (this._public) {
      res.push(this._public);
    }
    if (this._private) {
      res.push(this._private);
    }
    return res;
  }
  getDefaultData() {
    return {};
  }
  initPrivate() {
    if (!this._private) {
      this._private = this.variableEngine.createScope(`${this.entity.id}_private`, {
        node: this.entity,
        type: "private" /* private */
      });
      this._private.coverScopes.forEach((_scope) => {
        _scope.refreshDeps();
      });
      this._private.depScopes.forEach((_scope) => {
        _scope.refreshCovers();
      });
      this._private.available.refresh();
      this.toDispose.push(this._private);
    }
    return this._private;
  }
};
FlowNodeVariableData.type = "FlowNodeVariableData";

// src/chains/free-layout-scope-chain.ts
import { inject, optional, postConstruct } from "inversify";
import { ScopeChain } from "@flowgram.ai/variable-core";
import { WorkflowNodeLinesData } from "@flowgram.ai/free-layout-core";
import { FlowDocument } from "@flowgram.ai/document";
import { EntityManager } from "@flowgram.ai/core";

// src/variable-layout-config.ts
var VariableLayoutConfig = Symbol("VariableLayoutConfig");

// src/scopes/global-scope.ts
import { injectable } from "inversify";
import { Scope, VariableEngine } from "@flowgram.ai/variable-core";
var GlobalScope = class extends Scope {
  static is(scope) {
    return scope.id === GlobalScope.ID;
  }
  setVar(arg1, arg2) {
    if (typeof arg1 === "string" && arg2 !== void 0) {
      return this.ast.set(arg1, arg2);
    }
    if (typeof arg1 === "object" && arg2 === void 0) {
      return this.ast.set("outputs", arg1);
    }
    throw new Error("Invalid arguments");
  }
  /**
   * Retrieves a variable from the Global Scope by key.
   *
   * @param key - The key of the variable to retrieve. Defaults to 'outputs'.
   * @returns The value of the variable, or undefined if not found.
   */
  getVar(key = "outputs") {
    return this.ast.get(key);
  }
  /**
   * Clears a variable from the Global Scope by key.
   *
   * @param key - The key of the variable to clear. Defaults to 'outputs'.
   * @returns The updated AST node.
   */
  clearVar(key = "outputs") {
    return this.ast.remove(key);
  }
};
GlobalScope.ID = Symbol("GlobalScope");
GlobalScope = __decorateClass([
  injectable()
], GlobalScope);
var bindGlobalScope = (bind) => {
  bind(GlobalScope).toDynamicValue((ctx) => {
    const variableEngine = ctx.container.get(VariableEngine);
    let scope = variableEngine.getScopeById(GlobalScope.ID);
    if (!scope) {
      scope = variableEngine.createScope(
        GlobalScope.ID,
        {},
        { ScopeConstructor: GlobalScope }
      );
      variableEngine.chain.refreshAllChange();
    }
    return scope;
  });
};

// src/chains/free-layout-scope-chain.ts
var FreeLayoutScopeChain = class extends ScopeChain {
  get tree() {
    return this.flowDocument.originTree;
  }
  onInit() {
    this.toDispose.pushAll([
      // 线条发生变化时，会触发作用域链的更新
      this.entityManager.onEntityDataChange(({ entityDataType }) => {
        if (entityDataType === WorkflowNodeLinesData.type) {
          this.refreshAllChange();
        }
      }),
      // 树变化时候刷新作用域
      this.tree.onTreeChange(() => {
        this.refreshAllChange();
      })
    ]);
  }
  // 获取同一层级所有输入节点
  getAllInputLayerNodes(curr) {
    return (curr.getData(WorkflowNodeLinesData)?.allInputNodes || []).filter(
      (_node) => _node.parent === curr.parent
    );
  }
  // 获取同一层级所有输出节点
  getAllOutputLayerNodes(curr) {
    return (curr.getData(WorkflowNodeLinesData)?.allOutputNodes || []).filter(
      (_node) => _node.parent === curr.parent
    );
  }
  getDeps(scope) {
    const { node } = scope.meta || {};
    if (!node) {
      return this.transformDeps([], { scope });
    }
    const deps = [];
    let curr = node;
    while (curr) {
      const allInputNodes = this.getAllInputLayerNodes(curr);
      deps.push(
        ...allInputNodes.map((_node) => _node.getData(FlowNodeVariableData).public).filter(Boolean)
      );
      const currVarData = curr.getData(FlowNodeVariableData);
      if (currVarData?.private && scope !== currVarData.private) {
        deps.push(currVarData.private);
      }
      curr = this.getParent(curr);
    }
    const globalScope = this.variableEngine.getScopeById(GlobalScope.ID);
    if (globalScope) {
      deps.unshift(globalScope);
    }
    const uniqDeps = Array.from(new Set(deps));
    return this.transformDeps(uniqDeps, { scope });
  }
  getCovers(scope) {
    if (GlobalScope.is(scope)) {
      return this.variableEngine.getAllScopes({ sort: true }).filter((_scope) => !GlobalScope.is(_scope));
    }
    const { node } = scope.meta || {};
    if (!node) {
      return this.transformCovers([], { scope });
    }
    const isPrivate = scope.meta.type === "private" /* private */;
    const queue = [];
    if (isPrivate) {
      queue.push(...this.getChildren(node));
    } else {
      queue.push(...this.getAllOutputLayerNodes(node) || []);
    }
    const scopes = [];
    while (queue.length) {
      const _node = queue.shift();
      const variableData = _node.getData(FlowNodeVariableData);
      scopes.push(...variableData.allScopes);
      const children = _node && this.getChildren(_node);
      if (children?.length) {
        queue.push(...children);
      }
    }
    const currentVariableData = node.getData(FlowNodeVariableData);
    if (isPrivate && currentVariableData.public) {
      scopes.push(currentVariableData.public);
    }
    const uniqScopes = Array.from(new Set(scopes));
    return this.transformCovers(uniqScopes, { scope });
  }
  transformCovers(covers, { scope }) {
    return this.configs?.transformCovers ? this.configs.transformCovers(covers, {
      scope,
      document: this.flowDocument,
      variableEngine: this.variableEngine
    }) : covers;
  }
  transformDeps(deps, { scope }) {
    return this.configs?.transformDeps ? this.configs.transformDeps(deps, {
      scope,
      document: this.flowDocument,
      variableEngine: this.variableEngine
    }) : deps;
  }
  getChildren(node) {
    if (this.configs?.getFreeChildren) {
      return this.configs.getFreeChildren?.(node);
    }
    const nodeMeta = node.getNodeMeta();
    const subCanvas = nodeMeta.subCanvas?.(node);
    if (subCanvas) {
      if (subCanvas.isCanvas) {
        return [];
      } else {
        return subCanvas.canvasNode.collapsedChildren;
      }
    }
    return this.tree.getChildren(node);
  }
  getParent(node) {
    if (this.configs?.getFreeParent) {
      return this.configs.getFreeParent(node);
    }
    const initParent = node.document.originTree.getParent(node);
    if (!initParent) {
      return initParent;
    }
    const nodeMeta = initParent.getNodeMeta();
    const subCanvas = nodeMeta.subCanvas?.(initParent);
    if (subCanvas?.isCanvas) {
      return subCanvas.parentNode;
    }
    return initParent;
  }
  sortAll() {
    console.warn("FreeLayoutScopeChain.sortAll is not implemented");
    return [];
  }
};
__decorateClass([
  inject(EntityManager)
], FreeLayoutScopeChain.prototype, "entityManager", 2);
__decorateClass([
  inject(FlowDocument)
], FreeLayoutScopeChain.prototype, "flowDocument", 2);
__decorateClass([
  optional(),
  inject(VariableLayoutConfig)
], FreeLayoutScopeChain.prototype, "configs", 2);
__decorateClass([
  postConstruct()
], FreeLayoutScopeChain.prototype, "onInit", 1);

// src/chains/fixed-layout-scope-chain.ts
import { inject as inject2, optional as optional2 } from "inversify";
import { ScopeChain as ScopeChain2 } from "@flowgram.ai/variable-core";
import { FlowDocument as FlowDocument2 } from "@flowgram.ai/document";
var FixedLayoutScopeChain = class extends ScopeChain2 {
  constructor(flowDocument, configs) {
    super();
    this.flowDocument = flowDocument;
    this.configs = configs;
    this.bindTree(flowDocument.originTree);
    this.toDispose.push(
      // REFRACTOR: onTreeChange 触发时机精细化
      flowDocument.originTree.onTreeChange(() => {
        this.refreshAllChange();
      })
    );
  }
  // 绑定树
  bindTree(tree) {
    this.tree = tree;
  }
  // 获取依赖作用域
  getDeps(scope) {
    if (!this.tree) {
      return this.transformDeps([], { scope });
    }
    const node = scope.meta.node;
    if (!node) {
      return this.transformDeps([], { scope });
    }
    const deps = [];
    let curr = node;
    while (curr) {
      const { parent, pre } = this.tree.getInfo(curr);
      const currData = this.getVariableData(curr);
      if (curr === node) {
        if (scope.meta.type === "public" /* public */ && currData?.private) {
          deps.unshift(currData.private);
        }
      } else if (this.hasChildren(curr) && !this.isNodeChildrenPrivate(curr)) {
        deps.unshift(
          ...this.getAllSortedChildScope(curr, {
            ignoreNodeChildrenPrivate: true
          })
        );
      }
      if (currData && curr !== node) {
        deps.unshift(currData.public);
      }
      if (pre) {
        curr = pre;
        continue;
      }
      if (parent) {
        let currParent = parent;
        let currParentPre = this.tree.getPre(currParent);
        while (currParent) {
          const currParentData = this.getVariableData(currParent);
          if (currParentData) {
            deps.unshift(...currParentData.allScopes);
          }
          if (currParentPre) {
            break;
          }
          currParent = this.tree.getParent(currParent);
          currParentPre = currParent ? this.tree.getPre(currParent) : void 0;
        }
        curr = currParentPre;
        continue;
      }
      curr = void 0;
    }
    const globalScope = this.variableEngine.getScopeById(GlobalScope.ID);
    if (globalScope) {
      deps.unshift(globalScope);
    }
    return this.transformDeps(deps, { scope });
  }
  // 获取覆盖作用域
  getCovers(scope) {
    if (!this.tree) {
      return this.transformCovers([], { scope });
    }
    if (GlobalScope.is(scope)) {
      return this.variableEngine.getAllScopes({ sort: true }).filter((_scope) => !GlobalScope.is(_scope));
    }
    const node = scope.meta.node;
    if (!node) {
      return this.transformCovers([], { scope });
    }
    const covers = [];
    if (scope.meta.type === "private" /* private */) {
      covers.push(
        ...this.getAllSortedChildScope(node, {
          addNodePrivateScope: true
        })
      );
      return this.transformCovers(covers, { scope });
    }
    let curr = node;
    while (curr) {
      const { next, parent } = this.tree.getInfo(curr);
      const currData = this.getVariableData(curr);
      if (curr !== node) {
        if (this.hasChildren(curr)) {
          covers.push(
            ...this.getAllSortedChildScope(curr, {
              addNodePrivateScope: true
            })
          );
        } else if (currData) {
          covers.push(...currData.allScopes);
        }
      }
      if (next) {
        curr = next;
        continue;
      }
      if (parent) {
        let currParent = parent;
        let currParentNext = this.tree.getNext(currParent);
        while (currParent) {
          if (this.isNodeChildrenPrivate(currParent)) {
            return this.transformCovers(covers, { scope });
          }
          if (currParentNext) {
            break;
          }
          currParent = this.tree.getParent(currParent);
          currParentNext = currParent ? this.tree.getNext(currParent) : void 0;
        }
        if (!currParentNext && currParent) {
          break;
        }
        curr = currParentNext;
        continue;
      }
      curr = void 0;
    }
    return this.transformCovers(covers, { scope });
  }
  transformCovers(covers, { scope }) {
    return this.configs?.transformCovers ? this.configs.transformCovers(covers, {
      scope,
      document: this.flowDocument,
      variableEngine: this.variableEngine
    }) : covers;
  }
  transformDeps(deps, { scope }) {
    return this.configs?.transformDeps ? this.configs.transformDeps(deps, {
      scope,
      document: this.flowDocument,
      variableEngine: this.variableEngine
    }) : deps;
  }
  // 排序所有作用域
  sortAll() {
    const startNode = this.flowDocument.getAllNodes().find((_node) => _node.isStart);
    if (!startNode) {
      return [];
    }
    const startVariableData = startNode.getData(FlowNodeVariableData);
    const startPublicScope = startVariableData.public;
    const deps = this.getDeps(startPublicScope);
    const covers = this.getCovers(startPublicScope).filter(
      (_scope) => !deps.includes(_scope) && _scope !== startPublicScope
    );
    return [...deps, startPublicScope, ...covers];
  }
  // 获取变量 Data 数据
  getVariableData(node) {
    if (node.flowNodeType === "virtualNode") {
      return;
    }
    if (node.id.startsWith("$")) {
      return;
    }
    return node.getData(FlowNodeVariableData);
  }
  // privateScope：子节点不可以被后续节点访问
  isNodeChildrenPrivate(node) {
    if (this.configs?.isNodeChildrenPrivate) {
      return node ? this.configs?.isNodeChildrenPrivate(node) : false;
    }
    const isSystemNode = node?.id.startsWith("$");
    return !isSystemNode && this.hasChildren(node);
  }
  hasChildren(node) {
    return Boolean(this.tree && node && this.tree.getChildren(node).length > 0);
  }
  // 子节点按照顺序进行排序（含自身）
  getAllSortedChildScope(node, {
    ignoreNodeChildrenPrivate,
    addNodePrivateScope
  } = {}) {
    const scopes = [];
    const variableData = this.getVariableData(node);
    if (variableData) {
      scopes.push(variableData.public);
    }
    if (ignoreNodeChildrenPrivate && this.isNodeChildrenPrivate(node)) {
      return scopes;
    }
    if (addNodePrivateScope && variableData?.private) {
      scopes.push(variableData.private);
    }
    const children = this.tree?.getChildren(node) || [];
    scopes.push(
      ...children.map(
        (child) => this.getAllSortedChildScope(child, { ignoreNodeChildrenPrivate, addNodePrivateScope })
      ).flat()
    );
    return scopes;
  }
};
FixedLayoutScopeChain = __decorateClass([
  __decorateParam(0, inject2(FlowDocument2)),
  __decorateParam(1, optional2()),
  __decorateParam(1, inject2(VariableLayoutConfig))
], FixedLayoutScopeChain);
export {
  FixedLayoutScopeChain,
  FlowNodeScopeTypeEnum as FlowNodeScopeType,
  FlowNodeVariableData,
  FreeLayoutScopeChain,
  GlobalScope,
  VariableLayoutConfig,
  bindGlobalScope
};
//# sourceMappingURL=index.js.map