import * as _flowgram_ai_utils from '@flowgram.ai/utils';
import { WorkflowNodeEntity } from '@flowgram.ai/free-layout-core';
import { FlowNodeTransformData } from '@flowgram.ai/document';
import * as _flowgram_ai_core from '@flowgram.ai/core';
import React, { FC, CSSProperties, ReactNode } from 'react';

declare enum NodeIntoContainerType {
    In = "in",
    Out = "out"
}

interface NodeIntoContainerState {
    isDraggingNode: boolean;
    isSkipEvent: boolean;
    transforms?: FlowNodeTransformData[];
    dragNode?: WorkflowNodeEntity;
    dropNode?: WorkflowNodeEntity;
    sourceParent?: WorkflowNodeEntity;
}
interface NodeIntoContainerEvent {
    type: NodeIntoContainerType;
    node: WorkflowNodeEntity;
    sourceContainer?: WorkflowNodeEntity;
    targetContainer: WorkflowNodeEntity;
}
interface WorkflowContainerPluginOptions {
    disableNodeIntoContainer?: boolean;
}

declare class NodeIntoContainerService {
    state: NodeIntoContainerState;
    private dragService;
    private document;
    private playgroundConfig;
    private operationService;
    private linesManager;
    private historyService;
    private selectService;
    private emitter;
    private toDispose;
    readonly on: _flowgram_ai_utils.Event<NodeIntoContainerEvent>;
    init(): void;
    ready(): void;
    dispose(): void;
    /** 将节点移出容器 */
    moveOutContainer(params: {
        node: WorkflowNodeEntity;
    }): Promise<void>;
    /** 能否将节点移出容器 */
    canMoveOutContainer(node: WorkflowNodeEntity): boolean;
    /** 移除节点所有非法连线 */
    clearInvalidLines(params: {
        dragNode?: WorkflowNodeEntity;
        sourceParent?: WorkflowNodeEntity;
    }): Promise<void>;
    /** 移除节点连线 */
    removeNodeLines(node: WorkflowNodeEntity): Promise<void>;
    /** 初始化状态 */
    private initState;
    /** 监听节点拖拽 */
    private listenDragToContainer;
    /** 监听节点拖拽出容器 */
    private dragOutContainer;
    /** 获取重叠位置 */
    private getCollisionTransform;
    /** 设置放置节点高亮 */
    private setDropNode;
    /** 获取容器节点transforms */
    private getContainerTransforms;
    /** 放置节点到容器 */
    private dropNodeToContainer;
    /** 拖拽节点 */
    private draggingNode;
    /** 判断能否将节点拖入容器 */
    protected canDropToContainer(params: {
        dragNode: WorkflowNodeEntity;
        dropNode?: WorkflowNodeEntity;
    }): boolean;
    /** 判断一个节点是否为另一个节点的父节点(向上查找直到根节点) */
    private isParent;
    /** 将节点移入容器 */
    private moveIntoContainer;
    /**
     * 如果存在容器节点，且传入鼠标坐标，需要用容器的坐标减去传入的鼠标坐标
     */
    private adjustSubNodePosition;
    private isContainer;
    /** 判断点是否在矩形内 */
    private isPointInRect;
    /** 判断两个矩形是否相交 */
    private isRectIntersects;
    private nextFrame;
}

declare const createContainerNodePlugin: _flowgram_ai_core.PluginCreator<WorkflowContainerPluginOptions>;

interface NodeSize {
    width: number;
    height: number;
}
declare const useNodeSize: () => NodeSize | undefined;

declare const useSyncNodeRenderSize: (nodeSize?: NodeSize) => void;

declare const SubCanvasBackground: FC;

interface ISubCanvasBorder$1 {
    style?: CSSProperties;
    children?: ReactNode | ReactNode[];
}
declare const SubCanvasBorder: FC<ISubCanvasBorder$1>;

interface ISubCanvasBorder {
    className?: string;
    style?: CSSProperties;
}
declare const SubCanvasRender: FC<ISubCanvasBorder>;

declare const SubCanvasTips: () => React.JSX.Element | null;

export { type NodeIntoContainerEvent, NodeIntoContainerService, type NodeIntoContainerState, NodeIntoContainerType, type NodeSize, SubCanvasBackground, SubCanvasBorder, SubCanvasRender, SubCanvasTips, type WorkflowContainerPluginOptions, createContainerNodePlugin, useNodeSize, useSyncNodeRenderSize };
