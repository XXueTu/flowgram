// src/core/tracker.ts
var Tracker;
((Tracker2) => {
  const _pendingComputations = [];
  const _afterFlushCallbacks = [];
  let _willFlush = false;
  let _inFlush = false;
  let _inCompute = false;
  let _currentComputation = void 0;
  let _throwFirstError = false;
  function _throwOrLog(msg, e) {
    if (_throwFirstError) {
      throw e;
    } else {
      console.error(`[Tracker error] ${msg}`, e);
    }
  }
  function _runFlush(options) {
    if (inFlush()) throw new Error("Can't call Tracker.flush while flushing");
    if (_inCompute) throw new Error("Can't flush inside Tracker.autorun");
    options = options || {};
    _inFlush = true;
    _willFlush = true;
    _throwFirstError = !!options.throwFirstError;
    var recomputedCount = 0;
    var finishedTry = false;
    try {
      while (_pendingComputations.length || _afterFlushCallbacks.length) {
        while (_pendingComputations.length) {
          var comp = _pendingComputations.shift();
          comp._recompute();
          if (comp._needsRecompute()) {
            _pendingComputations.unshift(comp);
          }
          if (!options.finishSynchronously && ++recomputedCount > 100) {
            finishedTry = true;
            return;
          }
        }
        if (_afterFlushCallbacks.length) {
          var func = _afterFlushCallbacks.shift();
          try {
            func();
          } catch (e) {
            _throwOrLog("afterFlush", e);
          }
        }
      }
      finishedTry = true;
    } finally {
      if (!finishedTry) {
        _inFlush = false;
        _runFlush({
          finishSynchronously: options.finishSynchronously,
          throwFirstError: false
        });
      }
      _willFlush = false;
      _inFlush = false;
      if (_pendingComputations.length || _afterFlushCallbacks.length) {
        if (options.finishSynchronously) {
          throw new Error("still have more to do?");
        }
        setTimeout(_requireFlush, 10);
      }
    }
  }
  function _requireFlush() {
    if (!_willFlush) {
      setTimeout(_runFlush, 0);
      _willFlush = true;
    }
  }
  function withComputation(computation, f) {
    let previousComputation = _currentComputation;
    _currentComputation = computation;
    try {
      return f.call(null, computation);
    } finally {
      _currentComputation = previousComputation;
    }
  }
  Tracker2.withComputation = withComputation;
  function withoutComputation(f) {
    let previousComputation = _currentComputation;
    _currentComputation = void 0;
    try {
      return f(void 0);
    } finally {
      _currentComputation = previousComputation;
    }
  }
  Tracker2.withoutComputation = withoutComputation;
  function isActive() {
    return !!_currentComputation;
  }
  Tracker2.isActive = isActive;
  function getCurrentComputation() {
    return _currentComputation;
  }
  Tracker2.getCurrentComputation = getCurrentComputation;
  function autorun(f, options) {
    var c = new Computation2(f, _currentComputation, options?.onError);
    if (isActive())
      Tracker2.onInvalidate(function() {
        c.stop();
      });
    return c;
  }
  Tracker2.autorun = autorun;
  function onInvalidate(f) {
    if (!_currentComputation) {
      throw new Error("Tracker.onInvalidate requires a currentComputation");
    }
    _currentComputation.onInvalidate(f);
  }
  Tracker2.onInvalidate = onInvalidate;
  function inFlush() {
    return _inFlush;
  }
  Tracker2.inFlush = inFlush;
  function flush(options) {
    _runFlush({
      finishSynchronously: true,
      throwFirstError: options && options.throwFirstError
    });
  }
  Tracker2.flush = flush;
  function afterFlush(f) {
    _afterFlushCallbacks.push(f);
    _requireFlush();
  }
  Tracker2.afterFlush = afterFlush;
  class Computation2 {
    constructor(_fn, parent, _onError) {
      this._fn = _fn;
      this.parent = parent;
      this._onError = _onError;
      this._onInvalidateCallbacks = [];
      this._onStopCallbacks = [];
      this._recomputing = false;
      /**
       * 是否停止
       */
      this.stopped = false;
      /**
       * 未开始执行则返回 false
       */
      this.invalidated = false;
      /**
       * 是否第一次执行
       */
      this.firstRun = true;
      let hasError = true;
      try {
        this._compute();
        hasError = false;
      } finally {
        this.firstRun = false;
        if (hasError) {
          this.stop();
        }
      }
    }
    onInvalidate(f) {
      if (this.invalidated) {
        withoutComputation(f.bind(null, this));
      } else {
        this._onInvalidateCallbacks.push(f);
      }
    }
    /**
     * @summary Invalidates this computation so that it will be rerun.
     */
    invalidate() {
      if (!this.invalidated) {
        if (!this._recomputing && !this.stopped) {
          _requireFlush();
          _pendingComputations.push(this);
        }
        this.invalidated = true;
        for (var i = 0, f; f = this._onInvalidateCallbacks[i]; i++) {
          withoutComputation(f.bind(null, this));
        }
        this._onInvalidateCallbacks = [];
      }
    }
    /**
     * @summary Prevents this computation from rerunning.
     * @locus Client
     */
    stop() {
      if (!this.stopped) {
        this.stopped = true;
        this.invalidate();
        for (let i = 0, f; f = this._onStopCallbacks[i]; i++) {
          withoutComputation(f.bind(null, this));
        }
        this._onStopCallbacks = [];
      }
    }
    onStop(f) {
      if (this.stopped) {
        withoutComputation(f.bind(null, this));
      } else {
        this._onStopCallbacks.push(f);
      }
    }
    _compute() {
      this.invalidated = false;
      var previousInCompute = _inCompute;
      _inCompute = true;
      try {
        this._result = Tracker2.withComputation(this, this._fn);
      } finally {
        _inCompute = previousInCompute;
      }
    }
    _needsRecompute() {
      return this.invalidated && !this.stopped;
    }
    _recompute() {
      this._recomputing = true;
      try {
        if (this._needsRecompute()) {
          try {
            this._compute();
          } catch (e) {
            if (this._onError) {
              this._onError(e);
            } else {
              _throwOrLog("recompute", e);
            }
          }
        }
      } finally {
        this._recomputing = false;
      }
    }
    /**
     * @summary Process the reactive updates for this computation immediately
     * and ensure that the computation is rerun. The computation is rerun only
     * if it is invalidated.
     */
    flush() {
      if (this._recomputing) return;
      this._recompute();
    }
    /**
     * @summary Causes the function inside this computation to run and
     * synchronously process all reactive updtes.
     * @locus Client
     */
    run() {
      this.invalidate();
      this.flush();
    }
    get result() {
      return this._result;
    }
  }
  Tracker2.Computation = Computation2;
  class Dependency3 {
    constructor() {
      this._dependents = /* @__PURE__ */ new Set();
    }
    /**
     * Declares that the current computation (or `fromComputation` if given) depends on `dependency`.  The computation will be invalidated the next time `dependency` changes.
     * If there is no current computation and `depend()` is called with no arguments, it does nothing and returns false.
     * Returns true if the computation is a new dependent of `dependency` rather than an existing one.
     */
    depend(computation) {
      if (!computation) {
        if (!isActive()) {
          return false;
        }
        computation = _currentComputation;
      }
      if (!this._dependents.has(computation)) {
        this._dependents.add(computation);
        computation.onInvalidate(() => {
          this._dependents.delete(computation);
        });
        return true;
      }
      return false;
    }
    /**
     * Invalidate all dependent computations immediately and remove them as dependents.
     */
    changed() {
      for (const dep of this._dependents) {
        dep.invalidate();
      }
    }
    /**
     * True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.
     */
    hasDependents() {
      return this._dependents.size !== 0;
    }
  }
  Tracker2.Dependency = Dependency3;
})(Tracker || (Tracker = {}));

// src/core/reactive-base-state.ts
var ReactiveBaseState = class {
  constructor(initialValue, opts) {
    this._dep = new Tracker.Dependency();
    this._isEqual = (a, b) => a == b;
    this._value = initialValue;
    if (opts?.isEqual) {
      this._isEqual = opts.isEqual;
    }
  }
  _addDepend(dep) {
    if (Tracker.isActive()) {
      dep.depend();
    }
  }
  hasDependents() {
    return this._dep.hasDependents();
  }
  get value() {
    this._addDepend(this._dep);
    return this._value;
  }
  set value(newValue) {
    if (!this._isEqual(this._value, newValue)) {
      this._value = newValue;
      this._dep.changed();
    }
  }
};

// src/utils/create-proxy.ts
function createProxy(target, opts) {
  let useProxy = "Proxy" in window;
  if (process.env.NODE_ENV === "test") {
    if (global.__ignoreProxy) {
      useProxy = false;
    }
  }
  if (useProxy) {
    return new Proxy(target, opts);
  }
  const result = {};
  for (const key in target) {
    Object.defineProperty(result, key, {
      enumerable: true,
      get: opts.get ? () => opts.get(target, key) : void 0,
      set: opts.set ? (newValue) => opts.set(target, key, newValue) : void 0
    });
  }
  return result;
}

// src/core/reactive-state.ts
var Dependency = Tracker.Dependency;
var ReactiveState = class extends ReactiveBaseState {
  constructor() {
    super(...arguments);
    this._keyDeps = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this._ensureKey(key);
    const oldValue = this._value[key];
    if (!this._isEqual(oldValue, value)) {
      this._value[key] = value;
      this._keyDeps.get(key).changed();
      return true;
    }
    return false;
  }
  get(key) {
    this._ensureKey(key);
    this._addDepend(this._keyDeps.get(key));
    return this._value[key];
  }
  _ensureKey(key) {
    if (!this._keyDeps.has(key)) {
      this._keyDeps.set(key, new Dependency());
    }
  }
  hasDependents() {
    if (this._dep.hasDependents()) return true;
    for (const dep of this._keyDeps.values()) {
      if (dep.hasDependents()) return true;
    }
    return false;
  }
  keys() {
    return Object.keys(this._value);
  }
  set value(newValue) {
    if (!this._isEqual(this._value, newValue)) {
      this._value = newValue;
      this._keyDeps.clear();
      this._dep.changed();
    }
  }
  get value() {
    this._addDepend(this._dep);
    if (!this._proxyValue) {
      this._proxyValue = createProxy(this._value, {
        get: (target, key) => this.get(key),
        set: (target, key, newValue) => {
          this.set(key, newValue);
          return true;
        }
      });
    }
    return this._proxyValue;
  }
  get readonlyValue() {
    this._addDepend(this._dep);
    if (!this._proxyReadonlyValue) {
      this._proxyReadonlyValue = createProxy(this._value, {
        get: (target, key) => this.get(key),
        set: (newValue, key) => {
          throw new Error(`[ReactiveState] Cannnot set readonly field "${key}"`);
        }
      });
    }
    return this._proxyReadonlyValue;
  }
};

// src/hooks/use-reactive-state.ts
import { useMemo as useMemo2 } from "react";

// src/hooks/use-observe.ts
import { useCallback, useEffect, useMemo } from "react";
import { useRefresh } from "@flowgram.ai/utils";
function useObserve(value) {
  const refresh = useRefresh();
  const computationMap = useMemo(() => /* @__PURE__ */ new Map(), []);
  const clear = useCallback(() => {
    computationMap.forEach((comp) => comp.stop());
    computationMap.clear();
  }, []);
  useEffect(() => clear, []);
  clear();
  return useMemo(() => {
    if (value === void 0) return {};
    return createProxy(value, {
      get(target, key) {
        let computation = computationMap.get(key);
        if (!computation) {
          computation = new Tracker.Computation((c) => {
            if (!c.firstRun) {
              refresh();
              return;
            }
            return value[key];
          });
          computationMap.set(key, computation);
        }
        return value[key];
      }
    });
  }, [value]);
}

// src/hooks/use-reactive-state.ts
function useReactiveState(v) {
  const state = useMemo2(
    () => v instanceof ReactiveState ? v : new ReactiveState(v),
    []
  );
  return useObserve(state.value);
}

// src/hooks/use-readonly-reactive-state.ts
function useReadonlyReactiveState(state) {
  return useObserve(state.readonlyValue);
}

// src/react/observe.tsx
import { useRef, useEffect as useEffect2 } from "react";
import { useRefresh as useRefresh2 } from "@flowgram.ai/utils";
function observe(fc) {
  return function ReactiveObserver(props) {
    const childrenRef = useRef();
    const computationRef = useRef();
    const refresh = useRefresh2();
    computationRef.current?.stop();
    computationRef.current = new Tracker.Computation((c) => {
      if (c.firstRun) {
        childrenRef.current = fc(props);
      } else {
        refresh();
      }
    });
    useEffect2(
      () => () => {
        computationRef.current?.stop();
      },
      []
    );
    return childrenRef.current;
  };
}

// src/index.ts
var { Dependency: Dependency2, Computation } = Tracker;
export {
  Computation,
  Dependency2 as Dependency,
  ReactiveBaseState,
  ReactiveState,
  Tracker,
  observe,
  useObserve,
  useReactiveState,
  useReadonlyReactiveState
};
//# sourceMappingURL=index.js.map