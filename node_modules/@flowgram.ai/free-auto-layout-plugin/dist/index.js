"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AutoLayoutService: () => AutoLayoutService,
  DagreGraph: () => import_graphlib10.Graph,
  Layout: () => Layout,
  createFreeAutoLayoutPlugin: () => createFreeAutoLayoutPlugin,
  dagreLib: () => dagreLib
});
module.exports = __toCommonJS(src_exports);

// src/dagre-lib/greedy-fas.js
var import_graphlib = require("@dagrejs/graphlib");

// src/dagre-lib/data/list.js
var List = class {
  constructor() {
    let sentinel = {};
    sentinel._next = sentinel._prev = sentinel;
    this._sentinel = sentinel;
  }
  dequeue() {
    let sentinel = this._sentinel;
    let entry = sentinel._prev;
    if (entry !== sentinel) {
      unlink(entry);
      return entry;
    }
  }
  enqueue(entry) {
    let sentinel = this._sentinel;
    if (entry._prev && entry._next) {
      unlink(entry);
    }
    entry._next = sentinel._next;
    sentinel._next._prev = entry;
    sentinel._next = entry;
    entry._prev = sentinel;
  }
  toString() {
    let strs = [];
    let sentinel = this._sentinel;
    let curr = sentinel._prev;
    while (curr !== sentinel) {
      strs.push(JSON.stringify(curr, filterOutLinks));
      curr = curr._prev;
    }
    return "[" + strs.join(", ") + "]";
  }
};
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}
var list_default = List;

// src/dagre-lib/greedy-fas.js
var greedy_fas_default = greedyFAS;
var DEFAULT_WEIGHT_FN = () => 1;
function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  let results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return results.flatMap((e) => g.outEdges(e.v, e.w));
}
function doGreedyFAS(g, buckets, zeroIdx) {
  let results = [];
  let sources = buckets[buckets.length - 1];
  let sinks = buckets[0];
  let entry;
  while (g.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    if (g.nodeCount()) {
      for (let i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  let results = collectPredecessors ? [] : void 0;
  g.inEdges(entry.v).forEach((edge) => {
    let weight = g.edge(edge);
    let uEntry = g.node(edge.v);
    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  g.outEdges(entry.v).forEach((edge) => {
    let weight = g.edge(edge);
    let w = edge.w;
    let wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g.removeNode(entry.v);
  return results;
}
function buildState(g, weightFn) {
  let fasGraph = new import_graphlib.Graph();
  let maxIn = 0;
  let maxOut = 0;
  g.nodes().forEach((v) => {
    fasGraph.setNode(v, { v, in: 0, out: 0 });
  });
  g.edges().forEach((e) => {
    let prevWeight = fasGraph.edge(e.v, e.w) || 0;
    let weight = weightFn(e);
    let edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
  });
  let buckets = range(maxOut + maxIn + 3).map(() => new list_default());
  let zeroIdx = maxIn + 1;
  fasGraph.nodes().forEach((v) => {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });
  return { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
function range(limit) {
  const range3 = [];
  for (let i = 0; i < limit; i++) {
    range3.push(i);
  }
  return range3;
}

// src/dagre-lib/util.js
var import_graphlib2 = require("@dagrejs/graphlib");
var util = {
  addBorderNode,
  addDummyNode,
  applyWithChunking,
  asNonCompoundGraph,
  buildLayerMatrix,
  intersectRect,
  mapValues,
  maxRank,
  normalizeRanks,
  notime,
  partition,
  pick,
  predecessorWeights,
  range: range2,
  removeEmptyRanks,
  simplify,
  successorWeights,
  time,
  uniqueId,
  zipObject
};
var util_default = util;
function addDummyNode(g, type, attrs, name) {
  let v;
  do {
    v = uniqueId(name);
  } while (g.hasNode(v));
  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}
function simplify(g) {
  let simplified = new import_graphlib2.Graph().setGraph(g.graph());
  g.nodes().forEach((v) => simplified.setNode(v, g.node(v)));
  g.edges().forEach((e) => {
    let simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    let label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g) {
  let simplified = new import_graphlib2.Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  g.nodes().forEach((v) => {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  g.edges().forEach((e) => {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}
function successorWeights(g) {
  let weightMap = g.nodes().map((v) => {
    let sucs = {};
    g.outEdges(v).forEach((e) => {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return zipObject(g.nodes(), weightMap);
}
function predecessorWeights(g) {
  let weightMap = g.nodes().map((v) => {
    let preds = {};
    g.inEdges(v).forEach((e) => {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return zipObject(g.nodes(), weightMap);
}
function intersectRect(rect, point) {
  let x = rect.x;
  let y = rect.y;
  let dx = point.x - x;
  let dy = point.y - y;
  let w = rect.width / 2;
  let h = rect.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  let sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }
  return { x: x + sx, y: y + sy };
}
function buildLayerMatrix(g) {
  let layering = range2(maxRank(g) + 1).map(() => []);
  g.nodes().forEach((v) => {
    let node = g.node(v);
    let rank2 = node.rank;
    if (rank2 !== void 0) {
      layering[rank2][node.order] = v;
    }
  });
  return layering;
}
function normalizeRanks(g) {
  let nodeRanks = g.nodes().map((v) => {
    let rank2 = g.node(v).rank;
    if (rank2 === void 0) {
      return Number.MAX_VALUE;
    }
    return rank2;
  });
  let min = applyWithChunking(Math.min, nodeRanks);
  g.nodes().forEach((v) => {
    let node = g.node(v);
    if (Object.hasOwn(node, "rank")) {
      node.rank -= min;
    }
  });
}
function removeEmptyRanks(g) {
  let nodeRanks = g.nodes().map((v) => g.node(v).rank);
  let offset = applyWithChunking(Math.min, nodeRanks);
  let layers = [];
  g.nodes().forEach((v) => {
    let rank2 = g.node(v).rank - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v);
  });
  let delta = 0;
  let nodeRankFactor = g.graph().nodeRankFactor;
  Array.from(layers).forEach((vs, i) => {
    if (vs === void 0 && i % nodeRankFactor !== 0) {
      --delta;
    } else if (vs !== void 0 && delta) {
      vs.forEach((v) => g.node(v).rank += delta);
    }
  });
}
function addBorderNode(g, prefix, rank2, order2) {
  let node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank2;
    node.order = order2;
  }
  return addDummyNode(g, "border", node, prefix);
}
function splitToChunks(array, chunkSize = CHUNKING_THRESHOLD) {
  const chunks = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    const chunk = array.slice(i, i + chunkSize);
    chunks.push(chunk);
  }
  return chunks;
}
var CHUNKING_THRESHOLD = 65535;
function applyWithChunking(fn, argsArray) {
  if (argsArray.length > CHUNKING_THRESHOLD) {
    const chunks = splitToChunks(argsArray);
    return fn.apply(
      null,
      chunks.map((chunk) => fn.apply(null, chunk))
    );
  } else {
    return fn.apply(null, argsArray);
  }
}
function maxRank(g) {
  const nodes = g.nodes();
  const nodeRanks = nodes.map((v) => {
    let rank2 = g.node(v).rank;
    if (rank2 === void 0) {
      return Number.MIN_VALUE;
    }
    return rank2;
  });
  return applyWithChunking(Math.max, nodeRanks);
}
function partition(collection, fn) {
  let result = { lhs: [], rhs: [] };
  collection.forEach((value) => {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}
function time(name, fn) {
  let start = Date.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (Date.now() - start) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}
function range2(start, limit, step = 1) {
  if (limit == null) {
    limit = start;
    start = 0;
  }
  let endCon = (i) => i < limit;
  if (step < 0) {
    endCon = (i) => limit < i;
  }
  const range3 = [];
  for (let i = start; endCon(i); i += step) {
    range3.push(i);
  }
  return range3;
}
function pick(source, keys) {
  const dest = {};
  for (const key of keys) {
    if (source[key] !== void 0) {
      dest[key] = source[key];
    }
  }
  return dest;
}
function mapValues(obj, funcOrProp) {
  let func = funcOrProp;
  if (typeof funcOrProp === "string") {
    func = (val) => val[funcOrProp];
  }
  return Object.entries(obj).reduce((acc, [k, v]) => {
    acc[k] = func(v, k);
    return acc;
  }, {});
}
function zipObject(props, values) {
  return props.reduce((acc, key, i) => {
    acc[key] = values[i];
    return acc;
  }, {});
}

// src/dagre-lib/acyclic.js
var acyclic = {
  run,
  undo
};
var acyclic_default = acyclic;
function run(g) {
  let fas = g.graph().acyclicer === "greedy" ? greedy_fas_default(g, weightFn(g)) : dfsFAS(g);
  fas.forEach((e) => {
    let label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, uniqueId("rev"));
  });
  function weightFn(g2) {
    return (e) => {
      return g2.edge(e).weight;
    };
  }
}
function dfsFAS(g) {
  let fas = [];
  let stack = {};
  let visited = {};
  function dfs2(v) {
    if (Object.hasOwn(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    g.outEdges(v).forEach((e) => {
      if (Object.hasOwn(stack, e.w)) {
        fas.push(e);
      } else {
        dfs2(e.w);
      }
    });
    delete stack[v];
  }
  g.nodes().forEach(dfs2);
  return fas;
}
function undo(g) {
  g.edges().forEach((e) => {
    let label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);
      let forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}

// src/dagre-lib/normalize.js
var normalize = {
  run: run2,
  undo: undo2
};
var normalize_default = normalize;
function run2(g) {
  g.graph().dummyChains = [];
  g.edges().forEach((edge) => normalizeEdge(g, edge));
}
function normalizeEdge(g, e) {
  let v = e.v;
  let vRank = g.node(v).rank;
  let w = e.w;
  let wRank = g.node(w).rank;
  let name = e.name;
  let edgeLabel = g.edge(e);
  let labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1) return;
  g.removeEdge(e);
  let dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel,
      edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }
  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}
function undo2(g) {
  g.graph().dummyChains.forEach((v) => {
    let node = g.node(v);
    let origLabel = node.edgeLabel;
    let w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}

// src/dagre-lib/rank/util.js
function longestPath(g) {
  var visited = {};
  function dfs2(v) {
    var label = g.node(v);
    if (Object.hasOwn(visited, v)) {
      return label.rank;
    }
    visited[v] = true;
    let outEdgesMinLens = g.outEdges(v).map((e) => {
      if (e == null) {
        return Number.POSITIVE_INFINITY;
      }
      return dfs2(e.w) - g.edge(e).minlen;
    });
    var rank2 = applyWithChunking(Math.min, outEdgesMinLens);
    if (rank2 === Number.POSITIVE_INFINITY) {
      rank2 = 0;
    }
    return label.rank = rank2;
  }
  g.sources().forEach(dfs2);
}
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}

// src/dagre-lib/rank/feasible-tree.js
var import_graphlib3 = require("@dagrejs/graphlib");
var feasible_tree_default = feasibleTree;
function feasibleTree(g) {
  var t = new import_graphlib3.Graph({ directed: false });
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});
  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }
  return t;
}
function tightTree(t, g) {
  function dfs2(v) {
    g.nodeEdges(v).forEach((e) => {
      var edgeV = e.v, w = v === edgeV ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs2(w);
      }
    });
  }
  t.nodes().forEach(dfs2);
  return t.nodeCount();
}
function findMinSlackEdge(t, g) {
  const edges = g.edges();
  return edges.reduce(
    (acc, edge) => {
      let edgeSlack = Number.POSITIVE_INFINITY;
      if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
        edgeSlack = slack(g, edge);
      }
      if (edgeSlack < acc[0]) {
        return [edgeSlack, edge];
      }
      return acc;
    },
    [Number.POSITIVE_INFINITY, null]
  )[1];
}
function shiftRanks(t, g, delta) {
  t.nodes().forEach((v) => g.node(v).rank += delta);
}

// src/dagre-lib/rank/network-simplex.js
var import_graphlib4 = require("@dagrejs/graphlib");
var { preorder, postorder } = import_graphlib4.alg;
var network_simplex_default = networkSimplex;
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;
function networkSimplex(g) {
  g = simplify(g);
  longestPath(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);
  var e, f;
  while (e = leaveEdge(t)) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  vs.forEach((v) => assignCutValue(t, g, v));
}
function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  var childIsTail = true;
  var graphEdge = g.edge(child, parent);
  var cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  g.nodeEdges(child).forEach((e) => {
    var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}
function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);
  visited[v] = true;
  tree.neighbors(v).forEach((w) => {
    if (!Object.hasOwn(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });
  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    delete label.parent;
  }
  return nextLim;
}
function leaveEdge(tree) {
  return tree.edges().find((e) => tree.edge(e).cutvalue < 0);
}
function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }
  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  var candidates = g.edges().filter((edge2) => {
    return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
  });
  return candidates.reduce((acc, edge2) => {
    if (slack(g, edge2) < slack(g, acc)) {
      return edge2;
    }
    return acc;
  });
}
function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}
function updateRanks(t, g) {
  var root = t.nodes().find((v) => !g.node(v).parent);
  var vs = preorder(t, root);
  vs = vs.slice(1);
  vs.forEach((v) => {
    var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }
    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}

// src/dagre-lib/rank/index.js
var rank_default = rank;
function rank(g) {
  switch (g.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g);
      break;
    case "tight-tree":
      tightTreeRanker(g);
      break;
    case "longest-path":
      longestPathRanker(g);
      break;
    default:
      networkSimplexRanker(g);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g) {
  longestPath(g);
  feasible_tree_default(g);
}
function networkSimplexRanker(g) {
  network_simplex_default(g);
}

// src/dagre-lib/parent-dummy-chains.js
var parent_dummy_chains_default = parentDummyChains;
function parentDummyChains(g) {
  let postorderNums = postorder2(g);
  g.graph().dummyChains.forEach((v) => {
    let node = g.node(v);
    let edgeObj = node.edgeObj;
    let pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    let path = pathData.path;
    let lca = pathData.lca;
    let pathIdx = 0;
    let pathV = path[pathIdx];
    let ascending = true;
    while (v !== edgeObj.w) {
      node = g.node(v);
      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending = false;
        }
      }
      if (!ascending) {
        while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }
      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}
function findPath(g, postorderNums, v, w) {
  let vPath = [];
  let wPath = [];
  let low = Math.min(postorderNums[v].low, postorderNums[w].low);
  let lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  let parent;
  let lca;
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder2(g) {
  let result = {};
  let lim = 0;
  function dfs2(v) {
    let low = lim;
    g.children(v).forEach(dfs2);
    result[v] = { low, lim: lim++ };
  }
  g.children().forEach(dfs2);
  return result;
}

// src/dagre-lib/nesting-graph.js
var nestingGraph = {
  run: run3,
  cleanup
};
var nesting_graph_default = nestingGraph;
function run3(g) {
  let root = util.addDummyNode(g, "root", {}, "_root");
  let depths = treeDepths(g);
  let depthsArr = Object.values(depths);
  let height = util.applyWithChunking(Math.max, depthsArr) - 1;
  let nodeSep = 2 * height + 1;
  g.graph().nestingRoot = root;
  g.edges().forEach((e) => g.edge(e).minlen *= nodeSep);
  let weight = sumWeights(g) + 1;
  g.children().forEach((child) => dfs(g, root, nodeSep, weight, height, depths, child));
  g.graph().nodeRankFactor = nodeSep;
}
function dfs(g, root, nodeSep, weight, height, depths, v) {
  let children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }
  let top = util.addBorderNode(g, "_bt");
  let bottom = util.addBorderNode(g, "_bb");
  let label = g.node(v);
  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;
  children.forEach((child) => {
    dfs(g, root, nodeSep, weight, height, depths, child);
    let childNode = g.node(child);
    let childTop = childNode.borderTop ? childNode.borderTop : child;
    let childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    let thisWeight = childNode.borderTop ? weight : 2 * weight;
    let minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
  });
  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}
function treeDepths(g) {
  var depths = {};
  function dfs2(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      children.forEach((child) => dfs2(child, depth + 1));
    }
    depths[v] = depth;
  }
  g.children().forEach((v) => dfs2(v, 1));
  return depths;
}
function sumWeights(g) {
  return g.edges().reduce((acc, e) => acc + g.edge(e).weight, 0);
}
function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  g.edges().forEach((e) => {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}

// src/dagre-lib/add-border-segments.js
var add_border_segments_default = addBorderSegments;
function addBorderSegments(g) {
  function dfs2(v) {
    let children = g.children(v);
    let node = g.node(v);
    if (children.length) {
      children.forEach(dfs2);
    }
    if (Object.hasOwn(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (let rank2 = node.minRank, maxRank2 = node.maxRank + 1; rank2 < maxRank2; ++rank2) {
        addBorderNode2(g, "borderLeft", "_bl", v, node, rank2);
        addBorderNode2(g, "borderRight", "_br", v, node, rank2);
      }
    }
  }
  g.children().forEach(dfs2);
}
function addBorderNode2(g, prop, prefix, sg, sgNode, rank2) {
  let label = { width: 0, height: 0, rank: rank2, borderType: prop };
  let prev = sgNode[prop][rank2 - 1];
  let curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank2] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}

// src/dagre-lib/coordinate-system.js
var coordinateSystem = {
  adjust,
  undo: undo3
};
var coordinate_system_default = coordinateSystem;
function adjust(g) {
  let rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}
function undo3(g) {
  let rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}
function swapWidthHeight(g) {
  g.nodes().forEach((v) => swapWidthHeightOne(g.node(v)));
  g.edges().forEach((e) => swapWidthHeightOne(g.edge(e)));
}
function swapWidthHeightOne(attrs) {
  let w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}
function reverseY(g) {
  g.nodes().forEach((v) => reverseYOne(g.node(v)));
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    edge.points.forEach(reverseYOne);
    if (Object.hasOwn(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g) {
  g.nodes().forEach((v) => swapXYOne(g.node(v)));
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    edge.points.forEach(swapXYOne);
    if (Object.hasOwn(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  let x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}

// src/dagre-lib/order/init-order.js
var init_order_default = initOrder;
function initOrder(g) {
  let visited = {};
  let simpleNodes = g.nodes().filter((v) => !g.children(v).length);
  let simpleNodesRanks = simpleNodes.map((v) => g.node(v).rank);
  let maxRank2 = util.applyWithChunking(Math.max, simpleNodesRanks);
  let layers = util.range(maxRank2 + 1).map(() => []);
  function dfs2(v) {
    if (visited[v]) return;
    visited[v] = true;
    let node = g.node(v);
    layers[node.rank].push(v);
    g.successors(v).forEach(dfs2);
  }
  let orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
  orderedVs.forEach(dfs2);
  return layers;
}

// src/dagre-lib/order/cross-count.js
var cross_count_default = crossCount;
function crossCount(g, layering) {
  let cc = 0;
  for (let i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
  }
  return cc;
}
function twoLayerCrossCount(g, northLayer, southLayer) {
  let southPos = zipObject(
    southLayer,
    southLayer.map((v, i) => i)
  );
  let southEntries = northLayer.flatMap((v) => {
    return g.outEdges(v).map((e) => {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }).sort((a, b) => a.pos - b.pos);
  });
  let firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  let treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  let tree = new Array(treeSize).fill(0);
  let cc = 0;
  southEntries.forEach((entry) => {
    let index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    let weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = index - 1 >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  });
  return cc;
}

// src/dagre-lib/order/barycenter.js
var barycenter_default = barycenter;
function barycenter(g, movable = []) {
  return movable.map((v) => {
    let inV = g.inEdges(v);
    if (!inV.length) {
      return { v };
    } else {
      let result = inV.reduce(
        (acc, e) => {
          let edge = g.edge(e), nodeU = g.node(e.v);
          return {
            sum: acc.sum + edge.weight * nodeU.order,
            weight: acc.weight + edge.weight
          };
        },
        { sum: 0, weight: 0 }
      );
      return {
        v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}

// src/dagre-lib/order/resolve-conflicts.js
var resolve_conflicts_default = resolveConflicts;
function resolveConflicts(entries, cg) {
  let mappedEntries = {};
  entries.forEach((entry, i) => {
    let tmp = mappedEntries[entry.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v],
      i
    };
    if (entry.barycenter !== void 0) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  cg.edges().forEach((e) => {
    let entryV = mappedEntries[e.v];
    let entryW = mappedEntries[e.w];
    if (entryV !== void 0 && entryW !== void 0) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });
  let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  let entries = [];
  function handleIn(vEntry) {
    return (uEntry) => {
      if (uEntry.merged) {
        return;
      }
      if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return (wEntry) => {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    let entry = sourceSet.pop();
    entries.push(entry);
    entry["in"].reverse().forEach(handleIn(entry));
    entry.out.forEach(handleOut(entry));
  }
  return entries.filter((entry) => !entry.merged).map((entry) => {
    return util_default.pick(entry, ["vs", "i", "barycenter", "weight"]);
  });
}
function mergeEntries(target, source) {
  let sum = 0;
  let weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}

// src/dagre-lib/order/sort.js
var sort_default = sort;
function sort(entries, biasRight) {
  let parts = util_default.partition(entries, (entry) => {
    return Object.hasOwn(entry, "barycenter");
  });
  let sortable = parts.lhs, unsortable = parts.rhs.sort((a, b) => b.i - a.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  sortable.forEach((entry) => {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  let result = { vs: vs.flat(true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index) {
  let last;
  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}
function compareWithBias(bias) {
  return (entryV, entryW) => {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}

// src/dagre-lib/order/sort-subgraph.js
var sort_subgraph_default = sortSubgraph;
function sortSubgraph(g, v, cg, biasRight) {
  let movable = g.children(v);
  let node = g.node(v);
  let bl = node ? node.borderLeft : void 0;
  let br = node ? node.borderRight : void 0;
  let subgraphs = {};
  if (bl) {
    movable = movable.filter((w) => w !== bl && w !== br);
  }
  let barycenters = barycenter_default(g, movable);
  barycenters.forEach((entry) => {
    if (g.children(entry.v).length) {
      let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (Object.hasOwn(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  let entries = resolve_conflicts_default(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  let result = sort_default(entries, biasRight);
  if (bl) {
    result.vs = [bl, result.vs, br].flat(true);
    if (g.predecessors(bl).length) {
      let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
      if (!Object.hasOwn(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  entries.forEach((entry) => {
    entry.vs = entry.vs.flatMap((v) => {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    });
  });
}
function mergeBarycenters(target, other) {
  if (target.barycenter !== void 0) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}

// src/dagre-lib/order/build-layer-graph.js
var import_graphlib5 = require("@dagrejs/graphlib");
var build_layer_graph_default = buildLayerGraph;
function buildLayerGraph(g, rank2, relationship) {
  let root = createRootNode(g), result = new import_graphlib5.Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel((v) => g.node(v));
  g.nodes().forEach((v) => {
    let node = g.node(v), parent = g.parent(v);
    if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);
      g[relationship](v).forEach((e) => {
        let u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = edge !== void 0 ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });
      if (Object.hasOwn(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank2],
          borderRight: node.borderRight[rank2]
        });
      }
    }
  });
  return result;
}
function createRootNode(g) {
  var v;
  while (g.hasNode(v = util.uniqueId("_root"))) ;
  return v;
}

// src/dagre-lib/order/add-subgraph-constraints.js
var add_subgraph_constraints_default = addSubgraphConstraints;
function addSubgraphConstraints(g, cg, vs) {
  let prev = {}, rootPrev;
  vs.forEach((v) => {
    let child = g.parent(v), parent, prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}

// src/dagre-lib/order/index.js
var import_graphlib6 = require("@dagrejs/graphlib");
var order_default = order;
function order(g, opts) {
  if (opts && typeof opts.customOrder === "function") {
    opts.customOrder(g, order);
    return;
  }
  let maxRank2 = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util.range(maxRank2 - 1, -1, -1), "outEdges");
  let layering = init_order_default(g);
  assignOrder(g, layering);
  if (opts && opts.disableOptimalOrderHeuristic) {
    return;
  }
  let bestCC = Number.POSITIVE_INFINITY, best;
  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
    layering = util.buildLayerMatrix(g);
    let cc = cross_count_default(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = Object.assign({}, layering);
      bestCC = cc;
    }
  }
  assignOrder(g, best);
}
function buildLayerGraphs(g, ranks, relationship) {
  return ranks.map(function(rank2) {
    return build_layer_graph_default(g, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  let cg = new import_graphlib6.Graph();
  layerGraphs.forEach(function(lg) {
    let root = lg.graph().root;
    let sorted = sort_subgraph_default(lg, root, cg, biasRight);
    sorted.vs.forEach((v, i) => lg.node(v).order = i);
    add_subgraph_constraints_default(lg, cg, sorted.vs);
  });
}
function assignOrder(g, layering) {
  Object.values(layering).forEach((layer) => layer.forEach((v, i) => g.node(v).order = i));
}

// src/dagre-lib/position/bk.js
var import_graphlib7 = require("@dagrejs/graphlib");
function findType1Conflicts(g, layering) {
  let conflicts = {};
  function visitLayer(prevLayer, layer) {
    let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
    layer.forEach((v, i) => {
      let w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
      if (w || v === lastNode) {
        layer.slice(scanPos, i + 1).forEach((scanNode) => {
          g.predecessors(scanNode).forEach((u) => {
            let uLabel = g.node(u), uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  layering.length && layering.reduce(visitLayer);
  return conflicts;
}
function findType2Conflicts(g, layering) {
  let conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    let v;
    util.range(southPos, southEnd).forEach((i) => {
      v = south[i];
      if (g.node(v).dummy) {
        g.predecessors(v).forEach((u) => {
          let uNode = g.node(u);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    let prevNorthPos = -1, nextNorthPos, southPos = 0;
    south.forEach((v, southLookahead) => {
      if (g.node(v).dummy === "border") {
        let predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  layering.length && layering.reduce(visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return g.predecessors(v).find((u) => g.node(u).dummy);
  }
}
function addConflict(conflicts, v, w) {
  if (v > w) {
    let tmp = v;
    v = w;
    w = tmp;
  }
  let conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}
function hasConflict(conflicts, v, w) {
  if (v > w) {
    let tmp = v;
    v = w;
    w = tmp;
  }
  return !!conflicts[v] && Object.hasOwn(conflicts[v], w);
}
function verticalAlignment(g, layering, conflicts, neighborFn) {
  let root = {}, align = {}, pos = {};
  layering.forEach((layer) => {
    layer.forEach((v, order2) => {
      root[v] = v;
      align[v] = v;
      pos[v] = order2;
    });
  });
  layering.forEach((layer) => {
    let prevIdx = -1;
    layer.forEach((v) => {
      let ws = neighborFn(v);
      if (ws.length) {
        ws = ws.sort((a, b) => pos[a] - pos[b]);
        let mp = (ws.length - 1) / 2;
        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          let w = ws[i];
          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });
  return { root, align };
}
function horizontalCompaction(g, layering, root, align, reverseSep) {
  let xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    let stack = blockG.nodes();
    let elem = stack.pop();
    let visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }
      elem = stack.pop();
    }
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce((acc, e) => {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }
  function pass2(elem) {
    let min = blockG.outEdges(elem).reduce((acc, e) => {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);
    let node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }
  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));
  Object.keys(align).forEach((v) => xs[v] = xs[root[v]]);
  return xs;
}
function buildBlockGraph(g, layering, root, reverseSep) {
  let blockGraph = new import_graphlib7.Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  layering.forEach((layer) => {
    let u;
    layer.forEach((v) => {
      let vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });
  return blockGraph;
}
function findSmallestWidthAlignment(g, xss) {
  return Object.values(xss).reduce(
    (currentMinAndXs, xs) => {
      let max = Number.NEGATIVE_INFINITY;
      let min = Number.POSITIVE_INFINITY;
      Object.entries(xs).forEach(([v, x]) => {
        let halfWidth = width(g, v) / 2;
        max = Math.max(x + halfWidth, max);
        min = Math.min(x - halfWidth, min);
      });
      const newMin = max - min;
      if (newMin < currentMinAndXs[0]) {
        currentMinAndXs = [newMin, xs];
      }
      return currentMinAndXs;
    },
    [Number.POSITIVE_INFINITY, null]
  )[1];
}
function alignCoordinates(xss, alignTo) {
  let alignToVals = Object.values(alignTo), alignToMin = util.applyWithChunking(Math.min, alignToVals), alignToMax = util.applyWithChunking(Math.max, alignToVals);
  ["u", "d"].forEach((vert) => {
    ["l", "r"].forEach((horiz) => {
      let alignment = vert + horiz, xs = xss[alignment];
      if (xs === alignTo) return;
      let xsVals = Object.values(xs);
      let delta = alignToMin - util.applyWithChunking(Math.min, xsVals);
      if (horiz !== "l") {
        delta = alignToMax - util.applyWithChunking(Math.max, xsVals);
      }
      if (delta) {
        xss[alignment] = util.mapValues(xs, (x) => x + delta);
      }
    });
  });
}
function balance(xss, align) {
  return util.mapValues(xss.ul, (num, v) => {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      let xs = Object.values(xss).map((xs2) => xs2[v]).sort((a, b) => a - b);
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX(g) {
  let layering = util.buildLayerMatrix(g);
  let conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
  let xss = {};
  let adjustedLayering;
  ["u", "d"].forEach((vert) => {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
    ["l", "r"].forEach((horiz) => {
      if (horiz === "r") {
        adjustedLayering = adjustedLayering.map((inner) => {
          return Object.values(inner).reverse();
        });
      }
      let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      let align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      let xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = util.mapValues(xs, (x) => -x);
      }
      xss[vert + horiz] = xs;
    });
  });
  let smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return (g, v, w) => {
    let vLabel = g.node(v);
    let wLabel = g.node(w);
    let sum = 0;
    let delta;
    sum += vLabel.width / 2;
    if (Object.hasOwn(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.width / 2;
    if (Object.hasOwn(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
}
function width(g, v) {
  return g.node(v).width;
}

// src/dagre-lib/position/index.js
var position_default = position;
function position(g) {
  g = util_default.asNonCompoundGraph(g);
  positionY(g);
  Object.entries(positionX(g)).forEach(([v, x]) => g.node(v).x = x);
}
function positionY(g) {
  let layering = util_default.buildLayerMatrix(g);
  let rankSep = g.graph().ranksep;
  let prevY = 0;
  layering.forEach((layer) => {
    const maxHeight = layer.reduce((acc, v) => {
      const height = g.node(v).height;
      if (acc > height) {
        return acc;
      } else {
        return height;
      }
    }, 0);
    layer.forEach((v) => g.node(v).y = prevY + maxHeight / 2);
    prevY += maxHeight + rankSep;
  });
}

// src/dagre-lib/layout.js
var import_graphlib8 = require("@dagrejs/graphlib");
function layout(g, opts) {
  let time2 = opts && opts.debugTiming ? util.time : util.notime;
  time2("layout", () => {
    let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g));
    time2("  runLayout", () => runLayout(layoutGraph, time2, opts));
    time2("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
  });
}
function runLayout(g, time2, opts) {
  time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g));
  time2("    removeSelfEdges", () => removeSelfEdges(g));
  time2("    acyclic", () => acyclic_default.run(g));
  time2("    nestingGraph.run", () => nesting_graph_default.run(g));
  time2("    rank", () => rank_default(util.asNonCompoundGraph(g)));
  time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g));
  time2("    removeEmptyRanks", () => removeEmptyRanks(g));
  time2("    nestingGraph.cleanup", () => nesting_graph_default.cleanup(g));
  time2("    normalizeRanks", () => normalizeRanks(g));
  time2("    assignRankMinMax", () => assignRankMinMax(g));
  time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g));
  time2("    normalize.run", () => normalize_default.run(g));
  time2("    parentDummyChains", () => parent_dummy_chains_default(g));
  time2("    addBorderSegments", () => add_border_segments_default(g));
  time2("    order", () => order_default(g, opts));
  time2("    insertSelfEdges", () => insertSelfEdges(g));
  time2("    adjustCoordinateSystem", () => coordinate_system_default.adjust(g));
  time2("    position", () => position_default(g));
  time2("    positionSelfEdges", () => positionSelfEdges(g));
  time2("    removeBorderNodes", () => removeBorderNodes(g));
  time2("    normalize.undo", () => normalize_default.undo(g));
  time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g));
  time2("    undoCoordinateSystem", () => coordinate_system_default.undo(g));
  time2("    translateGraph", () => translateGraph(g));
  time2("    assignNodeIntersects", () => assignNodeIntersects(g));
  time2("    reversePoints", () => reversePointsForReversedEdges(g));
  time2("    acyclic.undo", () => acyclic_default.undo(g));
}
function updateInputGraph(inputGraph, layoutGraph) {
  inputGraph.nodes().forEach((v) => {
    let inputLabel = inputGraph.node(v);
    let layoutLabel = layoutGraph.node(v);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      inputLabel.rank = layoutLabel.rank;
      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  inputGraph.edges().forEach((e) => {
    let inputLabel = inputGraph.edge(e);
    let layoutLabel = layoutGraph.edge(e);
    inputLabel.points = layoutLabel.points;
    if (Object.hasOwn(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  let g = new import_graphlib8.Graph({ multigraph: true, compound: true });
  let graph = canonicalize(inputGraph.graph());
  g.setGraph(
    Object.assign(
      {},
      graphDefaults,
      selectNumberAttrs(graph, graphNumAttrs),
      util.pick(graph, graphAttrs)
    )
  );
  inputGraph.nodes().forEach((v) => {
    let node = canonicalize(inputGraph.node(v));
    const newNode = selectNumberAttrs(node, nodeNumAttrs);
    Object.keys(nodeDefaults).forEach((k) => {
      if (newNode[k] === void 0) {
        newNode[k] = nodeDefaults[k];
      }
    });
    g.setNode(v, newNode);
    g.setParent(v, inputGraph.parent(v));
  });
  inputGraph.edges().forEach((e) => {
    let edge = canonicalize(inputGraph.edge(e));
    g.setEdge(
      e,
      Object.assign(
        {},
        edgeDefaults,
        selectNumberAttrs(edge, edgeNumAttrs),
        util.pick(edge, edgeAttrs)
      )
    );
  });
  return g;
}
function makeSpaceForEdgeLabels(g) {
  let graph = g.graph();
  graph.ranksep /= 2;
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}
function injectEdgeLabelProxies(g) {
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    if (edge.width && edge.height) {
      let v = g.node(e.v);
      let w = g.node(e.w);
      let label = { rank: (w.rank - v.rank) / 2 + v.rank, e };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}
function assignRankMinMax(g) {
  let maxRank2 = 0;
  g.nodes().forEach((v) => {
    let node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank2 = Math.max(maxRank2, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g) {
  g.nodes().forEach((v) => {
    let node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}
function translateGraph(g) {
  let minX = Number.POSITIVE_INFINITY;
  let maxX = 0;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = 0;
  let graphLabel = g.graph();
  let marginX = graphLabel.marginx || 0;
  let marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    let x = attrs.x;
    let y = attrs.y;
    let w = attrs.width;
    let h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }
  g.nodes().forEach((v) => getExtremes(g.node(v)));
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    if (Object.hasOwn(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  g.nodes().forEach((v) => {
    let node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    edge.points.forEach((p) => {
      p.x -= minX;
      p.y -= minY;
    });
    if (Object.hasOwn(edge, "x")) {
      edge.x -= minX;
    }
    if (Object.hasOwn(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g) {
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    let nodeV = g.node(e.v);
    let nodeW = g.node(e.w);
    let p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g) {
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    if (Object.hasOwn(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g) {
  g.edges().forEach((e) => {
    let edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g) {
  g.nodes().forEach((v) => {
    if (g.children(v).length) {
      let node = g.node(v);
      let t = g.node(node.borderTop);
      let b = g.node(node.borderBottom);
      let l = g.node(node.borderLeft[node.borderLeft.length - 1]);
      let r = g.node(node.borderRight[node.borderRight.length - 1]);
      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });
  g.nodes().forEach((v) => {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}
function removeSelfEdges(g) {
  g.edges().forEach((e) => {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}
function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  layers.forEach((layer) => {
    var orderShift = 0;
    layer.forEach((v, i) => {
      var node = g.node(v);
      node.order = i + orderShift;
      (node.selfEdges || []).forEach((selfEdge) => {
        util.addDummyNode(
          g,
          "selfedge",
          {
            width: selfEdge.label.width,
            height: selfEdge.label.height,
            rank: node.rank,
            order: i + ++orderShift,
            e: selfEdge.e,
            label: selfEdge.label
          },
          "_se"
        );
      });
      delete node.selfEdges;
    });
  });
}
function positionSelfEdges(g) {
  g.nodes().forEach((v) => {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x + dx, y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return util.mapValues(util.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  if (attrs) {
    Object.entries(attrs).forEach(([k, v]) => {
      if (typeof k === "string") {
        k = k.toLowerCase();
      }
      newAttrs[k] = v;
    });
  }
  return newAttrs;
}

// src/dagre-lib/index.js
var dagreLib = {
  layout,
  buildLayoutGraph,
  updateInputGraph,
  makeSpaceForEdgeLabels,
  removeSelfEdges,
  acyclic: acyclic_default,
  nestingGraph: nesting_graph_default,
  rank: rank_default,
  util,
  injectEdgeLabelProxies,
  removeEmptyRanks,
  normalizeRanks,
  assignRankMinMax,
  removeEdgeLabelProxies,
  normalize: normalize_default,
  parentDummyChains: parent_dummy_chains_default,
  addBorderSegments: add_border_segments_default,
  order: order_default,
  insertSelfEdges,
  coordinateSystem: coordinate_system_default,
  position: position_default,
  positionSelfEdges,
  removeBorderNodes,
  fixupEdgeLabelCoords,
  translateGraph,
  assignNodeIntersects,
  reversePointsForReversedEdges
};

// src/create-auto-layout-plugin.tsx
var import_core2 = require("@flowgram.ai/core");

// src/services.ts
var import_inversify = require("inversify");
var import_free_layout_core2 = require("@flowgram.ai/free-layout-core");

// src/layout/store.ts
var import_free_layout_core = require("@flowgram.ai/free-layout-core");
var import_document = require("@flowgram.ai/document");
var LayoutStore = class {
  constructor() {
    this.init = false;
  }
  get initialized() {
    return this.init;
  }
  getNode(id) {
    return this.store.nodes.get(id);
  }
  getNodeByIndex(index) {
    const id = this.indexMap.get(index);
    return id ? this.getNode(id) : void 0;
  }
  getEdge(id) {
    return this.store.edges.get(id);
  }
  get nodes() {
    return Array.from(this.store.nodes.values());
  }
  get edges() {
    return Array.from(this.store.edges.values());
  }
  create(params) {
    this.store = this.createStore(params);
    this.indexMap = this.createIndexMap();
    this.init = true;
  }
  /**  */
  createStore(params) {
    const { nodes, edges, container } = params;
    this.container = container;
    const layoutNodes = this.createLayoutNodes(nodes);
    const layoutEdges = this.createEdgesStore(edges);
    const virtualEdges = this.createVirtualEdges(params);
    const store = {
      nodes: /* @__PURE__ */ new Map(),
      edges: /* @__PURE__ */ new Map()
    };
    layoutNodes.forEach((node) => store.nodes.set(node.id, node));
    layoutEdges.concat(virtualEdges).forEach((edge) => store.edges.set(edge.id, edge));
    return store;
  }
  /**  */
  createLayoutNodes(nodes) {
    const layoutNodes = nodes.map((node, index) => {
      const { bounds } = node.getData(import_document.FlowNodeTransformData);
      const layoutNode = {
        id: node.id,
        entity: node,
        index: "",
        // index 
        rank: -1,
        // -1
        order: -1,
        // -1
        position: { x: bounds.center.x, y: bounds.center.y },
        offset: { x: 0, y: 0 },
        size: { width: bounds.width, height: bounds.height },
        hasChildren: node.collapsedChildren?.length > 0
      };
      return layoutNode;
    });
    return layoutNodes;
  }
  /**  */
  createEdgesStore(edges) {
    const layoutEdges = edges.map((edge) => {
      const { from, to } = edge.info;
      if (!from || !to || edge.vertical) {
        return;
      }
      const layoutEdge = {
        id: edge.id,
        entity: edge,
        from,
        to,
        fromIndex: "",
        // index 
        toIndex: "",
        // index 
        name: edge.id
      };
      return layoutEdge;
    }).filter(Boolean);
    return layoutEdges;
  }
  /**  */
  createVirtualEdges(params) {
    const { nodes, edges } = params;
    const groupNodes = nodes.filter((n) => n.flowNodeType === import_document.FlowNodeBaseType.GROUP);
    const virtualEdges = groupNodes.map((group) => {
      const { id: groupId, blocks = [] } = group;
      const blockIdSet = new Set(blocks.map((b) => b.id));
      const groupFromEdges = edges.filter((edge) => blockIdSet.has(edge.to?.id ?? "")).map((edge) => {
        const { from, to } = edge.info;
        if (!from || !to || edge.vertical) {
          return;
        }
        const id = `virtual_${groupId}_${to}`;
        const layoutEdge = {
          id,
          entity: edge,
          from,
          to: groupId,
          fromIndex: "",
          // index 
          toIndex: "",
          // index 
          name: id
        };
        return layoutEdge;
      }).filter(Boolean);
      const groupToEdges = edges.filter((edge) => blockIdSet.has(edge.from.id ?? "")).map((edge) => {
        const { from, to } = edge.info;
        if (!from || !to || edge.vertical) {
          return;
        }
        const id = `virtual_${groupId}_${from}`;
        const layoutEdge = {
          id,
          entity: edge,
          from: groupId,
          to,
          fromIndex: "",
          // index 
          toIndex: "",
          // index 
          name: id
        };
        return layoutEdge;
      }).filter(Boolean);
      return [...groupFromEdges, ...groupToEdges];
    }).flat();
    return virtualEdges;
  }
  /**  */
  createIndexMap() {
    const nodeIndexes = this.sortNodes();
    const nodeToIndex = /* @__PURE__ */ new Map();
    nodeIndexes.forEach((nodeId, nodeIndex) => {
      const node = this.getNode(nodeId);
      if (!node) {
        return;
      }
      const graphIndex = String(1e5 + nodeIndex);
      nodeToIndex.set(node.id, graphIndex);
      node.index = graphIndex;
    });
    this.edges.forEach((edge) => {
      const fromIndex = nodeToIndex.get(edge.from);
      const toIndex = nodeToIndex.get(edge.to);
      if (!fromIndex || !toIndex) {
        this.store.edges.delete(edge.id);
        return;
      }
      edge.fromIndex = fromIndex;
      edge.toIndex = toIndex;
    });
    const indexToNode = /* @__PURE__ */ new Map();
    nodeToIndex.forEach((index, id) => {
      indexToNode.set(index, id);
    });
    return indexToNode;
  }
  /**  */
  sortNodes() {
    const nodeIdList = [];
    this.nodes.forEach((node) => {
      nodeIdList.push(node.id);
    });
    this.edges.forEach((edge) => {
      nodeIdList.push(edge.to);
    });
    const visited = /* @__PURE__ */ new Set();
    const visit = (node) => {
      if (visited.has(node.id)) {
        return;
      }
      visited.add(node.id);
      nodeIdList.push(node.id);
      node.blocks.forEach((child) => {
        visit(child);
      });
      const { outputLines } = node.getData(import_free_layout_core.WorkflowNodeLinesData);
      const sortedLines = outputLines.sort((a, b) => {
        const aPort = a.fromPort;
        const bPort = b.fromPort;
        if (aPort && bPort) {
          return aPort.point.y - bPort.point.y;
        }
        return 0;
      });
      sortedLines.forEach((line) => {
        const { to } = line;
        if (!to) {
          return;
        }
        visit(to);
      });
    };
    visit(this.container);
    const uniqueNodeIds = nodeIdList.reduceRight((acc, nodeId) => {
      if (!acc.includes(nodeId)) {
        acc.unshift(nodeId);
      }
      return acc;
    }, []);
    return uniqueNodeIds;
  }
};

// src/layout/position.ts
var import_core = require("@flowgram.ai/core");
var LayoutPosition = class {
  constructor(store) {
    this.store = store;
  }
  async position() {
    return new Promise((resolve) => {
      (0, import_core.startTween)({
        from: { d: 0 },
        to: { d: 100 },
        duration: 300,
        onUpdate: (v) => {
          this.store.nodes.forEach((layoutNode) => {
            this.updateNodePosition({ layoutNode, step: v.d });
          });
        },
        onComplete: () => {
          resolve();
        }
      });
    });
  }
  updateNodePosition(params) {
    const { layoutNode, step } = params;
    const transform = layoutNode.entity.getData(import_core.TransformData);
    const position2 = {
      x: layoutNode.position.x + layoutNode.offset.x,
      y: layoutNode.position.y + layoutNode.offset.y
    };
    const deltaX = (position2.x - transform.position.x) * step / 100;
    const deltaY = (position2.y - transform.bounds.height / 2 - transform.position.y) * step / 100;
    transform.update({
      position: {
        x: transform.position.x + deltaX,
        y: transform.position.y + deltaY
      }
    });
    const document = layoutNode.entity.document;
    document.layout.updateAffectedTransform(layoutNode.entity);
  }
};

// src/layout/dagre.ts
var import_document2 = require("@flowgram.ai/document");
var import_graphlib9 = require("@dagrejs/graphlib");

// src/layout/constant.ts
var DagreLayoutOptions = {
  rankdir: "LR",
  nodesep: 100,
  ranksep: 100,
  ranker: "network-simplex"
};

// src/layout/dagre.ts
var DagreLayout = class {
  constructor(store) {
    this.store = store;
    this.graph = this.createGraph();
  }
  layout() {
    this.graphSetData();
    this.dagreLayout();
    this.layoutSetPosition();
  }
  dagreLayout() {
    let layoutGraph = dagreLib.buildLayoutGraph(this.graph);
    this.runLayout(layoutGraph);
    dagreLib.updateInputGraph(this.graph, layoutGraph);
  }
  runLayout(graph) {
    dagreLib.makeSpaceForEdgeLabels(graph);
    dagreLib.removeSelfEdges(graph);
    dagreLib.acyclic.run(graph);
    dagreLib.nestingGraph.run(graph);
    dagreLib.rank(dagreLib.util.asNonCompoundGraph(graph));
    dagreLib.injectEdgeLabelProxies(graph);
    dagreLib.removeEmptyRanks(graph);
    dagreLib.nestingGraph.cleanup(graph);
    dagreLib.normalizeRanks(graph);
    dagreLib.assignRankMinMax(graph);
    dagreLib.removeEdgeLabelProxies(graph);
    dagreLib.normalize.run(graph);
    dagreLib.parentDummyChains(graph);
    dagreLib.addBorderSegments(graph);
    dagreLib.order(graph);
    this.setOrderAndRank(graph);
    dagreLib.insertSelfEdges(graph);
    dagreLib.coordinateSystem.adjust(graph);
    dagreLib.position(graph);
    dagreLib.positionSelfEdges(graph);
    dagreLib.removeBorderNodes(graph);
    dagreLib.normalize.undo(graph);
    dagreLib.fixupEdgeLabelCoords(graph);
    dagreLib.coordinateSystem.undo(graph);
    dagreLib.translateGraph(graph);
    dagreLib.assignNodeIntersects(graph);
    dagreLib.reversePointsForReversedEdges(graph);
    dagreLib.acyclic.undo(graph);
  }
  createGraph() {
    const graph = new import_graphlib9.Graph({ multigraph: true });
    graph.setDefaultEdgeLabel(() => ({}));
    graph.setGraph(DagreLayoutOptions);
    return graph;
  }
  graphSetData() {
    const nodes = Array.from(this.store.nodes.values());
    const edges = Array.from(this.store.edges.values()).sort((next, prev) => {
      if (next.fromIndex === prev.fromIndex) {
        return next.toIndex < prev.toIndex ? -1 : 1;
      }
      return next.fromIndex < prev.fromIndex ? -1 : 1;
    });
    nodes.forEach((layoutNode) => {
      this.graph.setNode(layoutNode.index, {
        originID: layoutNode.id,
        width: layoutNode.size.width,
        height: layoutNode.size.height
      });
    });
    edges.forEach((layoutEdge) => {
      this.graph.setEdge({
        v: layoutEdge.fromIndex,
        w: layoutEdge.toIndex,
        name: layoutEdge.name
      });
    });
  }
  layoutSetPosition() {
    this.store.nodes.forEach((layoutNode) => {
      const offsetX = this.getOffsetX(layoutNode);
      const graphNode = this.graph.node(layoutNode.index);
      if (!graphNode) {
        layoutNode.rank = -1;
        layoutNode.position = {
          x: layoutNode.position.x + offsetX,
          y: layoutNode.position.y
        };
        return;
      }
      layoutNode.rank = graphNode.rank ?? -1;
      layoutNode.position = {
        x: this.normalizeNumber(graphNode.x) + offsetX,
        y: this.normalizeNumber(graphNode.y)
      };
    });
  }
  normalizeNumber(number) {
    return Number.isNaN(number) ? 0 : number;
  }
  getOffsetX(layoutNode) {
    if (!layoutNode.hasChildren) {
      return 0;
    }
    const nodeTransform = layoutNode.entity.getData(import_document2.FlowNodeTransformData);
    const { bounds, padding } = nodeTransform;
    const leftOffset = -bounds.width / 2 + padding.left;
    return leftOffset;
  }
  setOrderAndRank(g) {
    this.followAdjust(g);
    this.normalizeOrder(g);
    return g;
  }
  /**  */
  followAdjust(g) {
    const rankGroup = this.rankGroup(g);
    g.nodes().forEach((i) => {
      const graphNode = g.node(i);
      const layoutNode = this.store.getNodeByIndex(i);
      if (!graphNode || !layoutNode?.followedBy) return;
      const { followedBy } = layoutNode;
      const { rank: targetRank, order: targetOrder } = graphNode;
      const followIndexes = followedBy.map((id) => this.store.getNode(id)?.index).filter(Boolean);
      const followSet = new Set(followIndexes);
      const rankIndexes = rankGroup.get(targetRank);
      if (!rankIndexes) return;
      const afterIndexes = Array.from(rankIndexes).filter((index) => {
        if (followSet.has(index)) return false;
        const graphNode2 = g.node(index);
        return graphNode2.order > targetOrder;
      });
      afterIndexes.forEach((index) => {
        const graphNode2 = g.node(index);
        graphNode2.order = graphNode2.order + followedBy.length;
      });
      followIndexes.forEach((followIndex, index) => {
        const graphNode2 = g.node(followIndex);
        graphNode2.order = targetOrder + index + 1;
        const originRank = graphNode2.rank;
        graphNode2.rank = targetRank;
        rankGroup.get(originRank)?.delete(followIndex);
        rankGroup.get(targetRank)?.add(followIndex);
      });
    });
  }
  /** rank  order  */
  normalizeOrder(g) {
    const rankGroup = this.rankGroup(g);
    rankGroup.forEach((indexSet, rank2) => {
      const graphNodes = Array.from(indexSet).map((id) => g.node(id));
      graphNodes.sort((a, b) => a.order - b.order);
      graphNodes.forEach((node, index) => {
        node.order = index;
      });
    });
  }
  /**  rank  */
  rankGroup(g) {
    const rankGroup = /* @__PURE__ */ new Map();
    g.nodes().forEach((i) => {
      const graphNode = g.node(i);
      const rank2 = graphNode.rank;
      if (!rankGroup.has(rank2)) {
        rankGroup.set(rank2, /* @__PURE__ */ new Set());
      }
      rankGroup.get(rank2)?.add(i);
    });
    return rankGroup;
  }
};

// src/layout/layout.ts
var Layout = class {
  constructor() {
    this._store = new LayoutStore();
    this._layout = new DagreLayout(this._store);
    this._position = new LayoutPosition(this._store);
  }
  init(params, options = {}) {
    this._store.create(params);
    this.setFollowNode(options.getFollowNode);
  }
  layout() {
    if (!this._store.initialized) {
      return;
    }
    this._layout.layout();
  }
  async position() {
    if (!this._store.initialized) {
      return;
    }
    return await this._position.position();
  }
  setFollowNode(getFollowNode) {
    if (!getFollowNode) return;
    const context = { store: this._store };
    this._store.nodes.forEach((node) => {
      const followTo = getFollowNode(node, context)?.followTo;
      if (!followTo) return;
      const followToNode = this._store.getNode(followTo);
      if (!followToNode) return;
      if (!followToNode.followedBy) {
        followToNode.followedBy = [];
      }
      followToNode.followedBy.push(node.id);
      node.followTo = followTo;
    });
  }
};

// src/services.ts
var AutoLayoutService = class {
  async layout(options = {}) {
    await this.layoutNode(this.document.root, options);
  }
  async layoutNode(node, options) {
    const nodes = node.blocks;
    if (!nodes || !Array.isArray(nodes) || !nodes.length) {
      return;
    }
    const edges = this.getNodesAllLines(nodes);
    await Promise.all(nodes.map(async (child) => this.layoutNode(child, options)));
    const layout2 = new Layout();
    layout2.init({ nodes, edges, container: node }, options);
    layout2.layout();
    await layout2.position();
  }
  getNodesAllLines(nodes) {
    const lines = nodes.map((node) => {
      const linesData = node.getData(import_free_layout_core2.WorkflowNodeLinesData);
      const outputLines = linesData.outputLines.filter(Boolean);
      const inputLines = linesData.inputLines.filter(Boolean);
      return [...outputLines, ...inputLines];
    }).flat();
    return lines;
  }
};
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowDocument)
], AutoLayoutService.prototype, "document", 2);
AutoLayoutService = __decorateClass([
  (0, import_inversify.injectable)()
], AutoLayoutService);

// src/create-auto-layout-plugin.tsx
var createFreeAutoLayoutPlugin = (0, import_core2.definePluginCreator)({
  onBind: ({ bind }) => {
    bind(AutoLayoutService).toSelf().inSingletonScope();
  }
});

// src/index.ts
var import_graphlib10 = require("@dagrejs/graphlib");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AutoLayoutService,
  DagreGraph,
  Layout,
  createFreeAutoLayoutPlugin,
  dagreLib
});
//# sourceMappingURL=index.js.map