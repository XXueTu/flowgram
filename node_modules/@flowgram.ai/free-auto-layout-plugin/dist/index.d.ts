import { Graph } from '@dagrejs/graphlib';
export { Graph as DagreGraph } from '@dagrejs/graphlib';
import * as _flowgram_ai_core from '@flowgram.ai/core';
import { WorkflowNodeEntity, WorkflowLineEntity } from '@flowgram.ai/free-layout-core';

declare function layout(g: any, opts: any): void;
declare function buildLayoutGraph(inputGraph: any): Graph;
declare function updateInputGraph(inputGraph: any, layoutGraph: any): void;
declare function makeSpaceForEdgeLabels(g: any): void;
declare function removeSelfEdges(g: any): void;
declare function injectEdgeLabelProxies(g: any): void;
declare function assignRankMinMax(g: any): void;
declare function removeEdgeLabelProxies(g: any): void;
declare function insertSelfEdges(g: any): void;
declare function positionSelfEdges(g: any): void;
declare function removeBorderNodes(g: any): void;
declare function fixupEdgeLabelCoords(g: any): void;
declare function translateGraph(g: any): void;
declare function assignNodeIntersects(g: any): void;
declare function reversePointsForReversedEdges(g: any): void;

declare namespace acyclic {
    export { run$2 as run };
    export { undo$2 as undo };
}

declare function run$2(g: any): void;
declare function undo$2(g: any): void;

declare namespace nestingGraph {
    export { run$1 as run };
    export { cleanup };
}

declare function run$1(g: any): void;
declare function cleanup(g: any): void;

declare function rank(g: any): void;

declare namespace util {
    export { addBorderNode };
    export { addDummyNode };
    export { applyWithChunking };
    export { asNonCompoundGraph };
    export { buildLayerMatrix };
    export { intersectRect };
    export { mapValues };
    export { maxRank };
    export { normalizeRanks };
    export { notime };
    export { partition };
    export { pick };
    export { predecessorWeights };
    export { range };
    export { removeEmptyRanks };
    export { simplify };
    export { successorWeights };
    export { time };
    export { uniqueId };
    export { zipObject };
}
declare function addBorderNode(g: any, prefix: any, rank: any, order: any, ...args: any[]): string;
declare function addDummyNode(g: any, type: any, attrs: any, name: any): string;
declare function applyWithChunking(fn: any, argsArray: any): any;
declare function asNonCompoundGraph(g: any): Graph;
declare function buildLayerMatrix(g: any): never[][];
declare function intersectRect(rect: any, point: any): {
    x: any;
    y: any;
};
declare function mapValues(obj: any, funcOrProp: any): {};
declare function maxRank(g: any): any;
declare function normalizeRanks(g: any): void;
declare function notime(name: any, fn: any): any;
declare function partition(collection: any, fn: any): {
    lhs: never[];
    rhs: never[];
};
declare function pick(source: any, keys: any): {};
declare function predecessorWeights(g: any): any;
declare function range(start: any, limit: any, step?: number): any[];
declare function removeEmptyRanks(g: any): void;
declare function simplify(g: any): Graph;
declare function successorWeights(g: any): any;
declare function time(name: any, fn: any): any;
declare function uniqueId(prefix: any): string;
declare function zipObject(props: any, values: any): any;

declare namespace normalize {
    export { run };
    export { undo$1 as undo };
}

declare function run(g: any): void;
declare function undo$1(g: any): void;

declare function parentDummyChains(g: any): void;

declare function addBorderSegments(g: any): void;

declare function order(g: any, opts: any): void;

declare namespace coordinateSystem {
    export { adjust };
    export { undo };
}

declare function adjust(g: any): void;
declare function undo(g: any): void;

declare function position(g: any): void;

declare namespace dagreLib {
    export { layout };
    export { buildLayoutGraph };
    export { updateInputGraph };
    export { makeSpaceForEdgeLabels };
    export { removeSelfEdges };
    export { acyclic };
    export { nestingGraph };
    export { rank };
    export { util };
    export { injectEdgeLabelProxies };
    export { removeEmptyRanks };
    export { normalizeRanks };
    export { assignRankMinMax };
    export { removeEdgeLabelProxies };
    export { normalize };
    export { parentDummyChains };
    export { addBorderSegments };
    export { order };
    export { insertSelfEdges };
    export { coordinateSystem };
    export { position };
    export { positionSelfEdges };
    export { removeBorderNodes };
    export { fixupEdgeLabelCoords };
    export { translateGraph };
    export { assignNodeIntersects };
    export { reversePointsForReversedEdges };
}

declare const createFreeAutoLayoutPlugin: _flowgram_ai_core.PluginCreator<unknown>;

declare class LayoutStore {
    private indexMap;
    private init;
    private store;
    private container;
    get initialized(): boolean;
    getNode(id: string): LayoutNode | undefined;
    getNodeByIndex(index: string): LayoutNode | undefined;
    getEdge(id: string): LayoutEdge | undefined;
    get nodes(): LayoutNode[];
    get edges(): LayoutEdge[];
    create(params: LayoutParams): void;
    /** 创建布局数据 */
    private createStore;
    /** 创建节点布局数据 */
    private createLayoutNodes;
    /** 创建线条布局数据 */
    private createEdgesStore;
    /** 创建虚拟线条数据 */
    private createVirtualEdges;
    /** 创建节点索引映射 */
    private createIndexMap;
    /** 节点排序 */
    private sortNodes;
}

interface LayoutNode {
    id: string;
    /** 节点索引 */
    index: string;
    /** 节点实体 */
    entity: WorkflowNodeEntity;
    /** 层级 */
    rank: number;
    /** 顺序 */
    order: number;
    /** 位置 */
    position: {
        x: number;
        y: number;
    };
    /** 偏移量 */
    offset: {
        x: number;
        y: number;
    };
    /** 宽高 */
    size: {
        width: number;
        height: number;
    };
    /** 是否存在子节点 */
    hasChildren: boolean;
    /** 被跟随节点 */
    followedBy?: string[];
    /** 跟随节点 */
    followTo?: string;
}
interface LayoutEdge {
    id: string;
    /** 线条实体 */
    entity: WorkflowLineEntity;
    /** 起点 */
    from: string;
    /** 终点 */
    to: string;
    /** 起点索引 */
    fromIndex: string;
    /** 终点索引 */
    toIndex: string;
    /** 线条名称 */
    name: string;
}
interface LayoutParams {
    nodes: WorkflowNodeEntity[];
    edges: WorkflowLineEntity[];
    container: WorkflowNodeEntity;
}
interface LayoutOptions {
    getFollowNode?: GetFollowNode;
}
type GetFollowNode = (node: LayoutNode, context: {
    store: LayoutStore;
    /** 业务自定义参数 */
    [key: string]: any;
}) => {
    followTo?: string;
} | undefined;

declare class Layout {
    private readonly _store;
    private readonly _layout;
    private readonly _position;
    constructor();
    init(params: LayoutParams, options?: LayoutOptions): void;
    layout(): void;
    position(): Promise<void>;
    setFollowNode(getFollowNode?: GetFollowNode): void;
}

declare class AutoLayoutService {
    private readonly document;
    layout(options?: LayoutOptions): Promise<void>;
    private layoutNode;
    private getNodesAllLines;
}

export { AutoLayoutService, type GetFollowNode, Layout, type LayoutEdge, type LayoutNode, type LayoutOptions, LayoutStore, createFreeAutoLayoutPlugin, dagreLib };
