"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HistoryConfig: () => HistoryConfig,
  HistoryContainerModule: () => HistoryContainerModule,
  HistoryContext: () => HistoryContext,
  HistoryManager: () => HistoryManager,
  HistoryMergeEventType: () => HistoryMergeEventType,
  HistoryService: () => HistoryService,
  HistoryStack: () => HistoryStack,
  HistoryStackChangeType: () => HistoryStackChangeType,
  OperationContribution: () => OperationContribution,
  OperationRegistry: () => OperationRegistry,
  OperationService: () => OperationService,
  StackOperation: () => StackOperation,
  UndoRedoChangeType: () => UndoRedoChangeType,
  UndoRedoService: () => UndoRedoService,
  createHistoryPlugin: () => createHistoryPlugin
});
module.exports = __toCommonJS(src_exports);

// src/operation/operation-contribution.ts
var OperationContribution = Symbol("OperationContribution");

// src/operation/operation-registry.ts
var import_inversify = require("inversify");
var import_utils = require("@flowgram.ai/utils");
var OperationRegistry = class {
  constructor() {
    this._operationMetas = /* @__PURE__ */ new Map();
    this.contributions = [];
  }
  init() {
    for (const contrib of this.contributions) {
      contrib.registerOperationMeta?.(this);
    }
  }
  /**
   * 注册操作的元数据
   * @param operationMeta 操作的元数据
   * @returns 销毁函数
   */
  registerOperationMeta(operationMeta) {
    if (this._operationMetas.has(operationMeta.type)) {
      console.warn(`A operation meta ${operationMeta.type} is already registered.`);
      return import_utils.Disposable.NULL;
    }
    const toDispose = new import_utils.DisposableCollection(this._doRegisterOperationMetaMeta(operationMeta));
    return toDispose;
  }
  /**
   * 获取操作的元数据
   * @param type 操作类型
   * @returns 操作的元数据
   */
  getOperationMeta(type) {
    return this._operationMetas.get(type);
  }
  _doRegisterOperationMetaMeta(operationMeta) {
    this._operationMetas.set(operationMeta.type, operationMeta);
    return {
      dispose: () => {
        this._operationMetas.delete(operationMeta.type);
      }
    };
  }
};
__decorateClass([
  (0, import_inversify.multiInject)(OperationContribution),
  (0, import_inversify.optional)()
], OperationRegistry.prototype, "contributions", 2);
__decorateClass([
  (0, import_inversify.postConstruct)()
], OperationRegistry.prototype, "init", 1);
OperationRegistry = __decorateClass([
  (0, import_inversify.injectable)()
], OperationRegistry);

// src/operation/operation-service.ts
var import_inversify4 = require("inversify");
var import_utils2 = require("@flowgram.ai/utils");

// src/history-context.ts
var import_inversify2 = require("inversify");
var HistoryContext = class {
};
HistoryContext = __decorateClass([
  (0, import_inversify2.injectable)()
], HistoryContext);

// src/history-config.ts
var import_nanoid = require("nanoid");
var import_inversify3 = require("inversify");
var HistoryConfig = class {
  constructor() {
    this.generateId = () => (0, import_nanoid.nanoid)();
    this.getSnapshot = () => "";
  }
};
HistoryConfig = __decorateClass([
  (0, import_inversify3.injectable)()
], HistoryConfig);

// src/operation/operation-service.ts
var OperationService = class {
  constructor() {
    this.applyEmitter = new import_utils2.Emitter();
    this.onApply = this.applyEmitter.event;
    this._toDispose = new import_utils2.DisposableCollection();
  }
  init() {
    this._toDispose.push(this.applyEmitter);
  }
  /**
   * 执行操作
   * @param op
   * @returns
   */
  applyOperation(op, options) {
    const meta = this.operationRegistry.getOperationMeta(op.type);
    if (!meta) {
      throw new Error(`Operation meta ${op.type} has not registered.`);
    }
    let res;
    if (!options?.noApply) {
      res = meta.apply(op, this.context.source);
    }
    this.applyEmitter.fire(op);
    return res;
  }
  /**
   * 根据操作类型获取操作的label
   * @param operation 操作
   * @returns
   */
  getOperationLabel(operation) {
    const operationMeta = this.operationRegistry.getOperationMeta(operation.type);
    if (operationMeta && operationMeta.getLabel) {
      return operationMeta.getLabel(operation, this.context.source);
    }
  }
  /**
   * 根据操作类型获取操作的description
   * @param operation 操作
   * @returns
   */
  getOperationDescription(operation) {
    const operationMeta = this.operationRegistry.getOperationMeta(operation.type);
    if (operationMeta && operationMeta.getDescription) {
      return operationMeta.getDescription(operation, this.context.source);
    }
  }
  /**
   * 操作取反
   * @param operations
   * @returns
   */
  inverseOperations(operations) {
    return operations.map((op) => this.inverseOperation(op)).reverse();
  }
  inverseOperation(op) {
    const meta = this.operationRegistry.getOperationMeta(op.type);
    if (!meta) {
      throw new Error(`Operation meta ${op.type} has not registered.`);
    }
    return meta.inverse(op);
  }
  dispose() {
    this._toDispose.dispose();
  }
};
__decorateClass([
  (0, import_inversify4.inject)(OperationRegistry)
], OperationService.prototype, "operationRegistry", 2);
__decorateClass([
  (0, import_inversify4.inject)(HistoryContext)
], OperationService.prototype, "context", 2);
__decorateClass([
  (0, import_inversify4.inject)(HistoryConfig)
], OperationService.prototype, "config", 2);
__decorateClass([
  (0, import_inversify4.postConstruct)()
], OperationService.prototype, "init", 1);
OperationService = __decorateClass([
  (0, import_inversify4.injectable)()
], OperationService);

// src/history/undo-redo-service.ts
var import_inversify5 = require("inversify");
var import_utils3 = require("@flowgram.ai/utils");

// src/history/types.ts
var UndoRedoChangeType = /* @__PURE__ */ ((UndoRedoChangeType2) => {
  UndoRedoChangeType2["UNDO"] = "undo";
  UndoRedoChangeType2["REDO"] = "redo";
  UndoRedoChangeType2["PUSH"] = "push";
  UndoRedoChangeType2["CLEAR"] = "clear";
  return UndoRedoChangeType2;
})(UndoRedoChangeType || {});
var HistoryStackChangeType = /* @__PURE__ */ ((HistoryStackChangeType2) => {
  HistoryStackChangeType2["ADD"] = "add";
  HistoryStackChangeType2["UPDATE"] = "update";
  HistoryStackChangeType2["CLEAR"] = "clear";
  HistoryStackChangeType2["ADD_OPERATION"] = "add_operation";
  HistoryStackChangeType2["UPDATE_OPERATION"] = "update_operation";
  return HistoryStackChangeType2;
})(HistoryStackChangeType || {});
var HistoryMergeEventType = /* @__PURE__ */ ((HistoryMergeEventType2) => {
  HistoryMergeEventType2["ADD"] = "ADD";
  HistoryMergeEventType2["UPDATE"] = "UPDATE";
  return HistoryMergeEventType2;
})(HistoryMergeEventType || {});

// src/history/undo-redo-service.ts
var UndoRedoService = class {
  constructor() {
    this._undoing = false;
    this._redoing = false;
    this._limit = 100;
    this.onChangeEmitter = new import_utils3.Emitter();
    this.onChange = this.onChangeEmitter.event;
    this._toDispose = new import_utils3.DisposableCollection();
    this._undoStack = [];
    this._redoStack = [];
    this._toDispose.push(this.onChangeEmitter);
  }
  setLimit(limit) {
    this._limit = limit;
  }
  pushElement(element) {
    this._redoStack = [];
    this._stackPush(this._undoStack, element);
    this._toDispose.push(element);
    this._emitChange("push" /* PUSH */, element);
  }
  getUndoStack() {
    return this._undoStack;
  }
  getRedoStack() {
    return this._redoStack;
  }
  getLastElement() {
    return this._undoStack[this._undoStack.length - 1];
  }
  /**
   * 执行undo
   * @returns void
   */
  async undo() {
    if (!this.canUndo()) {
      return;
    }
    if (this._undoing) {
      return;
    }
    this._undoing = true;
    const item = this._undoStack.pop();
    try {
      await item.undo();
    } finally {
      this._stackPush(this._redoStack, item);
      this._emitChange("undo" /* UNDO */, item);
      this._undoing = false;
    }
  }
  /**
   * 执行redo
   * @returns void
   */
  async redo() {
    if (!this.canRedo()) {
      return;
    }
    if (this._redoing) {
      return;
    }
    this._redoing = true;
    const item = this._redoStack.pop();
    try {
      await item.redo();
    } finally {
      this._stackPush(this._undoStack, item);
      this._emitChange("redo" /* REDO */, item);
      this._redoing = false;
    }
  }
  /**
   * 是否可undo
   * @returns true代表可以，false代表不可以
   */
  canUndo() {
    return this._undoStack.length > 0;
  }
  /**
   * 是否可redo
   * @returns true代表可以，false代表不可以
   */
  canRedo() {
    return this._redoStack.length > 0;
  }
  /**
   * 是否可以push
   * @returns true代表可以，false代表不可以
   */
  canPush() {
    return !this._redoing && !this._undoing;
  }
  /**
   * 清空
   */
  clear() {
    this.clearRedoStack();
    this.clearUndoStack();
    this._emitChange("clear" /* CLEAR */);
  }
  /**
   * 清空redo栈
   */
  clearRedoStack() {
    this._redoStack.forEach((element) => {
      element.dispose();
    });
    this._redoStack = [];
  }
  /**
   * 清空undo栈
   */
  clearUndoStack() {
    this._undoStack.forEach((element) => {
      element.dispose();
    });
    this._undoStack = [];
  }
  /**
   * 销毁
   */
  dispose() {
    this.clear();
    this._toDispose.dispose();
  }
  _stackPush(stack, element) {
    stack.push(element);
    if (stack.length > this._limit) {
      stack.shift();
    }
  }
  _emitChange(type, element) {
    if (element) {
      this.onChangeEmitter.fire({ type, element });
    } else {
      this.onChangeEmitter.fire({ type });
    }
  }
};
UndoRedoService = __decorateClass([
  (0, import_inversify5.injectable)()
], UndoRedoService);

// src/history/history-service.ts
var import_lodash3 = require("lodash");
var import_inversify8 = require("inversify");
var import_utils7 = require("@flowgram.ai/utils");

// src/history/stack-operation.ts
var import_lodash = require("lodash");
var import_utils4 = require("@flowgram.ai/utils");
var StackOperation = class {
  constructor(operationService, operations = []) {
    this._toDispose = new import_utils4.DisposableCollection();
    this._timestamp = Date.now();
    this._operationService = operationService;
    this._operations = operations.map((op) => this._operation(op));
    this._id = operationService.config.generateId();
  }
  get id() {
    return this._id;
  }
  getTimestamp() {
    return this._timestamp;
  }
  pushOperation(operation) {
    const op = this._operation(operation);
    this._operations.push(op);
    return op;
  }
  getOperations() {
    return this._operations;
  }
  getChangeOperations(type) {
    if (type === "undo" /* UNDO */) {
      return this._operationService.inverseOperations(this._operations);
    }
    return this._operations;
  }
  getFirstOperation() {
    return this._operations[0];
  }
  getLastOperation() {
    return this._operations[this._operations.length - 1];
  }
  async undo() {
    const inverseOps = this._operationService.inverseOperations(this._operations);
    for (const op of inverseOps) {
      await this._apply(op);
    }
  }
  async redo() {
    for (const op of this._operations) {
      await this._apply(op);
    }
  }
  revert(type) {
    let operations = this._operations;
    if (type !== "undo" /* UNDO */) {
      operations = this._operations.map((op) => this._inverse(op)).reverse();
    }
    for (const op of operations) {
      this._apply(op);
    }
  }
  _inverse(op) {
    return this._operationService.inverseOperation(op);
  }
  async _apply(op) {
    await this._operationService.applyOperation(op);
  }
  _operation(op) {
    return {
      ...op,
      value: (0, import_lodash.cloneDeep)(op.value),
      id: this._operationService.config.generateId()
    };
  }
  dispose() {
    this._toDispose.dispose();
  }
};

// src/history/history-manager.ts
var import_inversify7 = require("inversify");
var import_utils6 = require("@flowgram.ai/utils");

// src/history/history-stack.ts
var import_lodash2 = require("lodash");
var import_inversify6 = require("inversify");
var import_utils5 = require("@flowgram.ai/utils");
var HistoryStack = class {
  constructor() {
    this._items = [];
    this.onChangeEmitter = new import_utils5.Emitter();
    this.onChange = this.onChangeEmitter.event;
    this._toDispose = new import_utils5.DisposableCollection();
    this.limit = 100;
    this._toDispose.push(this.onChangeEmitter);
  }
  get items() {
    return this._items;
  }
  add(service, item) {
    const historyItem = this._getHistoryItem(service, item);
    this._items.unshift(historyItem);
    if (this._items.length > this.limit) {
      this._items.pop();
    }
    this.onChangeEmitter.fire({
      type: "add" /* ADD */,
      value: historyItem,
      service
    });
    return historyItem;
  }
  findById(id) {
    return this._items.find((item) => item.id === id);
  }
  changeByIndex(index, service, item) {
    const historyItem = this._getHistoryItem(service, item);
    this._items[index] = historyItem;
    this.onChangeEmitter.fire({
      type: "update" /* UPDATE */,
      value: historyItem,
      service
    });
  }
  addOperation(service, id, op) {
    const historyItem = this._items.find((item) => item.id === id);
    if (!historyItem) {
      console.warn("no history item found");
      return;
    }
    const newOperatopn = this._getHistoryOperation(service, op);
    historyItem.operations.push(newOperatopn);
    this.onChangeEmitter.fire({
      type: "add_operation" /* ADD_OPERATION */,
      value: {
        historyItem,
        operation: newOperatopn
      },
      service
    });
  }
  updateOperation(service, id, op) {
    const historyItem = this._items.find((item) => item.id === id);
    if (!historyItem) {
      console.warn("no history item found");
      return;
    }
    const index = historyItem.operations.findIndex((op2) => op2.id === op2.id);
    if (index < 0) {
      console.warn("no operation found");
      return;
    }
    const newOperatopn = this._getHistoryOperation(service, op);
    historyItem.operations.splice(index, 1, newOperatopn);
    this.onChangeEmitter.fire({
      type: "update_operation" /* UPDATE_OPERATION */,
      value: {
        historyItem,
        operation: newOperatopn
      },
      service
    });
  }
  clear() {
    this._items = [];
  }
  dispose() {
    this._items = [];
    this._toDispose.dispose();
  }
  _getHistoryItem(service, item) {
    return {
      ...item,
      uri: service.context.uri,
      time: HistoryStack.dateFormat(item.timestamp),
      operations: item.operations.map(
        (op) => this._getHistoryOperation(service, op, item.type !== "push" /* PUSH */)
      )
    };
  }
  _getHistoryOperation(service, op, generateId = false) {
    let id;
    if (generateId) {
      id = this.historyConfig.generateId();
    } else {
      const oldId = op.id;
      if (!oldId) {
        throw new Error("no operation id found");
      }
      id = oldId;
    }
    return {
      ...(0, import_lodash2.cloneDeep)(op),
      id,
      label: service.operationService.getOperationLabel(op),
      description: service.operationService.getOperationDescription(op),
      timestamp: Date.now()
    };
  }
  static dateFormat(timestamp) {
    return new Date(timestamp).toLocaleString();
  }
};
__decorateClass([
  (0, import_inversify6.inject)(HistoryConfig)
], HistoryStack.prototype, "historyConfig", 2);
HistoryStack = __decorateClass([
  (0, import_inversify6.injectable)()
], HistoryStack);

// src/history/history-manager.ts
var HistoryManager = class {
  constructor() {
    this._historyServices = /* @__PURE__ */ new Map();
    this._toDispose = new import_utils6.DisposableCollection();
  }
  registerHistoryService(service) {
    const toDispose = new import_utils6.DisposableCollection();
    toDispose.pushAll([
      service.undoRedoService.onChange((event) => {
        if (event.type === "clear" /* CLEAR */) {
          return;
        }
        const { type, element } = event;
        const operations = element.getChangeOperations(type);
        const historyStackItem = {
          id: type === "push" /* PUSH */ ? element.id : this.historyConfig.generateId(),
          type,
          uri: service.context.uri,
          operations,
          timestamp: Date.now()
        };
        this.historyStack.add(service, historyStackItem);
      }),
      service.onMerge((event) => {
        this._handleMerge(service, event);
      })
    ]);
    this._historyServices.set(service, toDispose);
    this._toDispose.push(
      service.onWillDispose(() => {
        this.unregisterHistoryService(service);
      })
    );
  }
  unregisterHistoryService(service) {
    const disposable = this._historyServices.get(service);
    if (!disposable) {
      return;
    }
    disposable.dispose();
    this._historyServices.delete(service);
  }
  getHistoryServiceByURI(uri) {
    for (const service of this._historyServices.keys()) {
      if (service.context.uri === uri) {
        return service;
      }
    }
  }
  getFirstHistoryService() {
    for (const service of this._historyServices.keys()) {
      return service;
    }
  }
  dispose() {
    this._toDispose.dispose();
    this.historyStack.dispose();
    this._historyServices.forEach((service) => service.dispose());
    this._historyServices.clear();
  }
  _handleMerge(service, event) {
    const { element, operation } = event.value;
    const find = this.historyStack.findById(element.id);
    if (!find) {
      return;
    }
    if (!operation.id) {
      console.warn("no operation id found");
      return;
    }
    if (event.type === "UPDATE" /* UPDATE */) {
      this.historyStack.updateOperation(
        service,
        element.id,
        operation
      );
    }
    if (event.type === "ADD" /* ADD */) {
      this.historyStack.addOperation(
        service,
        element.id,
        operation
      );
    }
  }
};
__decorateClass([
  (0, import_inversify7.inject)(HistoryStack)
], HistoryManager.prototype, "historyStack", 2);
__decorateClass([
  (0, import_inversify7.inject)(HistoryConfig)
], HistoryManager.prototype, "historyConfig", 2);
HistoryManager = __decorateClass([
  (0, import_inversify7.injectable)()
], HistoryManager);

// src/history/history-service.ts
var HistoryService = class {
  constructor() {
    this._toDispose = new import_utils7.DisposableCollection();
    this._transacting = false;
    this._transactOperation = null;
    this._locked = false;
    this._willDisposeEmitter = new import_utils7.Emitter();
    this._mergeEmitter = new import_utils7.Emitter();
    this.onWillDispose = this._willDisposeEmitter.event;
    this.onMerge = this._mergeEmitter.event;
  }
  get onApply() {
    return this.operationService.onApply;
  }
  init() {
    this._toDispose.push(this._willDisposeEmitter);
    this._toDispose.push(this._mergeEmitter);
  }
  start() {
    this._locked = false;
  }
  stop() {
    this._locked = true;
  }
  limit(num) {
    this.undoRedoService.setLimit(num);
  }
  startTransaction() {
    if (this._transacting) {
      return;
    }
    this._transacting = true;
    const stackOperation = new StackOperation(this.operationService, []);
    this._transactOperation = stackOperation;
  }
  endTransaction() {
    const stackOperation = this._transactOperation;
    if (!stackOperation) {
      return;
    }
    if (stackOperation.getOperations().length !== 0) {
      this._pushStackOperation(stackOperation);
    }
    this._transactOperation = null;
    this._transacting = false;
  }
  transact(transaction) {
    if (this._transacting) {
      return;
    }
    this.startTransaction();
    transaction();
    this.endTransaction();
  }
  pushOperation(operation, options) {
    if (!this._canPush()) {
      return;
    }
    const prev = this._transactOperation || this.undoRedoService.getLastElement();
    const operationMeta = this.operationRegistry.getOperationMeta(operation.type);
    if (!operationMeta) {
      throw new Error(`Operation meta ${operation.type} has not registered.`);
    }
    if (operationMeta.shouldSave && !operationMeta.shouldSave(operation)) {
      return operationMeta.apply(operation, this.context.source);
    }
    const res = this.operationService.applyOperation(operation, { noApply: options?.noApply });
    if (operationMeta.getURI && !operation.uri) {
      operation.uri = operationMeta.getURI(operation, this.context.source);
    }
    const shouldMerge = this._shouldMerge(operation, prev, operationMeta);
    if (shouldMerge) {
      if (typeof shouldMerge === "object") {
        const operation2 = prev.getLastOperation();
        operation2.value = shouldMerge.value;
        this._mergeEmitter.fire({
          type: "UPDATE" /* UPDATE */,
          value: {
            element: prev,
            operation: operation2,
            value: shouldMerge.value
          }
        });
      } else {
        const op = prev.pushOperation(operation);
        this._mergeEmitter.fire({
          type: "ADD" /* ADD */,
          value: {
            element: prev,
            operation: op
          }
        });
      }
    } else {
      const stackOperation = new StackOperation(this.operationService, [operation]);
      this._pushStackOperation(stackOperation);
    }
    return res;
  }
  getHistoryOperations() {
    return this.historyManager.historyStack.items.reverse().map(
      (item) => item.operations.map((o) => ({
        ...(0, import_lodash3.pick)(o, ["type", "value"]),
        label: o.label || o.type
      }))
    ).flat();
  }
  async undo() {
    await this.undoRedoService.undo();
  }
  async redo() {
    await this.undoRedoService.redo();
  }
  canUndo() {
    return this.undoRedoService.canUndo();
  }
  canRedo() {
    return this.undoRedoService.canRedo();
  }
  getSnapshot() {
    return this.config.getSnapshot();
  }
  getRecords() {
    throw new Error("Method not implemented.");
  }
  restore(historyRecord) {
    throw new Error("Method not implemented.");
  }
  clear() {
    this.undoRedoService.clear();
  }
  dispose() {
    this._willDisposeEmitter.fire(this);
    this._toDispose.dispose();
  }
  _canPush() {
    if (this._locked) {
      return false;
    }
    return this.undoRedoService.canPush();
  }
  _pushStackOperation(stackOperation) {
    this.undoRedoService.pushElement(stackOperation);
    this.undoRedoService.clearRedoStack();
  }
  _shouldMerge(operation, prev, operationMeta) {
    if (!prev) {
      return false;
    }
    if (this._transacting) {
      return true;
    }
    return operationMeta.shouldMerge && operationMeta.shouldMerge(operation, prev.getLastOperation(), prev);
  }
};
__decorateClass([
  (0, import_inversify8.inject)(UndoRedoService)
], HistoryService.prototype, "undoRedoService", 2);
__decorateClass([
  (0, import_inversify8.inject)(OperationRegistry)
], HistoryService.prototype, "operationRegistry", 2);
__decorateClass([
  (0, import_inversify8.inject)(OperationService)
], HistoryService.prototype, "operationService", 2);
__decorateClass([
  (0, import_inversify8.inject)(HistoryContext)
], HistoryService.prototype, "context", 2);
__decorateClass([
  (0, import_inversify8.inject)(HistoryConfig)
], HistoryService.prototype, "config", 2);
__decorateClass([
  (0, import_inversify8.inject)(HistoryManager)
], HistoryService.prototype, "historyManager", 2);
__decorateClass([
  (0, import_inversify8.postConstruct)()
], HistoryService.prototype, "init", 1);
HistoryService = __decorateClass([
  (0, import_inversify8.injectable)()
], HistoryService);

// src/history-container-module.ts
var import_inversify9 = require("inversify");
var HistoryContainerModule = new import_inversify9.ContainerModule(
  (bind, _unbind, _isBound, _rebind, _unbindAsync, onActivation, _onDeactivation) => {
    bind(OperationRegistry).toSelf().inSingletonScope();
    bind(OperationService).toSelf().inSingletonScope();
    bind(UndoRedoService).toSelf().inSingletonScope();
    bind(HistoryService).toSelf().inSingletonScope();
    bind(HistoryContext).toSelf().inSingletonScope();
    bind(HistoryManager).toSelf().inSingletonScope();
    bind(HistoryStack).toSelf().inSingletonScope();
    bind(HistoryConfig).toSelf().inSingletonScope();
    onActivation(HistoryService, (ctx, historyService) => {
      let historyManager;
      if (ctx.container?.parent?.isBound(HistoryManager)) {
        historyManager = ctx.container?.parent?.get(HistoryManager);
      } else {
        historyManager = ctx.container.get(HistoryManager);
      }
      if (!historyManager) {
        return historyService;
      }
      historyService.historyManager = historyManager;
      historyManager.registerHistoryService(historyService);
      return historyService;
    });
  }
);

// src/create-history-plugin.ts
var import_core = require("@flowgram.ai/core");
var createHistoryPlugin = (0, import_core.definePluginCreator)({
  onInit: (ctx, opts) => {
    if (opts.onApply) {
      ctx.get(OperationService).onApply(opts.onApply.bind(null, ctx));
    }
  },
  containerModules: [HistoryContainerModule]
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HistoryConfig,
  HistoryContainerModule,
  HistoryContext,
  HistoryManager,
  HistoryMergeEventType,
  HistoryService,
  HistoryStack,
  HistoryStackChangeType,
  OperationContribution,
  OperationRegistry,
  OperationService,
  StackOperation,
  UndoRedoChangeType,
  UndoRedoService,
  createHistoryPlugin
});
//# sourceMappingURL=index.js.map