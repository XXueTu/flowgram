"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BezierControlType: () => BezierControlType,
  LINE_OFFSET: () => LINE_OFFSET,
  LINE_PADDING: () => LINE_PADDING,
  LinesLayer: () => WorkflowLinesLayer,
  WorkflowArkLineContribution: () => WorkflowArkLineContribution,
  WorkflowBezierLineContribution: () => WorkflowBezierLineContribution,
  WorkflowFoldLineContribution: () => WorkflowFoldLineContribution,
  WorkflowLinesLayer: () => WorkflowLinesLayer,
  WorkflowManhattanLineContribution: () => WorkflowManhattanLineContribution,
  WorkflowPortRender: () => WorkflowPortRender,
  WorkflowStraightLineContribution: () => WorkflowStraightLineContribution,
  createFreeLinesPlugin: () => createFreeLinesPlugin,
  getBezierHorizontalControlPoints: () => getBezierHorizontalControlPoints,
  getBezierVerticalControlPoints: () => getBezierVerticalControlPoints
});
module.exports = __toCommonJS(src_exports);

// src/components/workflow-port-render/index.tsx
var import_react_dom = __toESM(require("react-dom"));
var import_react2 = __toESM(require("react"));
var import_clsx = __toESM(require("clsx"));
var import_free_layout_core = require("@flowgram.ai/free-layout-core");
var import_core = require("@flowgram.ai/core");

// src/constants/points.ts
var STROKE_WIDTH_SLECTED = 3;
var STROKE_WIDTH = 2;
var PORT_BG_CLASS_NAME = "workflow-port-bg";

// src/components/workflow-port-render/style.ts
var import_styled_components = __toESM(require("styled-components"));
var WorkflowPointStyle = import_styled_components.default.div`
  width: 20px;
  height: 20px;
  border-radius: 50%;
  margin-top: -10px;
  margin-left: -10px;
  left: 50%;
  top: 50%;
  position: absolute;
  // 非 hover 状态下的样式
  border: none;

  & > .symbol {
    opacity: 0;
  }

  .bg-circle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    background-color: var(--g-workflow-port-color-background, #fff);
    transform: scale(0.5);
    transition: all 0.2s linear 0s;
  }

  .bg {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: var(--g-workflow-port-color-secondary, #9197f1);
    transform: scale(0.4, 0.4);
    transition: all 0.2s linear 0s;

    &.hasError {
      background: var(--g-workflow-port-color-error, red);
    }

    .symbol {
      position: absolute;
      width: 14px;
      height: 14px;
      opacity: 0;
      pointer-events: none;
      color: var(--g-workflow-port-color-background, #fff);
      transition: opacity 0.2s linear 0s;

      & > svg {
        width: 14px;
        height: 14px;
      }
    }

    .focus-circle {
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 8px;
      height: 8px;
      opacity: 0;
      background: var(--g-workflow-port-color-secondary, #9197f1);
      border-radius: 50%;
      transition: opacity 0.2s linear 0s;
    }
  }

  &.linked .bg:not(.hasError) {
    background: var(--g-workflow-port-color-primary, #4d53e8);
  }

  &.hovered .bg:not(.hasError) {
    border: none;
    cursor: crosshair;
    transform: scale(1, 1);
    background: var(--g-workflow-port-color-primary, #4d53e8);

    & > .symbol {
      opacity: 1;
    }
  }

  .cross-hair {
    position: relative;
    left: 2px;
    top: 2px;

    &::after,
    &::before {
      content: '';
      background: var(--g-workflow-port-color-background, #fff);
      border-radius: 2px;
      position: absolute;
    }

    &::after {
      left: 4px;
      width: 2px;
      height: 6px;
      box-shadow: 0 4px var(--g-workflow-port-color-background, #fff);
    }

    &::before {
      top: 4px;
      width: 6px;
      height: 2px;
      box-shadow: 4px 0 var(--g-workflow-port-color-background, #fff);
    }
`;

// src/components/workflow-port-render/cross-hair.tsx
var import_react = __toESM(require("react"));
function CrossHair() {
  return /* @__PURE__ */ import_react.default.createElement("div", { className: "symbol" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "cross-hair" }));
}

// src/components/workflow-port-render/index.tsx
var WorkflowPortRender = (
  // eslint-disable-next-line react/display-name
  import_react2.default.memo((props) => {
    const hoverService = (0, import_core.useService)(import_free_layout_core.WorkflowHoverService);
    const linesManager = (0, import_core.useService)(import_free_layout_core.WorkflowLinesManager);
    const { entity, onClick } = props;
    const { portType, relativePosition, disabled } = entity;
    const [targetElement, setTargetElement] = (0, import_react2.useState)(entity.targetElement);
    const [posX, updatePosX] = (0, import_react2.useState)(relativePosition.x);
    const [posY, updatePosY] = (0, import_react2.useState)(relativePosition.y);
    const [hovered, setHovered] = (0, import_react2.useState)(false);
    const [linked, setLinked] = (0, import_react2.useState)(Boolean(entity?.lines?.length));
    const [hasError, setHasError] = (0, import_react2.useState)(props.entity.hasError);
    const readonly = (0, import_free_layout_core.usePlaygroundReadonlyState)();
    (0, import_react2.useEffect)(() => {
      entity.validate();
      setHasError(entity.hasError);
      const dispose = entity.onEntityChange(() => {
        if (entity.targetElement) {
          if (entity.targetElement !== targetElement) {
            setTargetElement(entity.targetElement);
          }
          return;
        }
        const newPos = entity.relativePosition;
        updatePosX(Math.round(newPos.x));
        updatePosY(Math.round(newPos.y));
      });
      const dispose2 = hoverService.onHoveredChange((id) => {
        setHovered(hoverService.isHovered(entity.id));
      });
      const dispose3 = entity.onErrorChanged(() => {
        setHasError(entity.hasError);
      });
      const dispose4 = linesManager.onAvailableLinesChange(() => {
        setTimeout(() => {
          if (linesManager.disposed || entity.disposed) return;
          setLinked(Boolean(entity.lines.length));
        }, 0);
      });
      return () => {
        dispose.dispose();
        dispose2.dispose();
        dispose3.dispose();
        dispose4.dispose();
      };
    }, [hoverService, entity, targetElement]);
    const className = (0, import_clsx.default)("workflow-port-render", props.className || "", {
      hovered: !readonly && hovered && !disabled && portType !== "input",
      // 有线条链接的时候深蓝色小圆点
      linked
    });
    const content = /* @__PURE__ */ import_react2.default.createElement(
      WorkflowPointStyle,
      {
        className,
        style: targetElement ? props.style : { ...props.style, left: posX, top: posY },
        onClick,
        "data-port-entity-id": entity.id,
        "data-port-entity-type": entity.portType,
        "data-testid": "sdk.workflow.canvas.node.port"
      },
      /* @__PURE__ */ import_react2.default.createElement("div", { className: (0, import_clsx.default)("bg-circle", "workflow-bg-circle") }),
      /* @__PURE__ */ import_react2.default.createElement(
        "div",
        {
          className: (0, import_clsx.default)({
            bg: true,
            [PORT_BG_CLASS_NAME]: true,
            "workflow-point-bg": true,
            hasError
          })
        },
        /* @__PURE__ */ import_react2.default.createElement(CrossHair, null)
      ),
      /* @__PURE__ */ import_react2.default.createElement("div", { className: "focus-circle" })
    );
    if (targetElement) {
      return import_react_dom.default.createPortal(content, targetElement);
    }
    return content;
  })
);

// src/constants/lines.ts
var LINE_OFFSET = 6;
var LINE_PADDING = 12;

// src/create-free-lines-plugin.ts
var import_free_layout_core12 = require("@flowgram.ai/free-layout-core");
var import_core3 = require("@flowgram.ai/core");

// src/layer/workflow-lines-layer.tsx
var import_react_dom2 = __toESM(require("react-dom"));
var import_react6 = __toESM(require("react"));
var import_inversify = require("inversify");
var import_utils = require("@flowgram.ai/utils");
var import_free_stack_plugin = require("@flowgram.ai/free-stack-plugin");
var import_free_layout_core4 = require("@flowgram.ai/free-layout-core");
var import_core2 = require("@flowgram.ai/core");

// src/components/workflow-line-render/index.tsx
var import_react5 = require("react");

// src/components/workflow-line-render/line-svg.tsx
var import_react4 = __toESM(require("react"));
var import_clsx2 = __toESM(require("clsx"));
var import_free_layout_core2 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core3 = require("@flowgram.ai/free-layout-core");

// src/components/workflow-line-render/index.style.ts
var import_styled_components2 = __toESM(require("styled-components"));
var LineStyle = import_styled_components2.default.div.attrs({
  className: "gedit-flow-activity-edge"
})`
  position: absolute;

  @keyframes flowingDash {
    to {
      stroke-dashoffset: -13;
    }
  }

  .dashed-line {
    stroke-dasharray: 8, 5;
  }

  .flowing-line {
    animation: flowingDash 0.5s linear infinite;
  }
`;

// src/components/workflow-line-render/arrow.tsx
var import_react3 = __toESM(require("react"));
function ArrowRenderer({
  id,
  pos,
  reverseArrow,
  strokeWidth,
  vertical,
  hide
}) {
  if (hide) {
    return null;
  }
  const arrowPath = vertical ? reverseArrow ? `M ${pos.x - LINE_OFFSET},${pos.y} L ${pos.x},${pos.y - LINE_OFFSET} L ${pos.x + LINE_OFFSET},${pos.y}` : `M ${pos.x - LINE_OFFSET},${pos.y - LINE_OFFSET} L ${pos.x},${pos.y} L ${pos.x + LINE_OFFSET},${pos.y - LINE_OFFSET}` : reverseArrow ? `M ${pos.x},${pos.y + LINE_OFFSET} L ${pos.x - LINE_OFFSET},${pos.y} L ${pos.x},${pos.y - LINE_OFFSET}` : `M ${pos.x - LINE_OFFSET},${pos.y - LINE_OFFSET} L ${pos.x},${pos.y} L ${pos.x - LINE_OFFSET},${pos.y + LINE_OFFSET}`;
  return /* @__PURE__ */ import_react3.default.createElement(
    "path",
    {
      d: arrowPath,
      strokeLinecap: "round",
      stroke: `url(#${id})`,
      fill: "none",
      strokeWidth
    }
  );
}

// src/components/workflow-line-render/line-svg.tsx
var PADDING = 12;
var LineSVG = (props) => {
  const { line, color, selected, children, strokePrefix } = props;
  const { position, reverse, vertical, hideArrow } = line;
  const renderData = line.getData(import_free_layout_core3.WorkflowLineRenderData);
  const { bounds, path: bezierPath } = renderData;
  const toRelative = (p) => ({
    x: p.x - bounds.x + PADDING,
    y: p.y - bounds.y + PADDING
  });
  const fromPos = toRelative(position.from);
  const toPos = toRelative(position.to);
  const arrowToPos = vertical ? { x: toPos.x, y: toPos.y - import_free_layout_core2.POINT_RADIUS } : { x: toPos.x - import_free_layout_core2.POINT_RADIUS, y: toPos.y };
  const arrowFromPos = vertical ? { x: fromPos.x, y: fromPos.y + import_free_layout_core2.POINT_RADIUS + LINE_OFFSET } : { x: fromPos.x + import_free_layout_core2.POINT_RADIUS + LINE_OFFSET, y: fromPos.y };
  const strokeWidth = selected ? STROKE_WIDTH_SLECTED : STROKE_WIDTH;
  const strokeID = strokePrefix ? `${strokePrefix}-${line.id}` : line.id;
  const path = /* @__PURE__ */ import_react4.default.createElement(
    "path",
    {
      d: bezierPath,
      fill: "none",
      stroke: `url(#${strokeID})`,
      strokeWidth,
      className: (0, import_clsx2.default)(
        line.className,
        // 显示流动线条的条件：没有自定义线条class，并且线条处于流动或处理中
        !line.className && (line.processing || line.flowing ? "dashed-line flowing-line" : "")
      )
    }
  );
  return /* @__PURE__ */ import_react4.default.createElement(
    LineStyle,
    {
      style: {
        left: bounds.x - PADDING,
        top: bounds.y - PADDING,
        position: "absolute"
      }
    },
    children,
    /* @__PURE__ */ import_react4.default.createElement("svg", { width: bounds.width + PADDING * 2, height: bounds.height + PADDING * 2 }, /* @__PURE__ */ import_react4.default.createElement("defs", null, /* @__PURE__ */ import_react4.default.createElement(
      "linearGradient",
      {
        x1: vertical ? "100%" : "0%",
        y1: vertical ? "0%" : "100%",
        x2: "100%",
        y2: "100%",
        id: strokeID,
        gradientUnits: "userSpaceOnUse"
      },
      /* @__PURE__ */ import_react4.default.createElement("stop", { stopColor: color, offset: "0%" }),
      /* @__PURE__ */ import_react4.default.createElement("stop", { stopColor: color, offset: "100%" })
    )), /* @__PURE__ */ import_react4.default.createElement("g", null, path, /* @__PURE__ */ import_react4.default.createElement(
      ArrowRenderer,
      {
        id: strokeID,
        reverseArrow: reverse,
        pos: reverse ? arrowFromPos : arrowToPos,
        strokeWidth,
        vertical,
        hide: hideArrow
      }
    )))
  );
};

// src/components/workflow-line-render/index.tsx
var WorkflowLineRender = (0, import_react5.memo)(
  LineSVG,
  (prevProps, nextProps) => prevProps.version === nextProps.version
);

// src/layer/workflow-lines-layer.tsx
var WorkflowLinesLayer = class extends import_core2.Layer {
  constructor() {
    super(...arguments);
    this.layerID = (0, import_free_layout_core4.nanoid)();
    this.mountedLines = /* @__PURE__ */ new Map();
    this._version = 0;
    /**
     * 节点线条
     */
    this.node = import_utils.domUtils.createDivWithClass("gedit-playground-layer gedit-flow-lines-layer");
  }
  onZoom(scale) {
    this.node.style.transform = `scale(${scale})`;
  }
  onReady() {
    this.pipelineNode.appendChild(this.node);
    this.toDispose.pushAll([
      this.selectService.onSelectionChanged(() => this.render()),
      this.hoverService.onHoveredChange(() => this.render()),
      this.workflowDocument.linesManager.onForceUpdate(() => {
        this.mountedLines.clear();
        this.bumpVersion();
        this.render();
      })
    ]);
  }
  dispose() {
    this.mountedLines.clear();
  }
  render() {
    const [, forceUpdate] = (0, import_react6.useState)({});
    (0, import_react6.useLayoutEffect)(() => {
      const updateLines = () => {
        let needsUpdate = false;
        this.lines.forEach((line) => {
          const renderData = line.getData(import_free_layout_core4.WorkflowLineRenderData);
          const oldVersion = renderData.renderVersion;
          renderData.update();
          if (renderData.renderVersion !== oldVersion) {
            needsUpdate = true;
          }
        });
        if (needsUpdate) {
          forceUpdate({});
        }
      };
      const rafId = requestAnimationFrame(updateLines);
      return () => cancelAnimationFrame(rafId);
    }, [this.lines]);
    const lines = this.lines.map((line) => this.renderLine(line));
    return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, lines);
  }
  // 用来绕过 memo
  bumpVersion() {
    this._version = this._version + 1;
    if (this._version === Number.MAX_SAFE_INTEGER) {
      this._version = 0;
    }
  }
  lineProps(line) {
    const { lineType } = this.workflowDocument.linesManager;
    const selected = this.selectService.isSelected(line.id);
    const hovered = this.hoverService.isHovered(line.id);
    const version = this.lineVersion(line);
    return {
      key: line.id,
      color: line.color,
      selected,
      hovered,
      line,
      lineType,
      version,
      strokePrefix: this.layerID
    };
  }
  lineVersion(line) {
    const renderData = line.getData(import_free_layout_core4.WorkflowLineRenderData);
    const { renderVersion } = renderData;
    const selected = this.selectService.isSelected(line.id);
    const hovered = this.hoverService.isHovered(line.id);
    const { version: lineVersion, color } = line;
    const version = `v:${this._version},lv:${lineVersion},rv:${renderVersion},c:${color},s:${selected ? "T" : "F"},h:${hovered ? "T" : "F"}`;
    return version;
  }
  lineComponent(props) {
    const RenderInsideLine = this.options.renderInsideLine ?? (() => /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null));
    return /* @__PURE__ */ import_react6.default.createElement(WorkflowLineRender, { ...props }, /* @__PURE__ */ import_react6.default.createElement(RenderInsideLine, { ...props }));
  }
  renderLine(line) {
    const lineProps = this.lineProps(line);
    const cache = this.mountedLines.get(line.id);
    const isCached = cache !== void 0;
    const { portal: cachedPortal, version: cachedVersion } = cache ?? {};
    if (isCached && cachedVersion === lineProps.version) {
      return cachedPortal;
    }
    if (!isCached) {
      this.renderElement.appendChild(line.node);
      line.onDispose(() => {
        this.mountedLines.delete(line.id);
        line.node.remove();
      });
    }
    const portal = import_react_dom2.default.createPortal(this.lineComponent(lineProps), line.node);
    this.mountedLines.set(line.id, { line, portal, version: lineProps.version });
    return portal;
  }
  get renderElement() {
    return this.stackContext.node;
  }
};
WorkflowLinesLayer.type = "WorkflowLinesLayer";
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core4.WorkflowHoverService)
], WorkflowLinesLayer.prototype, "hoverService", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core4.WorkflowSelectService)
], WorkflowLinesLayer.prototype, "selectService", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_stack_plugin.StackingContextManager)
], WorkflowLinesLayer.prototype, "stackContext", 2);
__decorateClass([
  (0, import_core2.observeEntities)(import_free_layout_core4.WorkflowLineEntity)
], WorkflowLinesLayer.prototype, "lines", 2);
__decorateClass([
  (0, import_core2.observeEntities)(import_free_layout_core4.WorkflowPortEntity)
], WorkflowLinesLayer.prototype, "ports", 2);
__decorateClass([
  (0, import_core2.observeEntityDatas)(import_free_layout_core4.WorkflowNodeEntity, import_core2.TransformData)
], WorkflowLinesLayer.prototype, "trans", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core4.WorkflowDocument)
], WorkflowLinesLayer.prototype, "workflowDocument", 2);
WorkflowLinesLayer = __decorateClass([
  (0, import_inversify.injectable)()
], WorkflowLinesLayer);

// src/contributions/bezier/bezier-controls.ts
var import_utils2 = require("@flowgram.ai/utils");
var BezierControlType = /* @__PURE__ */ ((BezierControlType2) => {
  BezierControlType2[BezierControlType2["RIGHT_TOP"] = 0] = "RIGHT_TOP";
  BezierControlType2[BezierControlType2["RIGHT_BOTTOM"] = 1] = "RIGHT_BOTTOM";
  BezierControlType2[BezierControlType2["LEFT_TOP"] = 2] = "LEFT_TOP";
  BezierControlType2[BezierControlType2["LEFT_BOTTOM"] = 3] = "LEFT_BOTTOM";
  return BezierControlType2;
})(BezierControlType || {});
var CONTROL_MAX = 300;
function getBezierHorizontalControlPoints(fromPos, toPos) {
  const rect = import_utils2.Rectangle.createRectangleWithTwoPoints(fromPos, toPos);
  let type;
  if (fromPos.x <= toPos.x) {
    type = fromPos.y <= toPos.y ? 1 /* RIGHT_BOTTOM */ : 0 /* RIGHT_TOP */;
  } else {
    type = fromPos.y <= toPos.y ? 3 /* LEFT_BOTTOM */ : 2 /* LEFT_TOP */;
  }
  let controls;
  switch (type) {
    case 0 /* RIGHT_TOP */:
      controls = [
        {
          x: rect.rightBottom.x - rect.width / 2,
          y: rect.rightBottom.y
        },
        {
          x: rect.leftTop.x + rect.width / 2,
          y: rect.leftTop.y
        }
      ];
      break;
    case 1 /* RIGHT_BOTTOM */:
      controls = [
        {
          x: rect.rightTop.x - rect.width / 2,
          y: rect.rightTop.y
        },
        {
          x: rect.leftBottom.x + rect.width / 2,
          y: rect.leftBottom.y
        }
      ];
      break;
    case 2 /* LEFT_TOP */:
      controls = [
        {
          x: rect.rightBottom.x + Math.min(rect.width, CONTROL_MAX),
          y: rect.rightBottom.y
        },
        {
          x: rect.leftTop.x - Math.min(rect.width, CONTROL_MAX),
          y: rect.leftTop.y
        }
      ];
      break;
    case 3 /* LEFT_BOTTOM */:
      controls = [
        {
          x: rect.rightTop.x + Math.min(rect.width, CONTROL_MAX),
          y: rect.rightTop.y
        },
        {
          x: rect.leftBottom.x - Math.min(rect.width, CONTROL_MAX),
          y: rect.leftBottom.y
        }
      ];
  }
  return controls;
}
function getBezierVerticalControlPoints(fromPos, toPos) {
  const rect = import_utils2.Rectangle.createRectangleWithTwoPoints(fromPos, toPos);
  let type;
  if (fromPos.y <= toPos.y) {
    type = fromPos.x <= toPos.x ? 1 /* RIGHT_BOTTOM */ : 3 /* LEFT_BOTTOM */;
  } else {
    type = fromPos.x <= toPos.x ? 0 /* RIGHT_TOP */ : 2 /* LEFT_TOP */;
  }
  let controls;
  switch (type) {
    case 1 /* RIGHT_BOTTOM */:
      controls = [
        {
          x: rect.leftTop.x,
          y: rect.leftTop.y + rect.height / 2
        },
        {
          x: rect.rightBottom.x,
          y: rect.rightBottom.y - rect.height / 2
        }
      ];
      break;
    case 3 /* LEFT_BOTTOM */:
      controls = [
        {
          x: rect.rightTop.x,
          y: rect.rightTop.y + rect.height / 2
        },
        {
          x: rect.leftBottom.x,
          y: rect.leftBottom.y - rect.height / 2
        }
      ];
      break;
    case 0 /* RIGHT_TOP */:
      controls = [
        {
          x: rect.leftBottom.x,
          y: rect.leftBottom.y + Math.min(rect.height, CONTROL_MAX)
        },
        {
          x: rect.rightTop.x,
          y: rect.rightTop.y - Math.min(rect.height, CONTROL_MAX)
        }
      ];
      break;
    case 2 /* LEFT_TOP */:
      controls = [
        {
          x: rect.rightBottom.x,
          y: rect.rightBottom.y + Math.min(rect.height, CONTROL_MAX)
        },
        {
          x: rect.leftTop.x,
          y: rect.leftTop.y - Math.min(rect.height, CONTROL_MAX)
        }
      ];
      break;
  }
  return controls;
}

// src/contributions/bezier/index.ts
var import_bezier_js = require("bezier-js");
var import_utils3 = require("@flowgram.ai/utils");
var import_free_layout_core5 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core6 = require("@flowgram.ai/free-layout-core");
var WorkflowBezierLineContribution = class {
  constructor(entity) {
    this.entity = entity;
  }
  get path() {
    return this.data?.path ?? "";
  }
  calcDistance(pos) {
    if (!this.data) {
      return Number.MAX_SAFE_INTEGER;
    }
    return import_utils3.Point.getDistance(pos, this.data.bezier.project(pos));
  }
  get bounds() {
    if (!this.data) {
      return new import_utils3.Rectangle();
    }
    return this.data.bbox;
  }
  update(params) {
    this.data = this.calcBezier(params.fromPos, params.toPos);
  }
  calcBezier(fromPos, toPos) {
    const controls = this.entity.vertical ? getBezierVerticalControlPoints(fromPos, toPos) : getBezierHorizontalControlPoints(fromPos, toPos);
    const bezier = new import_bezier_js.Bezier([fromPos, ...controls, toPos]);
    const bbox = bezier.bbox();
    const bboxBounds = new import_utils3.Rectangle(
      bbox.x.min,
      bbox.y.min,
      bbox.x.max - bbox.x.min,
      bbox.y.max - bbox.y.min
    );
    const path = this.getPath({ bbox: bboxBounds, fromPos, toPos, controls });
    this.data = {
      fromPos,
      toPos,
      bezier,
      bbox: bboxBounds,
      controls,
      path
    };
    return this.data;
  }
  getPath(params) {
    const { bbox } = params;
    const toRelative = (p) => ({
      x: p.x - bbox.x + LINE_PADDING,
      y: p.y - bbox.y + LINE_PADDING
    });
    const fromPos = toRelative(params.fromPos);
    const toPos = toRelative(params.toPos);
    const controls = params.controls.map((c) => toRelative(c));
    const renderToPos = this.entity.vertical ? { x: toPos.x, y: toPos.y - import_free_layout_core5.POINT_RADIUS } : { x: toPos.x - import_free_layout_core5.POINT_RADIUS, y: toPos.y };
    const getPathData = () => {
      const controlPoints = controls.map((s) => `${s.x} ${s.y}`).join(",");
      const curveType = controls.length === 1 ? "S" : "C";
      if (this.entity.vertical) {
        return `M${fromPos.x} ${fromPos.y + import_free_layout_core5.POINT_RADIUS} ${curveType} ${controlPoints}, ${renderToPos.x} ${renderToPos.y}`;
      }
      return `M${fromPos.x + import_free_layout_core5.POINT_RADIUS} ${fromPos.y} ${curveType} ${controlPoints}, ${renderToPos.x} ${renderToPos.y}`;
    };
    const path = getPathData();
    return path;
  }
};
WorkflowBezierLineContribution.type = import_free_layout_core6.LineType.BEZIER;

// src/contributions/fold/index.ts
var import_utils5 = require("@flowgram.ai/utils");
var import_free_layout_core7 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core8 = require("@flowgram.ai/free-layout-core");

// src/contributions/fold/fold-line.ts
var import_utils4 = require("@flowgram.ai/utils");
var getPointToSegmentDistance = (point, segStart, segEnd) => {
  const { x: px, y: py } = point;
  const { x: x1, y: y1 } = segStart;
  const { x: x2, y: y2 } = segEnd;
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  const param = lenSq === 0 ? -1 : dot / lenSq;
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
};
var FoldLine;
((FoldLine2) => {
  const EDGE_RADIUS = 5;
  const OFFSET = 20;
  function getEdgeCenter({ source, target }) {
    const xOffset = Math.abs(target.x - source.x) / 2;
    const centerX = target.x < source.x ? target.x + xOffset : target.x - xOffset;
    const yOffset = Math.abs(target.y - source.y) / 2;
    const centerY = target.y < source.y ? target.y + yOffset : target.y - yOffset;
    return [centerX, centerY];
  }
  const getDirection = ({ source, target }) => source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  function getPoints({
    source,
    target,
    vertical = false
  }) {
    const sourceDir = vertical ? { x: 0, y: 1 } : { x: 1, y: 0 };
    const targetDir = vertical ? { x: 0, y: -1 } : { x: -1, y: 0 };
    const sourceGapped = {
      x: source.x + sourceDir.x * OFFSET,
      y: source.y + sourceDir.y * OFFSET
    };
    const targetGapped = {
      x: target.x + targetDir.x * OFFSET,
      y: target.y + targetDir.y * OFFSET
    };
    const dir = vertical ? { x: 0, y: sourceGapped.y < targetGapped.y ? 1 : -1 } : getDirection({ source: sourceGapped, target: targetGapped });
    const dirAccessor = dir.x !== 0 ? "x" : "y";
    const currDir = dir[dirAccessor];
    let points = [];
    let centerX, centerY;
    const [defaultCenterX, defaultCenterY] = getEdgeCenter({
      source,
      target
    });
    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
      centerX = defaultCenterX;
      centerY = defaultCenterY;
      const verticalSplit = [
        { x: centerX, y: sourceGapped.y },
        { x: centerX, y: targetGapped.y }
      ];
      const horizontalSplit = [
        { x: sourceGapped.x, y: centerY },
        { x: targetGapped.x, y: centerY }
      ];
      if (sourceDir[dirAccessor] === currDir) {
        points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
      } else {
        points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
      }
    } else {
      const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
      const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
      if (dirAccessor === "x") {
        points = sourceDir.x === currDir ? targetSource : sourceTarget;
      } else {
        points = sourceDir.y === currDir ? sourceTarget : targetSource;
      }
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
      const sourceGapPoint = { x: sourceGapped.x, y: sourceGapped.y };
      const targetGapPoint = { x: targetGapped.x, y: targetGapped.y };
      const maxXDistance = Math.max(
        Math.abs(sourceGapPoint.x - points[0].x),
        Math.abs(targetGapPoint.x - points[0].x)
      );
      const maxYDistance = Math.max(
        Math.abs(sourceGapPoint.y - points[0].y),
        Math.abs(targetGapPoint.y - points[0].y)
      );
      if (maxXDistance >= maxYDistance) {
        centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
        centerY = points[0].y;
      } else {
        centerX = points[0].x;
        centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
      }
    }
    const pathPoints = [
      source,
      { x: sourceGapped.x, y: sourceGapped.y },
      ...points,
      { x: targetGapped.x, y: targetGapped.y },
      target
    ];
    return pathPoints;
  }
  FoldLine2.getPoints = getPoints;
  function getBend(a, b, c) {
    const bendSize = Math.min(
      import_utils4.Point.getDistance(a, b) / 2,
      import_utils4.Point.getDistance(b, c) / 2,
      EDGE_RADIUS
    );
    const { x, y } = b;
    if (a.x === x && x === c.x || a.y === y && y === c.y) {
      return `L${x} ${y}`;
    }
    if (a.y === y) {
      const xDir2 = a.x < c.x ? -1 : 1;
      const yDir2 = a.y < c.y ? 1 : -1;
      return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
    }
    const xDir = a.x < c.x ? 1 : -1;
    const yDir = a.y < c.y ? -1 : 1;
    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
  }
  function getSmoothStepPath(points) {
    const path = points.reduce((res, p, i) => {
      let segment = "";
      if (i > 0 && i < points.length - 1) {
        segment = getBend(points[i - 1], p, points[i + 1]);
      } else {
        segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
      }
      res += segment;
      return res;
    }, "");
    return path;
  }
  FoldLine2.getSmoothStepPath = getSmoothStepPath;
  function getBounds(points) {
    const xList = points.map((p) => p.x);
    const yList = points.map((p) => p.y);
    const left = Math.min(...xList);
    const right = Math.max(...xList);
    const top = Math.min(...yList);
    const bottom = Math.max(...yList);
    return import_utils4.Rectangle.createRectangleWithTwoPoints(
      {
        x: left,
        y: top
      },
      {
        x: right,
        y: bottom
      }
    );
  }
  FoldLine2.getBounds = getBounds;
  FoldLine2.getFoldLineToPointDistance = (points, pos) => {
    if (points.length === 0) {
      return Infinity;
    }
    if (points.length === 1) {
      return import_utils4.Point.getDistance(points[0], pos);
    }
    const lines = [];
    for (let i = 0; i < points.length - 1; i++) {
      lines.push([points[i], points[i + 1]]);
    }
    const distances = lines.map((line) => {
      const [p1, p2] = line;
      return getPointToSegmentDistance(pos, p1, p2);
    });
    return Math.min(...distances);
  };
})(FoldLine || (FoldLine = {}));

// src/contributions/fold/index.ts
var WorkflowFoldLineContribution = class {
  constructor(entity) {
    this.entity = entity;
  }
  get path() {
    return this.data?.path ?? "";
  }
  calcDistance(pos) {
    if (!this.data) {
      return Number.MAX_SAFE_INTEGER;
    }
    return FoldLine.getFoldLineToPointDistance(this.data.points, pos);
  }
  get bounds() {
    if (!this.data) {
      return new import_utils5.Rectangle();
    }
    return this.data.bbox;
  }
  update(params) {
    const { fromPos, toPos } = params;
    const { vertical } = this.entity;
    const sourceOffset = {
      x: vertical ? 0 : import_free_layout_core7.POINT_RADIUS,
      y: vertical ? import_free_layout_core7.POINT_RADIUS : 0
    };
    const targetOffset = {
      x: vertical ? 0 : -import_free_layout_core7.POINT_RADIUS,
      y: vertical ? -import_free_layout_core7.POINT_RADIUS : 0
    };
    const points = FoldLine.getPoints({
      source: {
        x: fromPos.x + sourceOffset.x,
        y: fromPos.y + sourceOffset.y
      },
      target: {
        x: toPos.x + targetOffset.x,
        y: toPos.y + targetOffset.y
      },
      vertical
    });
    const bbox = FoldLine.getBounds(points);
    const adjustedPoints = points.map((p) => ({
      x: p.x - bbox.x + LINE_PADDING,
      y: p.y - bbox.y + LINE_PADDING
    }));
    const path = FoldLine.getSmoothStepPath(adjustedPoints);
    this.data = {
      points,
      path,
      bbox
    };
  }
};
WorkflowFoldLineContribution.type = import_free_layout_core8.LineType.LINE_CHART;

// src/contributions/straight/index.ts
var import_utils6 = require("@flowgram.ai/utils");
var import_free_layout_core9 = require("@flowgram.ai/free-layout-core");

// src/contributions/straight/point-on-line.ts
function projectPointOnLine(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  if (dx === 0) {
    return { x: lineStart.x, y: point.y };
  }
  if (dy === 0) {
    return { x: point.x, y: lineStart.y };
  }
  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (dx * dx + dy * dy);
  const clampedT = Math.max(0, Math.min(1, t));
  return {
    x: lineStart.x + clampedT * dx,
    y: lineStart.y + clampedT * dy
  };
}

// src/contributions/straight/index.ts
var WorkflowStraightLineContribution = class {
  constructor(entity) {
    this.entity = entity;
  }
  get path() {
    return this.data?.path ?? "";
  }
  calcDistance(pos) {
    if (!this.data) {
      return Number.MAX_SAFE_INTEGER;
    }
    const [start, end] = this.data.points;
    return import_utils6.Point.getDistance(pos, projectPointOnLine(pos, start, end));
  }
  get bounds() {
    if (!this.data) {
      return new import_utils6.Rectangle();
    }
    return this.data.bbox;
  }
  update(params) {
    const { fromPos, toPos } = params;
    const { vertical } = this.entity;
    const sourceOffset = {
      x: vertical ? 0 : import_free_layout_core9.POINT_RADIUS,
      y: vertical ? import_free_layout_core9.POINT_RADIUS : 0
    };
    const targetOffset = {
      x: vertical ? 0 : -import_free_layout_core9.POINT_RADIUS,
      y: vertical ? -import_free_layout_core9.POINT_RADIUS : 0
    };
    const points = [
      {
        x: fromPos.x + sourceOffset.x,
        y: fromPos.y + sourceOffset.y
      },
      {
        x: toPos.x + targetOffset.x,
        y: toPos.y + targetOffset.y
      }
    ];
    const bbox = import_utils6.Rectangle.createRectangleWithTwoPoints(points[0], points[1]);
    const adjustedPoints = points.map((p) => ({
      x: p.x - bbox.x + LINE_PADDING,
      y: p.y - bbox.y + LINE_PADDING
    }));
    const path = `M ${adjustedPoints[0].x} ${adjustedPoints[0].y} L ${adjustedPoints[1].x} ${adjustedPoints[1].y}`;
    this.data = {
      points,
      path,
      bbox
    };
  }
};
WorkflowStraightLineContribution.type = "WorkflowStraightLineContribution";

// src/contributions/arc/index.ts
var import_utils7 = require("@flowgram.ai/utils");
var import_free_layout_core10 = require("@flowgram.ai/free-layout-core");
var WorkflowArkLineContribution = class {
  constructor(entity) {
    this.entity = entity;
  }
  get path() {
    return this.data?.path ?? "";
  }
  calcDistance(pos) {
    if (!this.data) {
      return Number.MAX_SAFE_INTEGER;
    }
    const { fromPos, toPos, bbox } = this.data;
    if (!bbox.contains(pos.x, pos.y)) {
      const dx = Math.max(bbox.x - pos.x, 0, pos.x - (bbox.x + bbox.width));
      const dy = Math.max(bbox.y - pos.y, 0, pos.y - (bbox.y + bbox.height));
      return Math.sqrt(dx * dx + dy * dy);
    }
    const center = {
      x: (fromPos.x + toPos.x) / 2,
      y: (fromPos.y + toPos.y) / 2
    };
    const radius = import_utils7.Point.getDistance(fromPos, center);
    const distanceToCenter = import_utils7.Point.getDistance(pos, center);
    return Math.abs(distanceToCenter - radius);
  }
  get bounds() {
    if (!this.data) {
      return new import_utils7.Rectangle();
    }
    return this.data.bbox;
  }
  update(params) {
    const { fromPos, toPos } = params;
    const { vertical } = this.entity;
    const sourceOffset = {
      x: vertical ? 0 : import_free_layout_core10.POINT_RADIUS,
      y: vertical ? import_free_layout_core10.POINT_RADIUS : 0
    };
    const targetOffset = {
      x: vertical ? 0 : -import_free_layout_core10.POINT_RADIUS,
      y: vertical ? -import_free_layout_core10.POINT_RADIUS : 0
    };
    const start = {
      x: fromPos.x + sourceOffset.x,
      y: fromPos.y + sourceOffset.y
    };
    const end = {
      x: toPos.x + targetOffset.x,
      y: toPos.y + targetOffset.y
    };
    const bbox = this.calculateArcBBox(start, end);
    const path = this.getArcPath(start, end, bbox);
    this.data = {
      fromPos: start,
      toPos: end,
      path,
      bbox
    };
  }
  calculateArcBBox(start, end) {
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const radius = Math.sqrt(dx * dx + dy * dy) / 2;
    const centerX = (start.x + end.x) / 2;
    const centerY = (start.y + end.y) / 2;
    return new import_utils7.Rectangle(centerX - radius, centerY - radius, radius * 2, radius * 2);
  }
  getArcPath(start, end, bbox) {
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const startRel = {
      x: start.x - bbox.x + LINE_PADDING,
      y: start.y - bbox.y + LINE_PADDING
    };
    const endRel = {
      x: end.x - bbox.x + LINE_PADDING,
      y: end.y - bbox.y + LINE_PADDING
    };
    return `M ${startRel.x} ${startRel.y} A ${distance / 2} ${distance / 2} 0 0 1 ${endRel.x} ${endRel.y}`;
  }
};
WorkflowArkLineContribution.type = "WorkflowArkLineContribution";

// src/contributions/manhattan/index.ts
var import_utils8 = require("@flowgram.ai/utils");
var import_free_layout_core11 = require("@flowgram.ai/free-layout-core");
var WorkflowManhattanLineContribution = class {
  constructor(entity) {
    this.entity = entity;
  }
  get path() {
    return this.data?.path ?? "";
  }
  calcDistance(pos) {
    if (!this.data) {
      return Number.MAX_SAFE_INTEGER;
    }
    return Math.min(
      ...this.data.points.slice(1).map((point, index) => {
        const prevPoint = this.data.points[index];
        return this.getDistanceToLineSegment(pos, prevPoint, point);
      })
    );
  }
  getDistanceToLineSegment(point, start, end) {
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    if (dx === 0 && dy === 0) {
      return import_utils8.Point.getDistance(point, start);
    }
    const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / (dx * dx + dy * dy);
    if (t < 0) return import_utils8.Point.getDistance(point, start);
    if (t > 1) return import_utils8.Point.getDistance(point, end);
    const projectionPoint = {
      x: start.x + t * dx,
      y: start.y + t * dy
    };
    return import_utils8.Point.getDistance(point, projectionPoint);
  }
  get bounds() {
    if (!this.data) {
      return new import_utils8.Rectangle();
    }
    return this.data.bbox;
  }
  update(params) {
    const { fromPos, toPos } = params;
    const { vertical } = this.entity;
    const sourceOffset = {
      x: vertical ? 0 : import_free_layout_core11.POINT_RADIUS,
      y: vertical ? import_free_layout_core11.POINT_RADIUS : 0
    };
    const targetOffset = {
      x: vertical ? 0 : -import_free_layout_core11.POINT_RADIUS,
      y: vertical ? -import_free_layout_core11.POINT_RADIUS : 0
    };
    const points = this.getManhattanPoints({
      source: {
        x: fromPos.x + sourceOffset.x,
        y: fromPos.y + sourceOffset.y
      },
      target: {
        x: toPos.x + targetOffset.x,
        y: toPos.y + targetOffset.y
      },
      vertical
    });
    const bbox = import_utils8.Rectangle.createRectangleWithTwoPoints(
      points.reduce(
        (min, p) => ({
          x: Math.min(min.x, p.x),
          y: Math.min(min.y, p.y)
        }),
        points[0]
      ),
      points.reduce(
        (max, p) => ({
          x: Math.max(max.x, p.x),
          y: Math.max(max.y, p.y)
        }),
        points[0]
      )
    );
    const adjustedPoints = points.map((p) => ({
      x: p.x - bbox.x + LINE_PADDING,
      y: p.y - bbox.y + LINE_PADDING
    }));
    const path = this.getPathFromPoints(adjustedPoints);
    this.data = {
      points,
      path,
      bbox
    };
  }
  getManhattanPoints(params) {
    const { source, target, vertical } = params;
    const points = [source];
    if (vertical) {
      if (source.y !== target.y) {
        points.push({ x: source.x, y: target.y });
      }
      if (source.x !== target.x) {
        points.push({ x: target.x, y: target.y });
      }
    } else {
      if (source.x !== target.x) {
        points.push({ x: target.x, y: source.y });
      }
      if (source.y !== target.y) {
        points.push({ x: target.x, y: target.y });
      }
    }
    if (points[points.length - 1] !== target) {
      points.push(target);
    }
    return points;
  }
  getPathFromPoints(points) {
    return points.reduce((path, point, index) => {
      if (index === 0) {
        return `M ${point.x} ${point.y}`;
      }
      return `${path} L ${point.x} ${point.y}`;
    }, "");
  }
};
WorkflowManhattanLineContribution.type = "WorkflowManhattanLineContribution";

// src/create-free-lines-plugin.ts
var createFreeLinesPlugin = (0, import_core3.definePluginCreator)({
  singleton: true,
  onInit: (ctx, opts) => {
    ctx.playground.registerLayer(WorkflowLinesLayer, {
      ...opts
    });
  },
  onReady: (ctx, opts) => {
    const linesManager = ctx.container.get(import_free_layout_core12.WorkflowLinesManager);
    linesManager.registerContribution(WorkflowBezierLineContribution).registerContribution(WorkflowFoldLineContribution);
    if (opts.contributions) {
      opts.contributions.forEach((contribution) => {
        linesManager.registerContribution(contribution);
      });
    }
    if (opts.defaultLineType) {
      linesManager.switchLineType(opts.defaultLineType);
    }
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BezierControlType,
  LINE_OFFSET,
  LINE_PADDING,
  LinesLayer,
  WorkflowArkLineContribution,
  WorkflowBezierLineContribution,
  WorkflowFoldLineContribution,
  WorkflowLinesLayer,
  WorkflowManhattanLineContribution,
  WorkflowPortRender,
  WorkflowStraightLineContribution,
  createFreeLinesPlugin,
  getBezierHorizontalControlPoints,
  getBezierVerticalControlPoints
});
//# sourceMappingURL=index.js.map