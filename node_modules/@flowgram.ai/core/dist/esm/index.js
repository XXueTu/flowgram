var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

// src/common/schema/origin-schema.ts
import { OriginSchemaDecoration, Schema } from "@flowgram.ai/utils";

// src/common/entity-data.ts
import { Compare as Compare2, DisposableImpl, Emitter as Emitter2 } from "@flowgram.ai/utils";

// src/common/entity.ts
import { nanoid } from "nanoid";
import { Compare, Disposable, DisposableCollection, Emitter } from "@flowgram.ai/utils";
var ObjectProto = Object.__proto__;
var _version = 0;
var Entity = class {
  constructor(opts) {
    this.onEntityChangeEmitter = new Emitter();
    this.onDataChangeEmitter = new Emitter();
    this.initializeDataKeys = [];
    // 初始化的
    this.dataManager = /* @__PURE__ */ new Map();
    // 存储的数据
    // readonly onBeforeAbleDispatchedEmitter = new Emitter<Able>();
    //
    // readonly onAfterAbleDispatchedEmitter = new Emitter<Able>();
    /**
     * 销毁事件管理
     */
    this.toDispose = new DisposableCollection();
    /**
     * 销毁前事件管理
     */
    this.preDispose = new DisposableCollection();
    // /**
    //  * able 管理
    //  */
    // readonly ables: EntityAbles;
    /**
     * 修改会触发
     */
    this.onEntityChange = this.onEntityChangeEmitter.event;
    // /**
    //  * able 触发之前
    //  */
    // readonly onBeforeAbleDispatched = this.onBeforeAbleDispatchedEmitter.event;
    // /**
    //  * able 触发之后
    //  */
    // readonly onAfterAbleDispatched = this.onAfterAbleDispatchedEmitter.event;
    /**
     * 数据更改事件
     */
    this.onDataChange = this.onDataChangeEmitter.event;
    this._changeLockedTimes = 0;
    this.isInitialized = true;
    this._version = _version++;
    // 每次创建都有一个新 version，避免 id 相同的 entity 频繁创建销毁导致碰撞
    this._savedInManager = true;
    this.entityManager = opts.entityManager;
    this._id = opts.id || nanoid();
    this._savedInManager = opts.savedInManager === void 0 ? true : opts.savedInManager;
    this.isInitialized = true;
    this.toDispose.push(this.onEntityChangeEmitter);
    this.toDispose.push(this.onDataChangeEmitter);
    this.register();
    if (opts.datas) {
      opts.datas.forEach((data) => this.addData(data.registry, data.data));
    }
    this.isInitialized = false;
  }
  // /**
  //  * able 数据更改
  //  */
  // readonly onAbleChange: Event<AbleChangedEvent>;
  // /**
  //  * 默认初始化的 Able
  //  */
  // getDefaultAbleRegistries(): AbleRegistry[] {
  //   return [];
  // }
  /**
   * 默认初始化的 Data
   */
  getDefaultDataRegistries() {
    return [];
  }
  // readonly ableManager: AbleManager;
  /**
   * 暂停更新开关
   * @protected
   */
  get changeLocked() {
    return this._changeLockedTimes > 0;
  }
  set changeLocked(changeLocked) {
    this._changeLockedTimes = changeLocked ? this._changeLockedTimes + 1 : this._changeLockedTimes - 1;
    if (this._changeLockedTimes < 0) this._changeLockedTimes = 0;
  }
  /**
   * 实体类型
   */
  get type() {
    if (!this.constructor.type) {
      throw new Error(`Entity Registry need a type: ${this.constructor.name}`);
    }
    return this.constructor.type;
  }
  get context() {
    return this.entityManager.context;
  }
  addInitializeData(datas, dataConfig) {
    this.isInitialized = true;
    datas.forEach((data) => this.addData(data, dataConfig));
    this.isInitialized = false;
  }
  /**
   * 实体的版本
   */
  get version() {
    return this._version;
  }
  /**
   * 存储数据，用于持久化存储
   */
  toJSON() {
    const dataList = [];
    for (const data of this.dataManager.values()) {
      dataList.push({
        type: data.type,
        data: data.toJSON()
      });
    }
    return {
      type: this.type,
      id: this.id,
      // ableList: this.ables.toJSON(),
      dataList
    };
  }
  /**
   * 还原数据
   */
  fromJSON(data) {
    if (!data || !data.id || !data.type) return;
    this.changeLocked = true;
    this.reset();
    if (data.dataList) {
      data.dataList.forEach((d) => {
        const registry = this.entityManager.getDataRegistryByType(d.type);
        if (registry) {
          const dataEntity = this.addData(registry);
          dataEntity.update(d.data);
        }
      });
    }
    this.changeLocked = false;
    this.fireChange();
  }
  /**
   * 实体 id
   */
  get id() {
    return this._id;
  }
  /**
   * 销毁实体
   */
  dispose() {
    this.preDispose.dispose();
    this.toDispose.dispose();
  }
  get disposed() {
    return this.toDispose.disposed;
  }
  /**
   * 重制为初始化状态
   */
  reset() {
    this.changeLocked = true;
    for (const data of this.dataManager.values()) {
      if (!this.initializeDataKeys.includes(data.type)) {
        data.dispose();
      }
    }
    this.register();
    this.changeLocked = false;
    this.fireChange();
  }
  /**
   * 销毁事件
   */
  get onDispose() {
    return this.toDispose.onDispose;
  }
  /**
   * 触发实体更新
   * @protected
   */
  fireChange() {
    if (this.changeLocked || this.isInitialized || this.disposed) return;
    this._version++;
    if (this._version >= Number.MAX_SAFE_INTEGER) {
      this._version = 0;
    }
    this.onEntityChangeEmitter.fire(this);
  }
  /**
   * 添加数据
   */
  addData(Registry, defaultProps) {
    this.entityManager.registerEntityData(Registry);
    let entityData = this.dataManager.get(Registry.type);
    if (entityData) {
      if (defaultProps) this.updateData(Registry, defaultProps);
      return entityData;
    }
    const injector = this.entityManager.getDataInjector(Registry);
    entityData = new Registry(this, injector?.());
    if (this.isInitialized) this.initializeDataKeys.push(entityData.type);
    this.dataManager.set(Registry.type, entityData);
    this.toDispose.push(entityData);
    entityData.onDataChange(() => {
      const event2 = {
        type: "update",
        data: entityData,
        entity: this
      };
      this.onDataChangeEmitter.fire(event2);
      this.fireChange();
    });
    entityData.toDispose.push(
      Disposable.create(() => {
        if (!this.initializeDataKeys.includes(Registry.type)) {
          this.dataManager.delete(Registry.type);
        }
        const event2 = {
          type: "delete",
          data: entityData,
          entity: this
        };
        this.onDataChangeEmitter.fire(event2);
        this.fireChange();
      })
    );
    entityData.changeLocked = true;
    this.updateData(Registry, defaultProps || entityData.getDefaultData());
    entityData.changeLocked = false;
    const event = {
      type: "add",
      data: entityData,
      entity: this
    };
    this.onDataChangeEmitter.fire(event);
    return entityData;
  }
  /**
   * 是否存到全局 manager，默认 true
   */
  get savedInManager() {
    return this._savedInManager;
  }
  /**
   * 更新实体的数据
   */
  updateData(Registry, props) {
    const entityData = this.dataManager.get(Registry.type);
    if (entityData) {
      entityData.update(props);
    }
  }
  /**
   * 获取 data 数据
   */
  getData(Registry) {
    return this.dataManager.get(Registry.type);
  }
  /**
   * 是否有指定数据
   */
  hasData(Registry) {
    return this.dataManager.has(Registry.type);
  }
  /**
   * 删除数据，初始化状态注入的数据无法被删除
   */
  removeData(Registry) {
    if (this.initializeDataKeys.includes(Registry.type)) return;
    const entityData = this.dataManager.get(Registry.type);
    if (entityData) {
      entityData.dispose();
    }
  }
  /**
   * 获取 IOC 服务
   * @param identifier
   */
  getService(identifier) {
    return this.entityManager.getService(identifier);
  }
  // /**
  //  * 添加 able
  //  */
  // addAbles(...ables: AbleRegistry[]): void {
  //   ables.forEach(able => this.ables.add(able));
  // }
  //
  // /**
  //  * 删除 able
  //  */
  // removeAbles(...ables: AbleRegistry[]): void {
  //   ables.forEach(able => this.ables.remove(able));
  // }
  //
  // /**
  //  * 是否有 able
  //  */
  // hasAble(able: AbleRegistry): boolean {
  //   return this.ables.has(able);
  // }
  //
  // hasAbles(...ables: AbleRegistry[]): boolean {
  //   for (const able of ables) {
  //     if (!this.ables.has(able)) return false;
  //   }
  //   return true;
  // }
  register() {
    this.getDefaultDataRegistries().forEach((Registry) => this.addData(Registry));
  }
};
Entity.type = "Entity";
((Entity5) => {
  function getType(registry) {
    return registry.type;
  }
  Entity5.getType = getType;
  function checkDataChanged(oldProps, newProps) {
    return Compare.isChanged(oldProps, newProps);
  }
  Entity5.checkDataChanged = checkDataChanged;
  function isRegistryOf(target, Registry) {
    if (target === Registry) return true;
    let proto = target.__proto__;
    while (proto && proto !== ObjectProto) {
      if (proto.prototype === Registry.prototype) return true;
      proto = proto.__proto__;
    }
    return false;
  }
  Entity5.isRegistryOf = isRegistryOf;
})(Entity || (Entity = {}));

// src/common/entity-data.ts
var EntityData = class extends DisposableImpl {
  constructor(entity, opts) {
    super();
    this.opts = opts;
    this.onDataChangeEmitter = new Emitter2();
    this.onWillChangeEmitter = new Emitter2();
    this._changeLocked = false;
    this._version = 0;
    /**
     * 修改后触发
     */
    this.onDataChange = this.onDataChangeEmitter.event;
    /**
     * 修改前触发
     */
    this.onWillChange = this.onWillChangeEmitter.event;
    this.entity = entity;
    this._data = this.getDefaultData();
    this.toDispose.push(this.onDataChangeEmitter);
    this.toDispose.push(this.onWillChangeEmitter);
  }
  /**
   * data 类型
   */
  get type() {
    if (!this.constructor.type) {
      throw new Error(`Entity Data Registry need a type: ${this.constructor.name}`);
    }
    return this.constructor.type;
  }
  /**
   * 当前数据
   */
  get data() {
    return this._data;
  }
  /**
   * 更新单个数据
   */
  update(props, value) {
    if (arguments.length === 2) {
      if (this._data[props] !== value) {
        this.fireWillChange();
        this._data[props] = value;
        this.fireChange();
      }
    } else if (this.checkChanged(props)) {
      this.fireWillChange();
      if (typeof props !== "object") {
        this._data = props;
      } else {
        this._data = { ...this._data, ...props };
      }
      this.fireChange();
    }
  }
  /**
   * 更新全量数据
   * @param props
   */
  fullyUpdate(props) {
    if (Compare2.isChanged(this._data, props, 1, false)) {
      this.fireWillChange();
      this._data = props;
      this.fireChange();
    }
  }
  /**
   * @deprecated
   * 检测属性是否更改，默认采用浅比较
   */
  checkChanged(newProps) {
    return Entity.checkDataChanged(this._data, newProps);
  }
  /**
   * 存储数据，一般在关闭浏览器后需要暂时存到 localStorage
   */
  toJSON() {
    return this.data;
  }
  /**
   * 还原数据
   */
  fromJSON(data) {
    this.update(data);
  }
  get changeLocked() {
    return this._changeLocked;
  }
  set changeLocked(p) {
    this._changeLocked = p;
  }
  fireWillChange() {
    this.onWillChangeEmitter.fire(this);
  }
  fireChange() {
    if (this._changeLocked) return;
    this._version++;
    if (this._version >= Number.MAX_SAFE_INTEGER) {
      this._version = 0;
    }
    this.onDataChangeEmitter.fire(this);
  }
  bindChange(data, fn) {
    this.toDispose.push(
      data.onDataChange(() => {
        if (fn) fn();
        this.fireChange();
      })
    );
  }
  get version() {
    return this._version;
  }
};
EntityData.type = "EntityData";

// src/common/schema/origin-schema.ts
var OriginData = class extends EntityData {
  getDefaultData() {
    return Schema.createDefault(OriginSchemaDecoration);
  }
  get x() {
    return this.data.x;
  }
  get y() {
    return this.data.y;
  }
  set x(x) {
    this.update("x", x);
  }
  set y(y) {
    this.update("y", y);
  }
};
OriginData.type = "OriginData";

// src/common/schema/opacity-schema.ts
import { OpacitySchemaDecoration, Schema as Schema2 } from "@flowgram.ai/utils";
var OpacityData = class extends EntityData {
  getDefaultData() {
    return Schema2.createDefault(OpacitySchemaDecoration);
  }
};
OpacityData.type = "OpacityData";

// src/common/schema/position-schema.ts
import { PositionSchemaDecoration, Schema as Schema3 } from "@flowgram.ai/utils";
var PositionData = class extends EntityData {
  getDefaultData() {
    return Schema3.createDefault(PositionSchemaDecoration);
  }
  get x() {
    return this.data.x;
  }
  get y() {
    return this.data.y;
  }
  set x(x) {
    this.update("x", x);
  }
  set y(y) {
    this.update("y", y);
  }
};
PositionData.type = "PositionData";

// src/common/schema/rotation-schema.ts
import { RotationSchemaDecoration, Schema as Schema4 } from "@flowgram.ai/utils";
var RotationData = class extends EntityData {
  getDefaultData() {
    return Schema4.createDefault(RotationSchemaDecoration);
  }
};
RotationData.type = "RotationData";

// src/common/schema/scale-schema.ts
import { ScaleSchemaDecoration, Schema as Schema5 } from "@flowgram.ai/utils";
var ScaleData = class extends EntityData {
  getDefaultData() {
    return Schema5.createDefault(ScaleSchemaDecoration);
  }
  get x() {
    return this.data.x;
  }
  get y() {
    return this.data.y;
  }
  set x(x) {
    this.update("x", x);
  }
  set y(y) {
    this.update("y", y);
  }
};
ScaleData.type = "ScaleData";

// src/common/schema/size-schema.ts
import { SizeSchema, SizeSchemaDecoration, Schema as Schema6 } from "@flowgram.ai/utils";
var SizeData = class extends EntityData {
  getDefaultData() {
    return Schema6.createDefault(SizeSchemaDecoration);
  }
  get width() {
    return this.data.width;
  }
  get height() {
    return this.data.height;
  }
  set width(width) {
    this.update("width", width);
  }
  set height(height) {
    this.update("height", height);
  }
  get locked() {
    return !!this.data.locked;
  }
  set locked(locked) {
    this.update("locked", locked);
  }
};
SizeData.type = "SizeData";

// src/common/schema/skew-schema.ts
import { SkewSchemaDecoration, Schema as Schema7 } from "@flowgram.ai/utils";
var SkewData = class extends EntityData {
  getDefaultData() {
    return Schema7.createDefault(SkewSchemaDecoration);
  }
  get x() {
    return this.data.x;
  }
  get y() {
    return this.data.y;
  }
  set x(x) {
    this.update("x", x);
  }
  set y(y) {
    this.update("y", y);
  }
};
SkewData.type = "SkewData";

// src/common/schema/transform-schema.ts
import {
  Angle,
  Circle,
  Disposable as Disposable2,
  DisposableCollection as DisposableCollection2,
  Matrix,
  PI_2,
  RAD_TO_DEG,
  Rectangle as Rectangle2,
  Schema as Schema8,
  TransformSchema,
  TransformSchemaDecoration
} from "@flowgram.ai/utils";

// src/common/utils/bounds.ts
import { Point, Rectangle } from "@flowgram.ai/utils";
var { fixZero } = Point;
var Bounds;
((Bounds2) => {
  function getPointWithMatrix(output, matrix) {
    if (matrix) {
      matrix.apply(output, output);
    }
    fixZero(output);
    return output;
  }
  Bounds2.getPointWithMatrix = getPointWithMatrix;
  function getBounds(target, matrix) {
    const output = new Rectangle();
    if (!matrix || matrix.isSimple()) {
      const { size, origin } = target;
      output.x = -(size.width * origin.x) + (matrix?.tx || 0);
      output.y = -(size.height * origin.y) + (matrix?.ty || 0);
      output.width = size.width;
      output.height = size.height;
      fixZero(output);
    } else {
      const topLeft = getTopLeft(target, matrix);
      const topRight = getTopRight(target, matrix);
      const bottomLeft = getBottomLeft(target, matrix);
      const bottomRight = getBottomRight(target, matrix);
      output.x = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
      output.y = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
      output.width = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x) - output.x;
      output.height = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y) - output.y;
    }
    return output;
  }
  Bounds2.getBounds = getBounds;
  function applyMatrix(bounds, matrix) {
    const output = new Rectangle();
    if (matrix.isSimple()) {
      output.x = bounds.x + matrix.tx;
      output.y = bounds.y + matrix.ty;
      output.width = bounds.width;
      output.height = bounds.height;
      fixZero(output);
    } else {
      const topLeft = getPointWithMatrix(bounds.leftTop, matrix);
      const topRight = getPointWithMatrix(bounds.rightTop, matrix);
      const bottomLeft = getPointWithMatrix(bounds.leftBottom, matrix);
      const bottomRight = getPointWithMatrix(bounds.rightBottom, matrix);
      output.x = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
      output.y = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
      output.width = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x) - output.x;
      output.height = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y) - output.y;
    }
    return output;
  }
  Bounds2.applyMatrix = applyMatrix;
  function getLeftPointFromBounds(target, matrix) {
    const topLeft = getTopLeft(target, matrix);
    const topRight = getTopRight(target, matrix);
    const bottomLeft = getBottomLeft(target, matrix);
    const bottomRight = getBottomRight(target, matrix);
    const items = [topLeft, topRight, bottomLeft, bottomRight].sort((p1, p2) => p1.x - p2.x);
    return items[0];
  }
  Bounds2.getLeftPointFromBounds = getLeftPointFromBounds;
  function getTopPointFromBounds(target, matrix) {
    const topLeft = getTopLeft(target, matrix);
    const topRight = getTopRight(target, matrix);
    const bottomLeft = getBottomLeft(target, matrix);
    const bottomRight = getBottomRight(target, matrix);
    const items = [topLeft, topRight, bottomLeft, bottomRight].sort((p1, p2) => p1.y - p2.y);
    return items[0];
  }
  Bounds2.getTopPointFromBounds = getTopPointFromBounds;
  function getCenter(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x) + size.width / 2,
      y: -(size.height * origin.y) + size.height / 2
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getCenter = getCenter;
  function getTopLeft(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x),
      y: -(size.height * origin.y)
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getTopLeft = getTopLeft;
  function getTopCenter(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x) + size.width / 2,
      y: -(size.height * origin.y)
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getTopCenter = getTopCenter;
  function getTopRight(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x) + size.width,
      y: -(size.height * origin.y)
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getTopRight = getTopRight;
  function getLeftCenter(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x),
      y: -(size.height * origin.y) + size.height / 2
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getLeftCenter = getLeftCenter;
  function getRightCenter(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x) + size.width,
      y: -(size.height * origin.y) + size.height / 2
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getRightCenter = getRightCenter;
  function getBottomLeft(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x),
      y: -(size.height * origin.y) + size.height
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getBottomLeft = getBottomLeft;
  function getBottomCenter(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x) + size.width / 2,
      y: -(size.height * origin.y) + size.height
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getBottomCenter = getBottomCenter;
  function getBottomRight(target, matrix) {
    const { size, origin } = target;
    const output = {
      x: -(size.width * origin.x) + size.width,
      y: -(size.height * origin.y) + size.height
    };
    return getPointWithMatrix(output, matrix);
  }
  Bounds2.getBottomRight = getBottomRight;
})(Bounds || (Bounds = {}));

// src/common/schema/transform-schema.ts
var TransformData = class extends EntityData {
  constructor(entity) {
    super(entity);
    this._worldTransform = new Matrix();
    this._localTransform = new Matrix();
    this.mutationCache = /* @__PURE__ */ new Map();
    this.sizeToScale = false;
    /**
     * The X-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     */
    this._cx = 1;
    /**
     * The Y-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     */
    this._sx = 0;
    /**
     * The X-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     */
    this._cy = 0;
    /**
     * The Y-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     */
    this._sy = 1;
    /**
     * The locally unique ID of the local transform.
     */
    this._localID = 0;
    /**
     * The locally unique ID of the local transform
     * used to calculate the current local transformation matrix.
     */
    this._currentLocalID = 0;
    /**
     * The locally unique ID of the world transform.
     */
    this._worldID = 0;
    /**
     * The locally unique ID of the parent's world transform
     * used to calculate the current world transformation matrix.
     */
    this._parentID = 0;
    this.bindChange(this.entity.addData(PositionData));
    this.bindChange(this.entity.addData(SizeData));
    this.bindChange(this.entity.addData(OriginData));
    this.bindChange(this.entity.addData(ScaleData));
    this.bindChange(this.entity.addData(SkewData), () => this.updateSkew());
    this.bindChange(this.entity.addData(RotationData), () => this.updateSkew());
  }
  // 标记 size 转成 scale
  get children() {
    return this._children || [];
  }
  clearChildren() {
    if (this._children) {
      this._children.slice().forEach((child) => {
        child.setParent(void 0);
      });
    }
  }
  /**
   * 容器选择框会动态计算子节点大小
   */
  get isContainer() {
    return !!this._children && this._children.length > 0;
  }
  fireChange() {
    if (this.changeLocked) return;
    this._localID++;
    this.mutationCache.clear();
    super.fireChange();
  }
  get localTransform() {
    this.updateLocalTransformMatrix();
    return this._localTransform;
  }
  get worldTransform() {
    this.updateTransformMatrix();
    return this._worldTransform;
  }
  getDefaultData() {
    return Schema8.createDefault(TransformSchemaDecoration);
  }
  update(data) {
    if (data.position) {
      this.entity.updateData(PositionData, data.position);
    }
    if (data.size) {
      this.entity.updateData(SizeData, data.size);
    }
    if (data.origin) {
      this.entity.updateData(OriginData, data.origin);
    }
    if (data.scale) {
      this.entity.updateData(ScaleData, data.scale);
    }
    if (data.skew) {
      this.entity.updateData(SkewData, data.skew);
    }
    if (data.rotation !== void 0) {
      this.entity.updateData(RotationData, data.rotation);
    }
  }
  get position() {
    return this.entity.getData(PositionData);
  }
  set position(position) {
    this.entity.updateData(PositionData, position);
  }
  get size() {
    return this.entity.getData(SizeData);
  }
  set size(size) {
    this.entity.updateData(SizeData, size);
  }
  get origin() {
    return this.entity.getData(OriginData);
  }
  set origin(origin) {
    this.entity.updateData(OriginData, origin);
  }
  get scale() {
    return this.entity.getData(ScaleData);
  }
  set scale(scale) {
    this.entity.updateData(ScaleData, scale);
  }
  get skew() {
    return this.entity.getData(SkewData);
  }
  set skew(skew) {
    this.entity.updateData(SkewData, skew);
  }
  get rotation() {
    return this.entity.getData(RotationData).data;
  }
  set rotation(rotation) {
    this.entity.updateData(RotationData, rotation);
  }
  get data() {
    return TransformSchema.toJSON(this);
  }
  /**
   * Called when the skew or the rotation changes.
   *
   * @protected
   */
  updateSkew() {
    const { rotation } = this;
    this._cx = Math.cos(rotation + this.skew.y);
    this._sx = Math.sin(rotation + this.skew.y);
    this._cy = -Math.sin(rotation - this.skew.x);
    this._sy = Math.cos(rotation - this.skew.x);
    this._localID++;
  }
  /**
   * Updates the local transformation matrix.
   */
  updateLocalTransformMatrix() {
    const lt = this._localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x;
      lt.ty = this.position.y;
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  get localID() {
    return this._localID;
  }
  get worldID() {
    return this._worldID;
  }
  /**
   * Updates the local and the world transformation matrices.
   *
   */
  updateTransformMatrix() {
    const lt = this._localTransform;
    this.updateLocalTransformMatrix();
    let parentTransform = Matrix.TEMP_MATRIX;
    let worldId = 0;
    if (this.parent) {
      parentTransform = this.parent.worldTransform;
      worldId = this.parent._worldID;
    }
    if (this._parentID !== worldId) {
      const pt = parentTransform;
      const wt = this._worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = worldId;
      this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   *
   * matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    const { a, b, c, d } = matrix;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      this.rotation = skewY;
      this.skew.x = this.skew.y = 0;
    } else {
      this.rotation = 0;
      this.skew.x = skewX;
      this.skew.y = skewY;
    }
    this.scale.x = Math.sqrt(a * a + b * b);
    this.scale.y = Math.sqrt(c * c + d * d);
    this.position.x = matrix.tx;
    this.position.y = matrix.ty;
    this.fireChange();
  }
  /**
   * 缓存计算, 缓存只能针对 local, world 加缓存会出问题
   */
  getMutationCache(key, fn) {
    if (this.mutationCache.has(key)) return this.mutationCache.get(key);
    const item = fn();
    this.mutationCache.set(key, item);
    return item;
  }
  get bounds() {
    if (this.isContainer) {
      const children = this._children;
      return Rectangle2.enlarge(children.map((c) => c.bounds));
    }
    return Bounds.getBounds(this, this.worldTransform);
  }
  /**
   * 不旋转的 bounds
   */
  get boundsWithoutRotation() {
    const { center } = this.bounds;
    const { worldScale } = this;
    const size = this.localSize;
    const width = worldScale.x * size.width;
    const height = worldScale.y * size.height;
    const leftTop = {
      x: center.x - width / 2,
      y: center.y - height / 2
    };
    return new Rectangle2(leftTop.x, leftTop.y, width, height);
  }
  /**
   * 本身的大小
   */
  get localSize() {
    let { size } = this;
    if (this.isContainer) {
      const childrenBounds = Rectangle2.enlarge(this.children.map((c) => c.localBounds));
      size = {
        width: childrenBounds.width,
        height: childrenBounds.height
      };
    }
    return {
      width: size.width,
      height: size.height
    };
  }
  get worldSize() {
    const { localSize } = this;
    const { worldScale } = this;
    return {
      width: localSize.width * worldScale.x,
      height: localSize.height * worldScale.y
    };
  }
  /**
   * 本地 bounds
   */
  get localBounds() {
    if (this.isContainer) {
      const children = this._children;
      const childrenBounds = Rectangle2.enlarge(children.map((c) => c.localBounds));
      return Bounds.applyMatrix(childrenBounds, this.localTransform);
    }
    return this.getMutationCache(
      "localBounds",
      () => Bounds.getBounds(this, this.localTransform)
    );
  }
  /**
   * 判断是否包含点
   * @param x
   * @param y
   * @param asCircle - 以圆形来算，TODO 目前不支持椭圆形
   */
  contains(x, y, asCircle) {
    if (this.isContainer) {
      return this.bounds.contains(x, y);
    }
    const tempPoint = this.worldTransform.applyInverse({ x, y });
    const { width, height } = this.size;
    if (width === 0 || height === 0) return false;
    const x1 = -width * this.origin.x;
    const y1 = -height * this.origin.y;
    if (asCircle) {
      const circle = new Circle(x1 + width / 2, y1 + height / 2, Math.min(width / 2, height / 2));
      return circle.contains(tempPoint.x, tempPoint.y);
    }
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  get parent() {
    return this._parent;
  }
  isParent(parent) {
    let currentParent = this.parent;
    while (currentParent) {
      if (currentParent === parent) return true;
      currentParent = currentParent.parent;
    }
    return false;
  }
  isParentTransform(parent) {
    let currentParent = this.parent;
    while (currentParent) {
      if (currentParent === parent) return true;
      currentParent = currentParent.parent;
    }
    return false;
  }
  setParent(parent, listenParentData = true) {
    if (this._parent !== parent) {
      if (this._parentChangedDispose) {
        this._parentChangedDispose.dispose();
        this._parentChangedDispose = void 0;
      }
      this._parentID = -1;
      if (parent && listenParentData) {
        if (!parent._children) parent._children = [];
        parent._children.push(this);
        this._parentChangedDispose = new DisposableCollection2();
        this.toDispose.push(this._parentChangedDispose);
        this._parentChangedDispose.pushAll([
          parent.onDispose(() => {
            this.setParent(void 0);
          }),
          Disposable2.create(() => {
            const index = parent._children.indexOf(this);
            if (index !== -1) {
              parent._children.splice(index, 1);
            }
          })
        ]);
      }
      this._parent = parent;
      this.fireChange();
    }
  }
  /**
   * 判断矩形碰撞
   */
  intersects(rect) {
    if (!this.isContainer && (this.size.width === 0 || this.size.height === 0)) return false;
    return Rectangle2.intersectsWithRotation(
      this.boundsWithoutRotation,
      this.worldRotation,
      rect,
      0
    );
  }
  /**
   * 全局的 scale
   */
  get worldScale() {
    const { parent } = this;
    const parentScale = parent ? parent.worldScale : { x: 1, y: 1 };
    return {
      x: this.scale.x * parentScale.x,
      y: this.scale.y * parentScale.y
    };
  }
  /**
   * 全局的 rotation
   */
  get worldRotation() {
    const { parent } = this;
    if (parent) {
      return Angle.wrap(this.rotation + parent.worldRotation);
    }
    return Angle.wrap(this.rotation);
  }
  /**
   * 全局的角度
   */
  get worldDegree() {
    return Math.round(this.worldRotation * RAD_TO_DEG);
  }
  get localOrigin() {
    const matrix = this.localTransform;
    const bounds = this.localBounds;
    return matrix.apply({
      x: this.origin.x * bounds.width,
      y: this.origin.y * bounds.height
    });
  }
  /**
   * 全局的原点位置
   */
  get worldOrigin() {
    const matrix = this.worldTransform;
    const { bounds } = this;
    return matrix.apply({
      x: this.origin.x * bounds.width,
      y: this.origin.y * bounds.height
    });
  }
  /**
   * 宽转换成 scale，用于图片等无法修改大小的场景
   * @param isWorldSize 是否为绝对大小
   */
  widthToScaleX(width, isWorldSize) {
    const parentScaleX = isWorldSize && this.parent ? this.parent.worldScale.x : 1;
    return width / parentScaleX / this.localSize.width;
  }
  /**
   * 绝对高转换成 scale，用于图片等无法修改大小的场景
   * @param isWorldSize 是否为绝对大小
   */
  heightToScaleY(height, isWorldSize) {
    const parentScaleY = isWorldSize && this.parent ? this.parent.worldScale.y : 1;
    return height / parentScaleY / this.localSize.height;
  }
  sizeToScaleValue(size, isWorldSize) {
    return {
      x: this.widthToScaleX(size.width, isWorldSize),
      y: this.heightToScaleY(size.height, isWorldSize)
    };
  }
};
TransformData.type = "TransformData";
((TransformData2) => {
  function isParentOrChildrenTransform(dragableEntities, target) {
    const targetTransform = target.getData(TransformData2);
    if (!targetTransform) return false;
    for (const dragger of dragableEntities.values()) {
      const draggerTransform = dragger.getData(TransformData2);
      if (!draggerTransform) continue;
      if (draggerTransform.isParent(targetTransform) || targetTransform.isParent(draggerTransform)) {
        return true;
      }
    }
    return false;
  }
  TransformData2.isParentOrChildrenTransform = isParentOrChildrenTransform;
})(TransformData || (TransformData = {}));

// src/common/entity-manager.ts
import { inject as inject3, injectable, multiInject, optional as optional2, postConstruct } from "inversify";
import { Disposable as Disposable6, DisposableCollection as DisposableCollection3, Emitter as Emitter4 } from "@flowgram.ai/utils";

// src/common/playground-schedule.ts
import { throttle } from "lodash";
var PlaygroundSchedule = class {
  constructor() {
    this.execMap = /* @__PURE__ */ new Map();
  }
  push(key, fn) {
    const { execMap } = this;
    if (process.env.NODE_ENV === "test") {
      fn();
      return;
    }
    let schedule = execMap.get(key);
    if (!schedule) {
      schedule = throttle(fn, 0);
      execMap.set(key, schedule);
    }
    schedule();
  }
  dispose() {
    this.execMap.clear();
  }
};

// src/core/utils/playground-drag.ts
import {
  Disposable as Disposable3,
  Emitter as Emitter3,
  generateLocalId
} from "@flowgram.ai/utils";
var SCROLL_DELTA = 4;
var SCROLL_AUTO_DISTANCE = 20;
var SCROLL_INTERVAL = 20;
function createMouseEvent(type, clientX, clientY) {
  const event = document.createEvent("MouseEvent");
  event.initMouseEvent(
    type,
    true,
    true,
    // @ts-ignore
    void 0,
    0,
    0,
    0,
    clientX,
    clientY,
    false,
    false,
    false,
    false,
    0,
    null
  );
  return event;
}
var PlaygroundDrag = class {
  constructor(options = {}) {
    this.onDragStartEmitter = new Emitter3();
    this.onDragEndEmitter = new Emitter3();
    this.onDragEmitter = new Emitter3();
    this._stopGlobalEventNames = [
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "contextmenu"
    ];
    this.onDrag = this.onDragEmitter.event;
    this.onDragStart = this.onDragStartEmitter.event;
    this.onDragEnd = this.onDragEndEmitter.event;
    this._lastPos = { x: 0, y: 0 };
    /**
     * 自动滚动画布
     */
    this._updateDragScroll = (event) => {
      if (!this._playgroundConfigEntity) return;
      const playgroundConfig = this._playgroundConfigEntity.config;
      const dragPos = event.endPos;
      const { scrollX, width, height, scrollY } = playgroundConfig;
      if (dragPos.x > width + scrollX - SCROLL_AUTO_DISTANCE) {
        this._startScrollX(scrollX, true);
      } else if (dragPos.x < scrollX + SCROLL_AUTO_DISTANCE) {
        this._startScrollX(scrollX, false);
      } else {
        this._stopScrollX();
      }
      if (dragPos.y > height + scrollY - SCROLL_AUTO_DISTANCE) {
        this._startScrollY(scrollY, true);
      } else if (dragPos.y < scrollY + SCROLL_AUTO_DISTANCE) {
        this._startScrollY(scrollY, false);
      } else {
        this._stopScrollY();
      }
    };
    this._disposed = false;
    if (options.onDragStart) this.onDragStart((e) => options.onDragStart(e, this.context));
    if (options.onDrag) this.onDrag((e) => options.onDrag(e, this.context));
    if (options.onDragEnd) this.onDragEnd((e) => options.onDragEnd(e, this.context));
    if (options.stopGlobalEventNames) this._stopGlobalEventNames = options.stopGlobalEventNames;
  }
  get isStarted() {
    return !!this._promise;
  }
  start(clientX, clientY, entity, context) {
    if (this._disposed) {
      return Promise.resolve();
    }
    if (this._promise) {
      return this._promise;
    }
    this.context = context;
    this.localId = generateLocalId();
    this._addListeners();
    this._promise = new Promise((resolve) => {
      this._resolve = resolve;
    });
    this._playgroundConfigEntity = entity;
    const mousedown = createMouseEvent("mousedown", clientX, clientY);
    this._startPos = this.getRelativePos(mousedown);
    this.onDragStartEmitter.fire(this.getDragEvent(mousedown));
    return this._promise;
  }
  stop(clientX, clientY) {
    if (this._disposed || !this._promise) {
      return;
    }
    const mouseup = createMouseEvent("mouseup", clientX, clientY);
    this.handleEvent(mouseup);
  }
  dispose() {
    if (this._disposed) return;
    this._stopScrollX();
    this._stopScrollY();
    this._disposed = true;
    this.onDragEmitter.dispose();
    this.onDragStartEmitter.dispose();
    this.onDragEndEmitter.dispose();
    this._finalize();
  }
  handleEvent(event) {
    switch (event.type) {
      case "mousemove":
        this._evtMouseMove(event);
        break;
      case "mouseup":
        this._stopScrollX();
        this._stopScrollY();
        this._evtMouseUp(event);
        break;
      case "keydown":
        this._evtKeyDown(event);
        break;
      // TODO 暂时屏蔽右键菜单
      case "contextmenu":
        const mouseup = createMouseEvent(
          "mouseup",
          event.clientX,
          event.clientY
        );
        this._evtMouseUp(mouseup);
        break;
      default:
        event.preventDefault();
        event.stopPropagation();
        break;
    }
  }
  get scale() {
    return this._playgroundConfigEntity ? this._playgroundConfigEntity.finalScale : 1;
  }
  getRelativePos(event) {
    if (this._playgroundConfigEntity) {
      return this._playgroundConfigEntity.getPosFromMouseEvent(event, false);
    }
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  getDragEvent(event) {
    const startPos = this._startPos;
    const { scale } = this;
    switch (event.type) {
      case "mousedown":
        this._lastPos = startPos;
        return Object.assign(event, {
          id: this.localId,
          startPos,
          endPos: startPos,
          scale,
          movingDelta: { x: 0, y: 0 },
          isStart: true,
          isMoving: false
        });
      case "mousemove":
        const endPos = this.getRelativePos(event);
        const movingDelta = {
          x: endPos.x - this._lastPos.x,
          y: endPos.y - this._lastPos.y
        };
        this._lastPos = endPos;
        return Object.assign(event, {
          id: this.localId,
          startPos,
          endPos,
          scale,
          isStart: true,
          movingDelta,
          isMoving: true
        });
      case "mouseup":
        this._lastPos = { x: 0, y: 0 };
        return Object.assign(event, {
          id: this.localId,
          startPos,
          endPos: this.getRelativePos(event),
          movingDelta: { x: 0, y: 0 },
          scale,
          isStart: false,
          isMoving: false
        });
      default:
        throw new Error("unknown event");
    }
  }
  _finalize() {
    const resolve = this._resolve;
    this._removeListeners();
    this._startPos = void 0;
    this._promise = void 0;
    this._resolve = void 0;
    if (resolve) {
      resolve();
    }
  }
  /**
   * Handle the `'mousemove'` event for the drag object.
   */
  _evtMouseMove(event) {
    event.preventDefault();
    event.stopPropagation();
    this._lastMouseMoveEvent = event;
    const dragEvent = this.getDragEvent(event);
    this._updateDragScroll(dragEvent);
    this.onDragEmitter.fire(dragEvent);
  }
  /**
   * Handle the `'mouseup'` event for the drag object.
   */
  _evtMouseUp(event) {
    this._lastMouseMoveEvent = void 0;
    event.preventDefault();
    event.stopPropagation();
    if (event.button !== 0 && event.button !== 1) {
      return;
    }
    this.onDragEndEmitter.fire(this.getDragEvent(event));
    this._finalize();
  }
  /**
   * Handle the `'keydown'` event for the drag object.
   */
  _evtKeyDown(event) {
    event.preventDefault();
    event.stopPropagation();
    if (event.keyCode === 27) {
      this.stop(NaN, NaN);
    }
  }
  /**
   * Add the document event listeners for the drag object.
   */
  _addListeners() {
    document.addEventListener("mousedown", this, true);
    document.addEventListener("mousemove", this, true);
    document.addEventListener("mouseup", this, true);
    this._stopGlobalEventNames.forEach((_event) => {
      document.addEventListener(_event, this, true);
    });
  }
  /**
   * Remove the document event listeners for the drag object.
   */
  _removeListeners() {
    document.removeEventListener("mousedown", this, true);
    document.removeEventListener("mousemove", this, true);
    document.removeEventListener("mouseup", this, true);
    this._stopGlobalEventNames.forEach((_event) => {
      document.removeEventListener(_event, this, true);
    });
  }
  _startScrollX(origin, added) {
    if (this._scrollXInterval) {
      return;
    }
    const interval = window.setInterval(() => {
      const current = this._scrollXInterval;
      if (!current) return;
      this.fireScroll("scrollX", added);
    }, SCROLL_INTERVAL);
    this._scrollXInterval = { interval, origin };
  }
  _stopScrollX() {
    if (this._scrollXInterval) {
      clearInterval(this._scrollXInterval.interval);
      this._scrollXInterval = void 0;
    }
  }
  _startScrollY(origin, added) {
    if (this._scrollYInterval) {
      return;
    }
    const interval = window.setInterval(() => {
      this.fireScroll("scrollY", added);
    }, SCROLL_INTERVAL);
    this._scrollYInterval = { interval, origin };
  }
  _stopScrollY() {
    if (this._scrollYInterval) {
      clearInterval(this._scrollYInterval.interval);
      this._scrollYInterval = void 0;
    }
  }
  /**
   * 触发滚动
   * @param scrollKey
   * @param added
   */
  fireScroll(scrollKey, added) {
    const current = scrollKey === "scrollY" ? this._scrollYInterval : this._scrollXInterval;
    if (!current) return;
    const value = current.origin = added ? current.origin + SCROLL_DELTA : current.origin - SCROLL_DELTA;
    const oldScroll = this._playgroundConfigEntity.config[scrollKey];
    this._playgroundConfigEntity.updateConfig({
      [scrollKey]: value
    });
    const newScroll = this._playgroundConfigEntity.config[scrollKey];
    if (newScroll !== oldScroll) {
      const lastMouseMoveEvent = this._lastMouseMoveEvent;
      const delta = {
        x: scrollKey === "scrollX" ? newScroll - current.origin : 0,
        y: scrollKey === "scrollY" ? newScroll - current.origin : 0
      };
      const mouseMove = createMouseEvent(
        "mousemove",
        lastMouseMoveEvent.clientX + delta.x,
        lastMouseMoveEvent.clientY + delta.y
      );
      const dragEvent = this.getDragEvent(mouseMove);
      this.onDragEmitter.fire(dragEvent);
    }
  }
};
var dragCache;
((PlaygroundDrag2) => {
  function startDrag(clientX, clientY, opts = {}) {
    if (dragCache) {
      dragCache.stop(NaN, NaN);
    }
    const dragger = dragCache = new PlaygroundDrag2({
      onDragStart(e, ctx) {
        if (opts.onDragStart) opts.onDragStart(e, ctx);
      },
      onDrag(e, ctx) {
        if (opts.onDrag) opts.onDrag(e, ctx);
      },
      onDragEnd(e, ctx) {
        if (opts.onDragEnd) opts.onDragEnd(e, ctx);
        dragger.dispose();
        if (dragCache === dragger) dragCache = void 0;
      }
    });
    dragger.start(clientX, clientY, opts.config, opts.context);
    return Disposable3.create(() => {
      dragger.stop(0, 0);
      dragger.dispose();
      if (dragCache === dragger) {
        dragCache = void 0;
      }
    });
  }
  PlaygroundDrag2.startDrag = startDrag;
})(PlaygroundDrag || (PlaygroundDrag = {}));

// src/core/utils/tween.ts
import TWEEN from "@tweenjs/tween.js";
import { Disposable as Disposable4 } from "@flowgram.ai/utils";
var started = 0;
function startTweenLoop() {
  started++;
  function animate(time) {
    if (started <= 0) return;
    requestAnimationFrame(animate);
    TWEEN.update(time);
  }
  requestAnimationFrame(animate);
}
function stopTweenLoop() {
  started--;
}
function startTween(opts) {
  startTweenLoop();
  let stopped = false;
  const tween = new TWEEN.Tween(opts.from).to(opts.to, opts.duration).easing(opts.easing || TWEEN.Easing.Quadratic.Out).onUpdate(() => {
    if (stopped) return;
    if (opts.onUpdate) opts.onUpdate(opts.from);
  }).onComplete(() => {
    if (stopped) return;
    stopped = true;
    stopTweenLoop();
    if (opts.onComplete) opts.onComplete(opts.from);
  }).start();
  return Disposable4.create(() => {
    if (stopped) return;
    stopped = true;
    stopTweenLoop();
    tween.stop();
    if (opts.onDispose) opts.onDispose(opts.from);
  });
}
var defaultScrollIntoViewOpts = {
  duration: 300,
  scrollY: true,
  scrollX: true
};
var preTweenMap = /* @__PURE__ */ new WeakMap();
function scrollIntoViewWithTween(opts) {
  opts = { ...defaultScrollIntoViewOpts, ...opts };
  const parentNode = opts.getScrollParent();
  const targetNode = opts.getTargetNode();
  if (!parentNode || !targetNode) return Disposable4.NULL;
  if (preTweenMap.has(parentNode)) {
    preTweenMap.get(parentNode).dispose();
  }
  const startScrollTop = parentNode.scrollTop;
  const startScrollLeft = parentNode.scrollLeft;
  let endScrollTop = startScrollTop;
  let endScrollLeft = startScrollLeft;
  const parentBound = parentNode.getBoundingClientRect();
  const targetBound = targetNode.getBoundingClientRect();
  const top = targetBound.top - parentBound.top + startScrollTop;
  const left = targetBound.left - parentBound.left + startScrollLeft;
  if (startScrollTop > top) {
    endScrollTop = top;
  } else {
    const bottom = top + targetNode.clientHeight - parentNode.clientHeight;
    if (startScrollTop < bottom && targetNode.clientHeight < parentNode.clientHeight) {
      endScrollTop = bottom;
    }
  }
  if (startScrollLeft > left) {
    endScrollLeft = left;
  } else {
    const right = left + targetNode.clientWidth - parentNode.clientWidth;
    if (startScrollLeft < right && targetNode.clientWidth < parentNode.clientWidth) {
      endScrollLeft = right;
    }
  }
  if (startScrollTop !== endScrollTop || startScrollLeft !== endScrollLeft) {
    const from = {};
    const to = {};
    if (opts.scrollY) {
      from.scrollTop = startScrollTop;
      to.scrollTop = endScrollTop;
    }
    if (opts.scrollX) {
      from.scrollLeft = startScrollLeft;
      to.scrollLeft = endScrollLeft;
    }
    const scrollTween = startTween({
      from,
      to,
      onUpdate: (v) => {
        if (v.scrollTop !== void 0) {
          parentNode.scrollTop = v.scrollTop;
        }
        if (v.scrollLeft !== void 0) {
          parentNode.scrollLeft = v.scrollLeft;
        }
      },
      onComplete: () => {
        toDispose.dispose();
      },
      duration: opts.duration
    });
    const toDispose = Disposable4.create(() => {
      scrollTween.dispose();
      preTweenMap.delete(parentNode);
    });
    preTweenMap.set(parentNode, toDispose);
    return toDispose;
  }
  return Disposable4.NULL;
}

// src/core/utils/playground-gesture.ts
import { Disposable as Disposable5, DisposableImpl as DisposableImpl2 } from "@flowgram.ai/utils";

// src/core/utils/use-gesture/core/utils/state.ts
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}

// src/core/utils/use-gesture/core/utils/maths.ts
function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0) return clamp(position, min, max);
  if (position < min) return -rubberband(min - position, max - min, constant) + min;
  if (position > max) return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// src/core/utils/use-gesture/core/utils/events.ts
var EVENT_TYPE_MAP = {
  pointer: { start: "down", change: "move", end: "up" },
  mouse: { start: "down", change: "move", end: "up" },
  touch: { start: "start", change: "move", end: "end" },
  gesture: { start: "start", change: "change", end: "end" }
};
function capitalize(string) {
  if (!string) return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return { device: eventKey, capture, passive };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter(
    (e) => e.target === event.currentTarget || event.currentTarget?.contains?.(e.target)
  );
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return { angle, distance, origin };
  } catch {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let { deltaX, deltaY, deltaMode } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget;
  return [scrollX ?? scrollLeft ?? 0, scrollY ?? scrollTop ?? 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const { shiftKey, altKey, metaKey, ctrlKey } = event;
    Object.assign(payload, { shiftKey, altKey, metaKey, ctrlKey });
  }
  return payload;
}

// src/core/utils/use-gesture/core/utils/fn.ts
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop() {
}
function chain(...fns) {
  if (fns.length === 0) return noop;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}

// src/core/utils/use-gesture/core/engines/Engine.ts
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  /**
   * Shortcut to the gesture state read from the Controller.
   */
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  /**
   * Shortcut to the shared state read from the Controller
   */
  get shared() {
    return this.ctrl.state.shared;
  }
  /**
   * Shortcut to the gesture event store read from the Controller.
   */
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  /**
   * Shortcut to the gesture timeout store read from the Controller.
   */
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  /**
   * Shortcut to the gesture config read from the Controller.
   */
  get config() {
    return this.ctrl.config[this.key];
  }
  /**
   * Shortcut to the shared config read from the Controller.
   */
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  /**
   * Shortcut to the gesture handler read from the Controller.
   */
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const { state, shared, ingKey, args } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  /**
   * Function ran at the start of the gesture.
   * @param event
   */
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  /**
   * Assign raw values to `state._values` and transformed values to
   * `state.values`.
   * @param values
   */
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  /**
   * Assign `state._values` to `state._initial` and transformed `state.values` to
   * `state.initial`.
   * @param values
   */
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  /**
   * Computes all sorts of state attributes, including kinematics.
   * @param event
   */
  compute(event) {
    const { state, config, shared } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const { _step, values } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  /**
   * Fires the gesture handler.
   */
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo = this.handler({ ...shared, ...state, [this.aliasKey]: state.values });
    if (memo !== void 0) state.memo = memo;
  }
  /**
   * Cleans the gesture timeouts and event listeners.
   */
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};

// src/core/utils/use-gesture/core/engines/CoordinatesEngine.ts
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor() {
    super(...arguments);
    this.aliasKey = "xy";
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        // [ x, 0 ]
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};

// src/core/utils/use-gesture/core/engines/WheelEngine.ts
var WheelEngine = class extends CoordinatesEngine {
  constructor() {
    super(...arguments);
    this.ingKey = "wheeling";
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};

// src/core/utils/use-gesture/core/engines/ScrollEngine.ts
var ScrollEngine = class extends CoordinatesEngine {
  constructor() {
    super(...arguments);
    this.ingKey = "scrolling";
  }
  scroll(event) {
    if (!this.state._active) this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};

// src/core/utils/use-gesture/core/engines/PinchEngine.ts
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor() {
    super(...arguments);
    this.ingKey = "pinching";
    this.aliasKey = "da";
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  // superseeds generic Engine reset call
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const { type, movement, lastOffset } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const { offset, lastOffset } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id2) => ctrlTouchIds.has(id2))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id2) => ctrlPointerIds.has(id2))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [
      state._values[0] / state._initial[0] - 1,
      state._values[1] - state._initial[1]
    ];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id2) => !this.ctrl.touchIds.has(id2))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey]))
      return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (process.env.NODE_ENV === "development" && !event.defaultPrevented) {
        console.warn(
          `[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`
        );
      }
    }
    const state = this.state;
    let stepValue = -wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0];
    if (Math.abs(stepValue) > 0.1) {
      stepValue = 0.1 * Math.sign(stepValue);
    }
    state._delta = [stepValue, 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), { passive: false });
    }
  }
};

// src/core/utils/use-gesture/core/engines/MoveEngine.ts
var MoveEngine = class extends CoordinatesEngine {
  constructor() {
    super(...arguments);
    this.ingKey = "moving";
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    if (!this.state._active) this.moveStart(event);
    else this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active) return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};

// src/core/utils/use-gesture/core/engines/HoverEngine.ts
var HoverEngine = class extends CoordinatesEngine {
  constructor() {
    super(...arguments);
    this.ingKey = "hovering";
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    const state = this.state;
    if (!state._active) return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};

// src/core/utils/use-gesture/core/config/commonConfigResolver.ts
var identity = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return { ...config.shared.eventOptions, ...value };
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (process.env.NODE_ENV === "development") {
      const originalTransform = transform || identity;
      return (v) => {
        const r = originalTransform(v);
        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
        }
        return r;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (process.env.NODE_ENV === "development") {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(
          `[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``
        );
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}

// src/core/utils/use-gesture/core/config/coordinatesConfigResolver.ts
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = {
  ...commonConfigResolver,
  axis(_v, _k, { axis }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value;
    return [
      [left, right],
      [top, bottom]
    ];
  }
};

// src/core/utils/use-gesture/core/engines/DragEngine.ts
var KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor() {
    super(...arguments);
    this.ingKey = "dragging";
  }
  // superseeds generic Engine reset call
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  // superseeds Engine clean function
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && // If the user submits an array as pointer.buttons, don't start the drag
    // if event.buttons isn't included inside that array.
    (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : (
      // If the user submits a number as pointer.buttons, refuse the drag if
      // config.pointerButtons is different than `-1` and if event.buttons
      // doesn't match the combination.
      config.pointerButtons !== -1 && config.pointerButtons !== event.buttons
    )))
      return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (
      // in some situations (https://github.com/pmndrs/use-gesture/issues/494#issuecomment-1127584116)
      // like when a new browser tab is opened during a drag gesture, the drag
      // can be interrupted mid-way, and can stall. This happens because the
      // pointerId that initiated the gesture is lost, and since the drag
      // persists until that pointerId is lifted with pointerup, it never ends.
      //
      // Therefore, when we detect that only one pointer is pressing the screen,
      // we consider that the gesture can proceed.
      ctrlIds && ctrlIds.size > 1 && state._pointerActive
    )
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive) return;
    const id2 = pointerId(event);
    if (state._pointerId !== void 0 && id2 !== state._pointerId) return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch {
      if (process.env.NODE_ENV === "development") {
        console.warn(
          `[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`
        );
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive) return;
    const id2 = pointerId(event);
    if (state._pointerId !== void 0 && id2 !== state._pointerId) return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (process.env.NODE_ENV === "development") {
      try {
        if (device === "pointer" && config.preventScrollDelay === void 0) {
          const currentTarget = (
            // @ts-ignore (warning for r3f)
            "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget
          );
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(
              `[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`,
              currentTarget
            );
          }
        }
      } catch {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(
      this.sharedConfig.window,
      "touch",
      "change",
      this.preventScroll.bind(this),
      {
        passive: false
      }
    );
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add(
      "startPointerDrag",
      this.startPointerDrag.bind(this),
      this.config.preventScrollDelay,
      event
    );
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add(
      "dragDelay",
      () => {
        this.state._step = [0, 0];
        this.startPointerDrag(event);
      },
      this.config.delay
    );
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP)) return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), { capture: true, passive: false });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}

// src/core/utils/use-gesture/core/config/wheelConfigResolver.ts
var wheelConfigResolver = coordinatesConfigResolver;

// src/core/utils/use-gesture/core/config/scrollConfigResolver.ts
var scrollConfigResolver = coordinatesConfigResolver;

// src/core/utils/use-gesture/core/config/support.ts
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  /**
   * It looks from https://github.com/pmndrs/use-gesture/discussions/421 that
   * some touchscreens using webkits don't have 'ontouchstart' in window. So
   * we're considering that browsers support TouchEvent if they have
   * `maxTouchPoints > 1`
   *
   * Update 16/09/2023: This generates failure on other Windows systems, so reverting
   * back to detecting TouchEvent support only.
   * https://github.com/pmndrs/use-gesture/issues/626
   */
  touch: supportsTouchEvents(),
  // touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};

// src/core/utils/use-gesture/core/config/pinchConfigResolver.ts
var pinchConfigResolver = {
  ...commonConfigResolver,
  device(_v, _k, { shared, pointer: { touch = false } = {} }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, { scaleBounds = {}, angleBounds = {} }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), { min: -Infinity, max: Infinity });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), { min: -Infinity, max: Infinity });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
};

// src/core/utils/use-gesture/core/config/moveConfigResolver.ts
var moveConfigResolver = {
  ...coordinatesConfigResolver,
  mouseOnly: (value = true) => value
};

// src/core/utils/use-gesture/core/config/hoverConfigResolver.ts
var hoverConfigResolver = {
  ...coordinatesConfigResolver,
  mouseOnly: (value = true) => value
};

// src/core/utils/use-gesture/core/config/dragConfigResolver.ts
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = { mouse: 0, touch: 0, pen: 8 };
var dragConfigResolver = {
  ...coordinatesConfigResolver,
  device(_v, _k, { pointer: { touch = false, lock = false, mouse = false } = {} }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, { preventScroll }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, { pointer: { capture = true, buttons = 1, keys = true } = {} }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, { filterTaps = false, tapsThreshold = 3, axis = void 0 }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({ velocity = DEFAULT_SWIPE_VELOCITY, distance = DEFAULT_SWIPE_DISTANCE, duration = DEFAULT_SWIPE_DURATION } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return { ...DEFAULT_DRAG_AXIS_THRESHOLD, ...value };
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
};
if (process.env.NODE_ENV === "development") {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(
          `[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`
        );
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(
          `[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`
        );
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(
          `[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`
        );
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(
          `[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`
        );
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(
          `[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`
        );
      }
      return NaN;
    }
  });
}

// src/core/utils/use-gesture/core/actions.ts
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// src/core/utils/use-gesture/core/TimeoutStore.ts
var TimeoutStore = class {
  constructor() {
    this._timeouts = /* @__PURE__ */ new Map();
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};

// src/core/utils/use-gesture/core/EventStore.ts
var EventStore = class {
  constructor(ctrl, gestureKey) {
    this._listeners = /* @__PURE__ */ new Set();
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = { ..._options, ...options };
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};

// src/core/utils/use-gesture/core/config/sharedConfigResolver.ts
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({ passive = true, capture = false } = {}) {
    return { passive, capture };
  },
  transform(value) {
    return value;
  }
};

// src/core/utils/use-gesture/core/config/resolver.ts
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r)) result[key] = r;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const { target, eventOptions, window: window2, enabled, transform, ...rest } = newConfig;
  _config.shared = resolveWith({ target, eventOptions, window: window2, enabled, transform }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith({ shared: _config.shared, ...rest }, resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith({ shared: _config.shared, ...rest[key] }, resolver);
      } else if (process.env.NODE_ENV === "development") {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(
            `[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`
          );
        }
      }
    }
  }
  return _config;
}

// src/core/utils/use-gesture/core/Controller.ts
var Controller = class {
  constructor(handlers) {
    /**
     * The list of gestures handled by the Controller.
     */
    this.gestures = /* @__PURE__ */ new Set();
    /**
     * The event store that keeps track of the config.target listeners.
     */
    this._targetEventStore = new EventStore(this);
    /**
     * Object that keeps track of all gesture event listeners.
     */
    this.gestureEventStores = {};
    this.gestureTimeoutStores = {};
    this.handlers = {};
    this.config = {};
    this.pointerIds = /* @__PURE__ */ new Set();
    this.touchIds = /* @__PURE__ */ new Set();
    this.state = {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    };
    resolveGestures(this, handlers);
  }
  /**
   * Sets pointer or touch ids based on the event.
   * @param event
   */
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  /**
   * Attaches handlers to the controller.
   * @param handlers
   * @param nativeHandlers
   */
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  /**
   * Compute and attaches a config to the controller.
   * @param config
   * @param gestureKey
   */
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  /**
   * Cleans all side effects (listeners, timeouts). When the gesture is
   * destroyed (in React, when the component is unmounted.)
   */
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  /**
   * Executes side effects (attaching listeners to a `config.target`). Ran on
   * each render.
   */
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  /**
   * The bind function that can be returned by the gesture handler (a hook in
   * React for example.)
   * @param args
   */
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(
          eventKey,
          "",
          // @ts-ignore
          (event) => this.nativeHandlers[eventKey]({ ...this.state.shared, event, args }),
          void 0,
          true
        );
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const { device, capture, passive } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], { capture, passive });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  const capture = options.capture ?? eventOptions.capture;
  const passive = options.passive ?? eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};

// src/core/utils/use-gesture/core/parser.ts
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    if (process.env.NODE_ENV === "development") {
      console.warn(
        `[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`
      );
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo = void 0;
    if (state.first && startKey in handlers) handlers[startKey](state);
    if (handlerKey in handlers) memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers) handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return { handlers: internalHandlers, config: mergedConfig, nativeHandlers };
}

// src/core/utils/use-gesture/vanilla/Recognizer.ts
var Recognizer = class {
  constructor(target, handlers, config, gestureKey, nativeHandlers) {
    this._target = target;
    this._gestureKey = gestureKey;
    this._ctrl = new Controller(handlers);
    this._ctrl.applyHandlers(handlers, nativeHandlers);
    this._ctrl.applyConfig({ ...config, target }, gestureKey);
    this._ctrl.effect();
  }
  destroy() {
    this._ctrl.clean();
  }
  setConfig(config) {
    this._ctrl.clean();
    this._ctrl.applyConfig({ ...config, target: this._target }, this._gestureKey);
    this._ctrl.effect();
  }
};

// src/core/utils/use-gesture/vanilla/createGesture.ts
function createGesture(actions) {
  actions.forEach(registerAction);
  return function(target, _handlers, _config) {
    const { handlers, nativeHandlers, config } = parseMergedHandlers(_handlers, _config || {});
    return new Recognizer(target, handlers, config, void 0, nativeHandlers);
  };
}

// src/core/utils/use-gesture/vanilla/Gesture.ts
var Gesture = function(target, handlers, config) {
  const gestureFunction = createGesture([
    dragAction,
    pinchAction,
    scrollAction,
    wheelAction,
    moveAction,
    hoverAction
  ]);
  return gestureFunction(target, handlers, config || {});
};

// src/core/utils/playground-gesture.ts
var PlaygroundGesture = class extends DisposableImpl2 {
  constructor(target, config) {
    super();
    this.target = target;
    this.config = config;
    this._pinching = false;
    this.preventDefault();
    const gesture = new Gesture(
      target,
      {
        // onDrag: ({pinching, cancel, offset: [x, y], ...rest}) => {
        //   if (pinching) return cancel();
        //   onChange({ ...style, x, y })
        //   api.start({ x, y })
        // },
        onPinch: ({
          origin: [originX, originY],
          first,
          last,
          movement: [ms],
          offset: [newScale, a]
        }) => {
          this.handlePinch({ first, last, originX, originY, newScale });
        }
      },
      {
        // drag: { from: () => [startState.x, startState.y] },
        pinch: {
          scaleBounds: () => this.getScaleBounds(),
          from: () => [this.config.finalScale, 0],
          /**
           * 支持 command 和 ctrl
           */
          modifierKey: ["metaKey", "ctrlKey"]
          // rubberband: true
        }
      }
    );
    this.toDispose.push(
      Disposable5.create(() => {
        gesture.destroy();
      })
    );
  }
  handlePinch(params) {
    const { first, last, originX, originY, newScale } = params;
    if (Number.isNaN(params.newScale)) {
      return;
    }
    if (first) {
      this._pinching = true;
    }
    if (last) {
      this._pinching = false;
    }
    const oldScale = this.config.finalScale;
    const origin = this.config.getPosFromMouseEvent({ clientX: originX, clientY: originY }, false);
    const finalPos = {
      x: origin.x / oldScale * newScale,
      y: origin.y / oldScale * newScale
    };
    this.config.updateConfig({
      scrollX: this.config.config.scrollX + finalPos.x - origin.x,
      scrollY: this.config.config.scrollY + finalPos.y - origin.y,
      zoom: newScale
    });
  }
  getScaleBounds() {
    return {
      min: this.config.config.minZoom,
      max: this.config.config.maxZoom
    };
  }
  preventDefault() {
    const handler = (e) => e.preventDefault();
    document.addEventListener("gesturestart", handler);
    document.addEventListener("gesturechange", handler);
    this.toDispose.push(
      Disposable5.create(() => {
        document.removeEventListener("gesturestart", handler);
        document.removeEventListener("gesturechange", handler);
      })
    );
  }
  get pinching() {
    return this._pinching;
  }
};

// src/core/utils/inject-provider-decorators.ts
import { inject, optional } from "inversify";
import "reflect-metadata";
var injectByProvider = (provider) => function(target, propertyKey) {
  const providerPropertyKey = `${propertyKey}Provider`;
  inject(provider)(target, providerPropertyKey);
  optional()(target, providerPropertyKey);
  return {
    get() {
      return this[providerPropertyKey]?.();
    },
    configurable: true,
    enumerable: true
  };
};

// src/core/utils/lazy-inject-decorators.ts
import { inject as inject2 } from "inversify";
var LazyInjectContext = Symbol("LazyInjectContext");
var IS_LAZY_INJECT_CONTEXT_INJECTED = Symbol("IS_LAZY_INJECT_CONTEXT_INJECTED");
var lazyInject = (serviceIdentifier) => function(target, propertyKey) {
  if (!serviceIdentifier) {
    throw new Error(
      `ServiceIdentifier ${serviceIdentifier} in @lazyInject is Empty, it might be caused by file circular dependency, please check it.`
    );
  }
  if (!Reflect.hasMetadata(IS_LAZY_INJECT_CONTEXT_INJECTED, target)) {
    inject2(LazyInjectContext)(target, LazyInjectContext);
    Reflect.defineMetadata(IS_LAZY_INJECT_CONTEXT_INJECTED, true, target);
  }
  const descriptor = {
    get() {
      const ctx = this[LazyInjectContext];
      return ctx.get(serviceIdentifier);
    },
    set() {
    },
    configurable: true,
    enumerable: true
  };
  return descriptor;
};

// src/common/playground-context.ts
var PlaygroundContext = Symbol("PlaygroundContext");
var PlaygroundContextProvider = Symbol("PlaygroundContextProvider");
var injectPlaygroundContext = () => injectByProvider(PlaygroundContextProvider);
var bindPlaygroundContextProvider = (bind) => {
  bind(PlaygroundContextProvider).toDynamicValue((ctx) => () => {
    if (ctx.container.isBound(PlaygroundContext)) {
      return ctx.container.get(PlaygroundContext);
    }
    return void 0;
  });
};
var PlaygroundContainerFactory = Symbol("PlaygroundContainerFactory");

// src/common/entity-manager-contribution.ts
var EntityManagerContribution = Symbol("EntityManagerContribution");

// src/common/config-entity.ts
function createConfigDataRegistry(entity) {
  class ConfigData extends EntityData {
    getDefaultData() {
      return entity.getDefaultConfig();
    }
    checkChanged(newProps) {
      return entity.checkChanged(this.data, newProps);
    }
    toJSON() {
      return super.toJSON();
    }
  }
  Object.defineProperty(ConfigData, "type", {
    value: `_${entity.type}DataMixin`
    // value: `_${entity.type}DataMixin_${version++}`,
  });
  return ConfigData;
}
var ConfigEntity = class extends Entity {
  constructor(opts) {
    super(opts);
    this.isInitialized = true;
    this.ConfigDataRegistry = createConfigDataRegistry(this);
    this.addData(this.ConfigDataRegistry);
    this.isInitialized = false;
  }
  getDefaultConfig() {
    return {};
  }
  /**
   * 判断 config 数据是否变化
   */
  checkChanged(oldData, newData) {
    return Entity.checkDataChanged(oldData, newData);
  }
  get config() {
    return this.getData(this.ConfigDataRegistry).data;
  }
  updateConfig(props) {
    this.updateData(this.ConfigDataRegistry, props);
  }
  onConfigChanged(fn) {
    return this.getData(this.ConfigDataRegistry).onDataChange((d) => fn(d.data));
  }
};
ConfigEntity.type = "ConfigEntity";

// src/common/entity-manager.ts
function bindConfigEntity(bind, entityRegistry) {
  bind(entityRegistry).toDynamicValue(
    (ctx) => ctx.container.get(EntityManager).createEntity(entityRegistry)
  ).inSingletonScope();
}
var EntityManager = class {
  constructor() {
    this.toDispose = new DisposableCollection3();
    this.onEntityChangeEmitter = new Emitter4();
    this.onEntityLifeCycleEmitter = new Emitter4();
    this.onEntityDataChangeEmitter = new Emitter4();
    /**
     *  Entity 的类缓存，便于在 fromJSON 时候查询对应的类
     */
    this.registryMap = /* @__PURE__ */ new Map();
    /**
     * Entity 数据类缓存，便于 fromJSON 使用
     */
    this.dataRegistryMap = /* @__PURE__ */ new Map();
    /**
     * Entity 数据类依赖注入器，可用于在EntityData构造器中注入第三方模块
     */
    this.dataInjectorMap = /* @__PURE__ */ new Map();
    /**
     * Entity 的所有实例缓存
     */
    this.entityInstanceMap = /* @__PURE__ */ new Map();
    // By entity id
    /**
     * entity 全局版本更新
     * @protected
     */
    this.entityVersionMap = /* @__PURE__ */ new Map();
    /**
     * data 全局版本更新
     * @protected
     */
    this.entityDataVersionMap = /* @__PURE__ */ new Map();
    /**
     * Entity 的实例按类型缓存，便于查询优化
     */
    this.entityInstanceMapByType = /* @__PURE__ */ new Map();
    // By entity type
    /**
     * 所有配置实体的缓存
     */
    this.configEntities = /* @__PURE__ */ new Map();
    /**
     * 当对应的实体类型变化后触发
     */
    this.onEntityChange = this.onEntityChangeEmitter.event;
    /**
     * entity data 数据变化
     */
    this.onEntityDataChange = this.onEntityDataChangeEmitter.event;
    /**
     * Entity 生命周期变化
     */
    this.onEntityLifeCycleChange = this.onEntityLifeCycleEmitter.event;
    /**
     * 暂停触发实体类型变化
     */
    this.changeEntityLocked = false;
    this.schedule = new PlaygroundSchedule();
    this.fireEntityChanged = (entity) => {
      const entityType = typeof entity === "string" ? entity : entity.type;
      let version = this.entityVersionMap.get(entityType) || 0;
      if (version === Number.MAX_SAFE_INTEGER) {
        version = 0;
      }
      this.entityVersionMap.set(entityType, version + 1);
      if (this.changeEntityLocked) return;
      this.schedule.push(entityType, () => {
        this.onEntityChangeEmitter.fire(entityType);
      });
    };
    this.fireEntityDataChanged = (entityType, entityDataType) => {
      let version = this.entityDataVersionMap.get(entityDataType) || 0;
      if (version === Number.MAX_SAFE_INTEGER) {
        version = 0;
      }
      this.entityDataVersionMap.set(entityDataType, version + 1);
      this.schedule.push(`${entityType}/${entityDataType}`, () => {
        this.onEntityDataChangeEmitter.fire({ entityType, entityDataType });
      });
    };
    this.fireEntityLifeCycleChanged = ({
      type,
      entity
    }) => {
      this.schedule.push(`${type}/${entity.id}`, () => {
        this.onEntityLifeCycleEmitter.fire({ type, entity });
      });
    };
    this.toDispose.pushAll([this.onEntityChangeEmitter, this.schedule]);
  }
  init() {
    this.contributions.forEach((contrib) => contrib.registerEntityManager?.(this));
  }
  /**
   * 创建实体
   */
  createEntity(Registry, opts) {
    if (!Registry.type) {
      throw new Error(`[EntityManager] createEntity need a type: ${Registry}`);
    }
    if (this.configEntities.has(Registry.type)) {
      return this.configEntities.get(Registry.type);
    }
    const entityOpts = {
      entityManager: this,
      savedInManager: true,
      ...opts
    };
    const entity = new Registry(entityOpts);
    if (entityOpts.savedInManager) {
      this.saveEntity(entity);
    }
    return entity;
  }
  isConfigEntity(type) {
    return this.configEntities.has(type);
  }
  /**
   * 批量删除实体
   */
  removeEntities(Registry) {
    for (const e of this.getEntities(Registry).values()) {
      e.dispose();
    }
  }
  removeEntityById(id2) {
    const entity = this.getEntityById(id2);
    if (entity) {
      entity.dispose();
      return true;
    }
    return false;
  }
  /**
   * 触发实体 reset
   * @param registry
   */
  resetEntities(registry) {
    const entities = this.getEntities(registry);
    entities.forEach((entity) => {
      entity.reset();
    });
  }
  resetEntity(registry, autoCreate) {
    const entity = this.getEntity(registry, autoCreate);
    entity?.reset();
  }
  updateConfigEntity(registry, config) {
    const entity = this.configEntities.get(registry.type);
    if (entity) {
      entity.updateConfig(config);
    }
  }
  /**
   * @param type
   */
  getRegistryByType(type) {
    return this.registryMap.get(type);
  }
  registerEntity(Registry) {
    if (!Registry.type) throw new Error(`Registry entity need a type: ${Registry.name}`);
    const oldRegistry = this.registryMap.get(Registry.type);
    if (oldRegistry) {
      if (oldRegistry !== Registry) {
        throw new Error(`Entity registry ${Registry.type} need a new type`);
      }
      return;
    }
    this.registryMap.set(Registry.type, Registry);
  }
  registerEntityData(Registry, injector) {
    if (!Registry.type) throw new Error(`Registry entity data need a type: ${Registry.name}`);
    const oldRegistry = this.dataRegistryMap.get(Registry.type);
    if (!oldRegistry) {
      this.dataRegistryMap.set(Registry.type, Registry);
    }
    const oldInjector = this.dataInjectorMap.get(Registry.type);
    if (!oldInjector && injector) {
      this.dataInjectorMap.set(Registry.type, injector);
    }
  }
  getDataRegistryByType(type) {
    return this.dataRegistryMap.get(type);
  }
  getEntityById(id2) {
    return this.entityInstanceMap.get(id2);
  }
  /**
   * @param autoCreate 是否要自动创建，默认 false
   */
  getEntity(registry, autoCreate) {
    const entity = this.getEntities(registry)[0];
    if (!entity && autoCreate) {
      return this.createEntity(registry);
    }
    return entity;
  }
  getEntities(registry) {
    return this.entityInstanceMapByType.get(registry.type) || [];
  }
  // getEntitiesByAble<T extends Entity>(registry: AbleRegistry): T[] {
  //   return this.ableManager.getEntitiesByAble<T>(registry);
  // }
  //
  // getEntitiesByAbles<T extends Entity>(...registries: AbleRegistry[]): T[] {
  //   return this.ableManager.getEntitiesByAbles<T>(...registries);
  // }
  //
  // getEntityByAble<T extends Entity>(registry: AbleRegistry): T | undefined {
  //   return this.ableManager.getEntityByAble<T>(registry);
  // }
  getEntityDatas(entityRegistry, dataRegistry) {
    return this.getEntities(entityRegistry).map((e) => e.getData(dataRegistry)).filter((d) => !!d);
  }
  hasEntity(registry) {
    return !!this.getEntity(registry);
  }
  /**
   * 只存储 config 数据，忽略动态数据
   */
  storeState({ configOnly = true } = {}) {
    const data = [];
    for (const e of this.entityInstanceMap.values()) {
      if ((!configOnly || e instanceof ConfigEntity) && e.toJSON) {
        if (e.toJSON) {
          const d = e.toJSON();
          if (d) {
            data.push(d);
          }
        }
      }
    }
    return data;
  }
  restoreState(data) {
    if (!data || !Array.isArray(data)) return;
    data.forEach((s) => {
      if (!s || !s.type || !s.id) return;
      const register = this.getRegistryByType(s.type);
      if (!register) {
        console.warn(`Playground entity registry lost: ${s.type}`);
        return;
      }
      const entity = this.createEntity(register, {
        id: s.id
      });
      if (entity.fromJSON) {
        entity.fromJSON(s);
      }
    });
  }
  saveEntity(entity) {
    const { id: id2 } = entity;
    if (id2 && this.entityInstanceMap.has(id2)) {
      console.error(`Entity ${entity.type} ${id2} is created before`);
      return;
    }
    this.entityInstanceMap.set(entity.id, entity);
    let entities = this.entityInstanceMapByType.get(entity.type);
    if (!entities) {
      entities = [];
      this.entityInstanceMapByType.set(entity.type, entities);
    }
    if (entity instanceof ConfigEntity) {
      this.configEntities.set(entity.type, entity);
    }
    entities.push(entity);
    entity.onEntityChange((entity2) => {
      this.fireEntityChanged(entity2);
      this.fireEntityLifeCycleChanged({ type: "update", entity: entity2 });
    });
    entity.onDataChange((e) => {
      this.fireEntityDataChanged(entity.type, e.data.type);
    });
    entity.toDispose.push(
      Disposable6.create(() => {
        this.removeEntity(entity);
        this.fireEntityLifeCycleChanged({ type: "delete", entity });
      })
    );
    entity.getDefaultDataRegistries().forEach((registry) => this.fireEntityDataChanged(entity.type, registry.type));
    this.fireEntityChanged(entity);
    this.fireEntityLifeCycleChanged({ type: "add", entity });
  }
  removeEntity(entity) {
    if (this.entityInstanceMap.has(entity.id) && this.entityInstanceMapByType.has(entity.type)) {
      const entities = this.entityInstanceMapByType.get(entity.type);
      const index = entities.indexOf(entity);
      if (index !== -1) {
        this.entityInstanceMapByType.set(
          entity.type,
          entities.filter((e) => e !== entity)
        );
        this.entityInstanceMap.delete(entity.id);
        if (this.configEntities.has(entity.type)) {
          this.configEntities.delete(entity.type);
        }
        this.fireEntityChanged(entity);
      }
    }
  }
  /**
   * 重制所有 entity 为初始化状态
   */
  reset() {
    for (const entity of this.entityInstanceMap.values()) {
      entity.reset();
    }
  }
  getEntityVersion(registry) {
    return this.entityVersionMap.get(typeof registry === "string" ? registry : registry.type) || 0;
  }
  getEntityDataVersion(registry) {
    return this.entityDataVersionMap.get(typeof registry === "string" ? registry : registry.type) || 0;
  }
  dispose() {
    this.toDispose.dispose();
  }
  getDataInjector(registry) {
    return this.dataInjectorMap.get(typeof registry === "string" ? registry : registry.type);
  }
  getService(identifier) {
    return this.containerFactory?.get(identifier);
  }
};
__decorateClass([
  multiInject(EntityManagerContribution),
  optional2()
], EntityManager.prototype, "contributions", 2);
__decorateClass([
  injectPlaygroundContext()
], EntityManager.prototype, "context", 2);
__decorateClass([
  inject3(PlaygroundContainerFactory),
  optional2()
], EntityManager.prototype, "containerFactory", 2);
__decorateClass([
  postConstruct()
], EntityManager.prototype, "init", 1);
EntityManager = __decorateClass([
  injectable()
], EntityManager);

// src/common/playground-decorator-helper.ts
var ENTITIES_DECO_KEY = Symbol("EntitiesDecorator");
var ENTITIES_BY_DATA_DECO_KEY = Symbol("EntitiesByDataDecorator");
var PROPERTEIS_INJECTED = Symbol("PropertiesInjected");
function getRegistryMetadata(target, key) {
  return Reflect.getMetadata(key, target.prototype) || [];
}
function getRegistryInjectedProperties(target) {
  return Reflect.getMetadata(PROPERTEIS_INJECTED, target) || [];
}
function definePropertiesMetadata(target, property) {
  const properties = getRegistryInjectedProperties(target);
  properties.push(property);
  Reflect.defineMetadata(PROPERTEIS_INJECTED, properties, target);
}
function removeInjectedProperties(instance) {
  if (typeof instance === "object") {
    const propertiesInjected = getRegistryInjectedProperties(instance.constructor.prototype);
    propertiesInjected.forEach((propertyKey) => {
      if (instance.hasOwnProperty(propertyKey) && instance[propertyKey] === void 0) {
        delete instance[propertyKey];
      }
    });
  }
}
function createRegistryDecorator(key, data, getValue, init) {
  return (target, property) => {
    let registries = Reflect.getMetadata(key, target);
    if (!registries) {
      registries = [];
      Reflect.defineMetadata(key, registries, target);
    }
    if (!Array.isArray(data)) {
      data = [data];
    }
    data.forEach((registry) => {
      if (!registries.includes(registry)) {
        registries.push(registry);
      }
    });
    if (init) init(target, property);
    if (property && getValue) {
      definePropertiesMetadata(target, property);
      return {
        enumerable: false,
        configurable: false,
        get() {
          return getValue(this, property);
        }
      };
    }
  };
}
function getEntityMetadata(layer) {
  return getRegistryMetadata(layer, ENTITIES_DECO_KEY);
}
function getEntityDatasMetadata(layer) {
  return getRegistryMetadata(layer, ENTITIES_BY_DATA_DECO_KEY);
}

// src/common/playground-decorators.ts
function observeEntity(registry) {
  const getValue = (target) => target.observeManager.get(registry);
  return createRegistryDecorator(ENTITIES_DECO_KEY, registry, getValue);
}
function observeEntities(registry) {
  const getValue = (target) => target.observeManager.getEntities(registry);
  return createRegistryDecorator(ENTITIES_DECO_KEY, registry, getValue);
}
function observeEntityDatas(entityRegistry, dataRegistry) {
  const getValue = (target) => target.observeManager.getEntityDatas(entityRegistry, dataRegistry);
  return createRegistryDecorator(
    ENTITIES_BY_DATA_DECO_KEY,
    { entity: entityRegistry, data: dataRegistry },
    getValue
  );
}

// src/common/protect-wheel-area.ts
var ProtectWheelArea = Symbol("ProtectWheelArea");

// src/common/index.ts
import { bindContributions, ContributionProvider, bindContributionProvider } from "@flowgram.ai/utils";

// src/core/pipeline/pipeline.ts
var PipelineLayerPriority = /* @__PURE__ */ ((PipelineLayerPriority2) => {
  PipelineLayerPriority2[PipelineLayerPriority2["BASE_LAYER"] = -2] = "BASE_LAYER";
  PipelineLayerPriority2[PipelineLayerPriority2["TOOL_LAYER"] = -1] = "TOOL_LAYER";
  PipelineLayerPriority2[PipelineLayerPriority2["NORMAL_LAYER"] = 0] = "NORMAL_LAYER";
  return PipelineLayerPriority2;
})(PipelineLayerPriority || {});
var PipelineLayerFactory = Symbol("PipelineLayerFactory");

// src/core/pipeline/pipeline-renderer.tsx
import React2 from "react";
import { inject as inject5, injectable as injectable8 } from "inversify";
import {
  ConflatableMessage,
  MessageLoop
} from "@phosphor/messaging";
import { DisposableCollection as DisposableCollection4, domUtils, Emitter as Emitter8 } from "@flowgram.ai/utils";

// src/services/selection-service.ts
import { injectable as injectable2 } from "inversify";
import { Compare as Compare3, Emitter as Emitter5 } from "@flowgram.ai/utils";
var SelectionService = class {
  constructor() {
    this.onSelectionChangedEmitter = new Emitter5();
    this.onSelectionChanged = this.onSelectionChangedEmitter.event;
    this.currentSelection = [];
    this.disposers = [];
  }
  get selection() {
    return this.currentSelection;
  }
  isEmpty() {
    return this.currentSelection.length === 0;
  }
  set selection(selection) {
    if (!Compare3.isArrayShallowChanged(this.currentSelection, selection)) {
      return;
    }
    this.disposers.forEach((disposer) => disposer.dispose());
    this.changeSelection(selection);
    this.disposers = this.currentSelection.map(
      (selection2) => selection2.onDispose(() => {
        const newSelection = this.currentSelection.filter((n) => n !== selection2);
        this.changeSelection(newSelection);
      })
    );
  }
  changeSelection(selection) {
    this.currentSelection = selection;
    this.onSelectionChangedEmitter.fire(this.currentSelection);
  }
  dispose() {
    this.onSelectionChangedEmitter.dispose();
  }
};
SelectionService = __decorateClass([
  injectable2()
], SelectionService);

// src/services/storage-service.ts
import { injectable as injectable3, postConstruct as postConstruct2 } from "inversify";
var StorageService = Symbol("StorageService");
var LocalStorageService = class {
  constructor() {
    this._prefix = "__gedit:";
  }
  setData(key, data) {
    this.storage[this.prefix(key)] = JSON.stringify(data);
  }
  getData(key, defaultValue) {
    const result = this.storage[this.prefix(key)];
    if (result === void 0) {
      return defaultValue;
    }
    return JSON.parse(result);
  }
  prefix(key) {
    return `${this._prefix}${key}`;
  }
  setPrefix(prefix) {
    this._prefix = prefix;
  }
  init() {
    if (typeof window !== "undefined" && window.localStorage) {
      this.storage = window.localStorage;
    } else {
      this.storage = {};
    }
  }
};
__decorateClass([
  postConstruct2()
], LocalStorageService.prototype, "init", 1);
LocalStorageService = __decorateClass([
  injectable3()
], LocalStorageService);

// src/services/clipboard-service.ts
import { injectable as injectable4 } from "inversify";
import { Emitter as Emitter6 } from "@flowgram.ai/utils";
var ClipboardService = Symbol("ClipboardService");
var DefaultClipboardService = class {
  constructor() {
    this.onClipboardChangedEmitter = new Emitter6();
    this.onClipboardChanged = this.onClipboardChangedEmitter.event;
  }
  readText() {
    return this._currentData;
  }
  writeText(value) {
    if (this._currentData !== value) {
      this._currentData = value;
      this.onClipboardChangedEmitter.fire(value);
    }
  }
};
DefaultClipboardService = __decorateClass([
  injectable4()
], DefaultClipboardService);

// src/services/context-menu-service.ts
import { injectable as injectable5 } from "inversify";
var ContextMenuService = class {
  get rightPanelVisible() {
    return this.isRightPanelVisible;
  }
  set rightPanelVisible(visible) {
    this.isRightPanelVisible = visible;
  }
};
ContextMenuService = __decorateClass([
  injectable5()
], ContextMenuService);

// src/services/logger-service.ts
import { injectable as injectable6 } from "inversify";
import { Emitter as Emitter7 } from "@flowgram.ai/utils";
var LoggerEvent = /* @__PURE__ */ ((LoggerEvent2) => {
  LoggerEvent2[LoggerEvent2["CANVAS_TTI"] = 0] = "CANVAS_TTI";
  LoggerEvent2[LoggerEvent2["CANVAS_FPS"] = 1] = "CANVAS_FPS";
  return LoggerEvent2;
})(LoggerEvent || {});
var LoggerService = class {
  constructor() {
    this.onLoggerEmitter = new Emitter7();
    // plugin 内注册：loggerService.onLogger(() => {})
    this.onLogger = this.onLoggerEmitter.event;
  }
  onAllLayersRendered() {
    this.onLoggerEmitter.fire({
      event: 0 /* CANVAS_TTI */
    });
  }
  onFlushRequest(renderFrameInterval) {
    if (renderFrameInterval <= 0) {
      return;
    }
    const fps = 1e3 / renderFrameInterval;
    this.onLoggerEmitter.fire({
      event: 1 /* CANVAS_FPS */,
      props: { rfi: renderFrameInterval, fps }
    });
  }
  dispose() {
    this.onLoggerEmitter.dispose();
  }
};
LoggerService = __decorateClass([
  injectable6()
], LoggerService);

// src/core/pipeline/pipline-react-utils.tsx
import ReactDOM from "react-dom";
import React, { useEffect, useState, useCallback } from "react";
import { NOOP } from "@flowgram.ai/utils";
function OriginComp({
  originRenderer,
  renderedCb
}) {
  useEffect(() => {
    renderedCb();
  }, []);
  return originRenderer() || null;
}
function createLayerReactAutorun(layer, originRenderer, renderedCb, pipelineRenderer) {
  let update = NOOP;
  function PlaygroundReactLayerPortal() {
    const [, refresh] = useState({});
    const handleRendered = useCallback(() => {
      renderedCb(layer);
    }, [layer]);
    useEffect(() => {
      update = () => refresh({});
      return () => {
        update = NOOP;
      };
    });
    let result;
    try {
      result = !pipelineRenderer.isReady ? /* @__PURE__ */ React.createElement(React.Fragment, null) : /* @__PURE__ */ React.createElement(OriginComp, { originRenderer, renderedCb: handleRendered });
    } catch (e) {
      console.error(`Render Layer "${layer.constructor.name}" error `, e);
      result = /* @__PURE__ */ React.createElement(React.Fragment, null);
    }
    return ReactDOM.createPortal(result, layer.node);
  }
  return {
    autorun: () => update(),
    // 这里使用了 memo 缓存隔离，这样做的前提 layer 的刷新完全交给 entity，不受外部干扰
    portal: layer.renderWithReactMemo ? React.memo(PlaygroundReactLayerPortal) : PlaygroundReactLayerPortal
  };
}

// src/core/pipeline/pipeline-entities-selector.ts
import { inject as inject4, injectable as injectable7 } from "inversify";
var PipelineEntitiesSelector = class {
  constructor() {
    this.layerEntitiesSelectorMap = /* @__PURE__ */ new WeakMap();
    this.entityLayerMap = /* @__PURE__ */ new Map();
    this.ableLayerMap = /* @__PURE__ */ new Map();
  }
  /**
   * 订阅关联的 entity，会影响 autorun
   */
  subscribeEntities(layer, entities) {
    const selector = this.getSelector(layer);
    entities.forEach((e) => {
      if (!selector.entities.includes(e)) selector.entities.push(e);
      let layers = this.entityLayerMap.get(e.type);
      if (!layers) {
        layers = /* @__PURE__ */ new Set();
        this.entityLayerMap.set(e.type, layers);
      }
      layers.add(layer);
    });
  }
  // /**
  //  * 订阅关联的 able, 会影响 autorun
  //  */
  // subscribeAbles(layer: Layer, ables: AbleRegistry[]): void {
  //   const selector = this.getSelector(layer);
  //   ables.forEach(able => {
  //     if (!selector.ables.includes(able)) selector.ables.push(able);
  //     let layers = this.ableLayerMap.get(able.type);
  //     if (!layers) {
  //       layers = new Set();
  //       this.ableLayerMap.set(able.type, layers);
  //     }
  //     layers.add(layer);
  //   });
  // }
  /**
   * 订阅 data 数据
   * @param layer
   * @param entity
   * @param data
   */
  subscribleEntityByData(layer, entity, data) {
    const selector = this.getSelector(layer);
    let layers = this.entityLayerMap.get(entity.type);
    if (!layers) {
      layers = /* @__PURE__ */ new Set();
      this.entityLayerMap.set(entity.type, layers);
    }
    layers.add(layer);
    const item = [entity, data];
    if (!selector.datas.find((i) => i[0] === entity && i[1] === data)) selector.datas.push(item);
  }
  getSelector(layer) {
    let selector = this.layerEntitiesSelectorMap.get(layer);
    if (!selector) {
      selector = { entities: [], datas: [] };
      this.layerEntitiesSelectorMap.set(layer, selector);
    }
    return selector;
  }
  /**
   * 查询 layer 关联的实体
   */
  getLayerEntities(layer) {
    const selector = this.layerEntitiesSelectorMap.get(layer);
    if (!selector) return { entities: [], changed: false };
    const allEntities = /* @__PURE__ */ new Set();
    const entityVersion = /* @__PURE__ */ new Map();
    let entityChanged = false;
    selector.entities.forEach((registry) => {
      const entities = this.entityManager.getEntities(registry);
      const version = this.entityManager.getEntityVersion(registry);
      entityVersion.set(registry.type, version);
      for (const item of entities) {
        allEntities.add(item);
      }
    });
    const result = [];
    for (const item of allEntities.values()) {
      result.push(item);
    }
    if (checkChanged(entityVersion, selector.lastEntityVersion)) {
      selector.lastEntityVersion = entityVersion;
      entityChanged = true;
    }
    return {
      entities: result,
      changed: entityChanged
    };
  }
  getLayerEntityDatas(layer) {
    const selector = this.layerEntitiesSelectorMap.get(layer);
    if (!selector) return { datas: [], changed: false };
    const allDatas = [];
    const dataVersion = /* @__PURE__ */ new Map();
    let dataChanged = false;
    selector.datas.forEach((registries) => {
      const [entityRegistry, entityDataRegistry] = registries;
      const entityDatas = this.entityManager.getEntityDatas(entityRegistry, entityDataRegistry);
      const version = this.entityManager.getEntityDataVersion(entityDataRegistry);
      dataVersion.set(entityDataRegistry.type, version);
      for (const item of entityDatas) {
        allDatas.push(item);
      }
    });
    if (checkChanged(dataVersion, selector.lastDataVersion)) {
      selector.lastDataVersion = dataVersion;
      dataChanged = true;
    }
    return {
      datas: allDatas,
      changed: dataChanged
    };
  }
  getLayerData(layer) {
    const entitiesSelector = this.getLayerEntities(layer);
    const datasSelector = this.getLayerEntityDatas(layer);
    return {
      observeEntities: entitiesSelector.entities,
      observeDatas: datasSelector.datas,
      changed: datasSelector.changed || entitiesSelector.changed
    };
  }
};
__decorateClass([
  inject4(EntityManager)
], PipelineEntitiesSelector.prototype, "entityManager", 2);
PipelineEntitiesSelector = __decorateClass([
  injectable7()
], PipelineEntitiesSelector);
function checkChanged(v1 = /* @__PURE__ */ new Map(), v2 = /* @__PURE__ */ new Map()) {
  if (v1.size !== v2.size) return true;
  for (const key of v1.keys()) {
    if (v1.get(key) !== v2.get(key)) return true;
  }
  return false;
}

// src/core/pipeline/pipeline-renderer.tsx
var FLUSH_LAYER_REQUEST = "flush-layer-request";
var id = 0;
var FlushLayerMessage = class extends ConflatableMessage {
  constructor(layer) {
    super(`${FLUSH_LAYER_REQUEST}_layer${id++}`);
    this.layer = layer;
  }
};
var PipelineRenderer = class {
  constructor(selector, entityManager) {
    this.selector = selector;
    this.isReady = false;
    this.onAllLayersRenderedEmitter = new Emitter8();
    this.toDispose = new DisposableCollection4();
    this.layers = [];
    this.forceUpdates = /* @__PURE__ */ new Set();
    this.layerAutorunMap = /* @__PURE__ */ new Map();
    this.layerRenderedMap = /* @__PURE__ */ new Map();
    this.layerFlushMessages = /* @__PURE__ */ new Map();
    this.reactPortals = [];
    this.node = domUtils.createDivWithClass("gedit-playground-pipeline");
    /**
     * 所有 Layer 第一次渲染完成后触发
     */
    this.onAllLayersRendered = this.onAllLayersRenderedEmitter.event;
    this.toDispose.push(
      entityManager.onEntityChange((entityType) => {
        const layers = this.selector.entityLayerMap.get(entityType);
        if (layers) layers.forEach((layer) => this.updateLayer(layer));
      })
    );
    this.toDispose.push(this.onAllLayersRenderedEmitter);
  }
  reportLayerRendered(layer) {
    this.layerRenderedMap.set(layer, true);
    const allLayersRendered = Array.from(this.layerRenderedMap.values()).every((v) => v);
    if (allLayersRendered) {
      this.loggerService.onAllLayersRendered();
      this.onAllLayersRenderedEmitter.fire();
      if (window.REPORT_TTI_FOR_E2E) {
        window.REPORT_TTI_FOR_E2E(
          // 由于 e2e 环境，performance 耗时即为 tti 的完整耗时。
          performance.now(),
          performance.getEntriesByType("resource")
        );
      }
    }
  }
  addLayer(layer) {
    this.layers.push(layer);
    this.toDispose.push(layer);
    this.layerFlushMessages.set(layer, new FlushLayerMessage(layer));
    layer.pipelineNode = this.node;
    layer.playgroundNode = this.node.parentElement;
    if ((layer.autorun || layer.render) && !layer.node) {
      layer.node = document.createElement("div");
    }
    if (layer.node) {
      this.node.appendChild(layer.node);
      layer.node.classList.add("gedit-playground-layer");
    }
    if (layer.autorun) {
      const autorun = layer.autorun.bind(layer);
      this.layerAutorunMap.set(layer, autorun);
      layer.autorun = () => {
        this.updateLayer(layer, true);
      };
    } else if (layer.render) {
      this.layerRenderedMap.set(layer, false);
      const render = layer.render.bind(layer);
      const autorun = createLayerReactAutorun(
        layer,
        render,
        this.reportLayerRendered.bind(this),
        this
      );
      this.reactPortals.push(autorun.portal);
      this.layerAutorunMap.set(layer, autorun.autorun);
      if (process.env.NODE_ENV === "test") {
        layer._render = layer.render;
      }
      layer.render = () => {
        this.updateLayer(layer, true);
      };
    }
  }
  flush(forceUpdate) {
    this.layers.forEach((layer) => {
      this.updateLayer(layer, forceUpdate);
    });
  }
  ready() {
    this.layers.forEach((layer) => {
      this.loadLayerEntities(layer);
      if (layer.onReady) layer.onReady();
    });
    this.isReady = true;
    this.flush(true);
  }
  dispose() {
    this.toDispose.dispose();
    this.node.remove();
  }
  processMessage(msg) {
    if (msg instanceof FlushLayerMessage) {
      this.onFlushRequest(msg.layer);
    }
  }
  loadLayerEntities(layer) {
    const result = this.selector.getLayerData(layer);
    if (result.changed) {
      layer.observeManager.load(
        result.observeEntities,
        result.observeDatas
      );
    }
    return result.changed;
  }
  onFlushRequest(layer) {
    if (!this.isReady || this.toDispose.disposed) return false;
    const startRenderTime = performance.now();
    const trackRenderPerformance = () => {
      const renderDuration = performance.now() - startRenderTime;
      if (renderDuration < 4) {
        return;
      }
      this.loggerService.onFlushRequest(renderDuration);
    };
    const autorun = this.layerAutorunMap.get(layer);
    const changed = this.loadLayerEntities(layer);
    if (autorun && (changed || this.forceUpdates.has(layer))) {
      this.forceUpdates.delete(layer);
      try {
        autorun();
      } catch (e) {
        console.error(e);
      }
      trackRenderPerformance();
      return true;
    }
    trackRenderPerformance();
    return false;
  }
  /**
   * 1. PostMessage: 会将消息在 nextTick 执行
   * 2. ConflatableMessage: 当多个消息进来会在下一个 nextTick 做合并
   * 3. 图层相互隔离，即时一层挂了也不受影响
   */
  updateLayer(layer, forceUpdate) {
    if (forceUpdate) {
      this.forceUpdates.add(layer);
    }
    if (process.env.NODE_ENV === "test") {
      this.onFlushRequest(layer);
    } else {
      MessageLoop.postMessage(this, this.layerFlushMessages.get(layer));
    }
  }
  /**
   * 转成 react
   */
  toReactComponent() {
    if (this.reactComp) return this.reactComp;
    const portals = this.reactPortals;
    const comp = () => /* @__PURE__ */ React2.createElement(React2.Fragment, null, portals.map((Portal, key) => /* @__PURE__ */ React2.createElement(Portal, { key })));
    this.reactComp = comp;
    return comp;
  }
};
__decorateClass([
  inject5(LoggerService)
], PipelineRenderer.prototype, "loggerService", 2);
PipelineRenderer = __decorateClass([
  injectable8(),
  __decorateParam(0, inject5(PipelineEntitiesSelector)),
  __decorateParam(1, inject5(EntityManager))
], PipelineRenderer);

// src/core/pipeline/pipeline-registry.ts
import { inject as inject8, injectable as injectable11 } from "inversify";
import {
  ConflatableMessage as ConflatableMessage2,
  MessageLoop as MessageLoop2
} from "@phosphor/messaging";
import { Disposable as Disposable10, DisposableCollection as DisposableCollection6, Emitter as Emitter11 } from "@flowgram.ai/utils";

// src/core/layer/config/editor-state-config-entity.ts
import { Emitter as Emitter9 } from "@flowgram.ai/utils";
var EditorState;
((EditorState2) => {
  EditorState2.STATE_SELECT = {
    id: "STATE_SELECT",
    cursor: "",
    shortcut: "",
    cancelMode: "hold"
  };
  EditorState2.STATE_MOUSE_FRIENDLY_SELECT = {
    id: "STATE_MOUSE_FRIENDLY_SELECT",
    cursor: "grab",
    // 初始为小手状态
    shortcut: "",
    cancelMode: "hold"
  };
  EditorState2.STATE_GRAB = {
    id: "STATE_GRAB",
    cursor: "grab",
    shortcut: "SPACE",
    // 如果是鼠标模式，这里不用按住 SPACE 就可以拖动
    shortcutAutoEsc: true,
    shortcutWorksOnlyOnStateChanged: true,
    cancelMode: "hold"
  };
})(EditorState || (EditorState = {}));
var EDITOR_STATE_DEFAULTS = [
  EditorState.STATE_SELECT,
  EditorState.STATE_MOUSE_FRIENDLY_SELECT,
  EditorState.STATE_GRAB
];
var EditorStateConfigEntity = class extends ConfigEntity {
  constructor(opts) {
    super(opts);
    this._isPressingSpaceBar = false;
    this._isPressingShift = false;
    this.states = EDITOR_STATE_DEFAULTS.slice();
    this.selected = EditorState.STATE_SELECT.id;
    this.onStateChangeEmitter = new Emitter9();
    this.onStateChange = this.onStateChangeEmitter.event;
    this.toDispose.push(this.onStateChangeEmitter);
  }
  get isPressingSpaceBar() {
    return this._isPressingSpaceBar;
  }
  set isPressingSpaceBar(isPressing) {
    this._isPressingSpaceBar = isPressing;
  }
  get isPressingShift() {
    return this._isPressingShift;
  }
  set isPressingShift(isPressing) {
    this._isPressingShift = isPressing;
  }
  /**
   * 取消指定状态后触发
   * @param stateId
   * @param fn
   */
  onCancel(stateId, fn) {
    return this.onStateChange((e) => {
      if (e.lastState && e.lastState.id === stateId) {
        fn();
      }
    });
  }
  getCurrentState() {
    return this.states.find((s) => s.id === this.selected);
  }
  is(stateId) {
    return this.selected === stateId;
  }
  changeState(stateId, event) {
    const state = this.states.find((s) => s.id === stateId);
    if (!state) throw new Error(`Unknown editor state ${stateId}`);
    if (this.selected !== stateId) {
      const lastState = this.getCurrentState();
      this.selected = stateId;
      this.onStateChangeEmitter.fire({ state, event, lastState });
      this.fireChange();
    }
  }
  toDefaultState() {
    this.changeState(EditorState.STATE_SELECT.id);
  }
  registerState(state) {
    this.states.push(state);
    this.fireChange();
  }
  getStates() {
    return this.states;
  }
  /**
   * 是否为鼠标友好模式
   */
  isMouseFriendlyMode() {
    return this.getCurrentState() === EditorState.STATE_MOUSE_FRIENDLY_SELECT;
  }
  getStateFromShortcut(e) {
    return this.states.find((s) => {
      const shortcut = s.shortcut === "SPACE" ? " " : (s.shortcut || "").toLowerCase();
      if (shortcut === e.key.toLowerCase()) {
        return s;
      }
      return void 0;
    });
  }
};
EditorStateConfigEntity.type = "EditorStateConfigEntity";

// src/core/layer/config/playground-config-entity.ts
import { domUtils as domUtils2, Emitter as Emitter10, PromiseDeferred, Rectangle as Rectangle3 } from "@flowgram.ai/utils";
var SCALE_WIDTH = 0;
var MOUSE_SCROLL_DELTA = 0.05;
var PlaygroundConfigEntity = class extends ConfigEntity {
  constructor(opts) {
    super(opts);
    this._loading = false;
    this._zoomEnable = true;
    this._onReadonlyOrDisabledChangeEmitter = new Emitter10();
    this._onGrabDisableChangeEmitter = new Emitter10();
    this.onGrabDisableChange = this._onGrabDisableChangeEmitter.event;
    this.onReadonlyOrDisabledChange = this._onReadonlyOrDisabledChangeEmitter.event;
    this.cursor = "default";
    this.toDispose.push(this._onReadonlyOrDisabledChangeEmitter);
  }
  /**
   * 是否禁用抓取拖拽画布能力
   */
  get grabDisable() {
    return this.config.grabDisable;
  }
  /**
   * 是否禁用抓取拖拽画布能力
   */
  set grabDisable(grabDisable) {
    this.updateConfig({
      grabDisable
    });
  }
  getDefaultConfig() {
    return {
      scrollX: 0,
      scrollY: 0,
      originX: 0,
      originY: 0,
      width: 0,
      height: 0,
      minZoom: 0.1,
      maxZoom: 2,
      zoom: 1,
      clientX: 0,
      clientY: 0,
      reverseScroll: true,
      overflowX: "scroll",
      overflowY: "scroll",
      disabled: false,
      readonly: false,
      grabDisable: false,
      mouseScrollDelta: MOUSE_SCROLL_DELTA
    };
  }
  /**
   * 添加滚动限制逻辑
   * @param fn
   */
  addScrollLimit(fn) {
    this._scrollLimitFn = fn;
  }
  /**
   * 更新实体配置
   * @param props
   */
  updateConfig(props) {
    if (props.zoom !== void 0) {
      props = { ...props, zoom: this.normalizeZoom(props.zoom) };
    }
    props = { ...this.config, ...props };
    if (!props.reverseScroll) {
      if (props.scrollX < this.config.originX) {
        props.scrollX = this.config.originX;
      }
      if (props.scrollY < this.config.originY) {
        props.scrollY = this.config.originY;
      }
    }
    if (props.scrollLimitX !== void 0 && props.scrollX < props.scrollLimitX) {
      props.scrollX = props.scrollLimitX;
    }
    if (props.scrollLimitY !== void 0 && props.scrollY < props.scrollLimitY) {
      props.scrollY = props.scrollLimitY;
    }
    if (props.overflowX === "hidden") {
      props.scrollX = this.config.originX;
    }
    if (props.overflowY === "hidden") {
      props.scrollY = this.config.originY;
    }
    const { readonly, disabled, grabDisable } = this;
    super.updateConfig(
      this._scrollLimitFn ? { ...props, ...this._scrollLimitFn({ scrollX: props.scrollX, scrollY: props.scrollY }) } : props
    );
    const readonlyOrDisableChanged = readonly !== this.readonly || disabled !== this.disabled;
    if (readonlyOrDisableChanged) this._onReadonlyOrDisabledChangeEmitter.fire({ readonly: this.readonly, disabled: this.disabled });
    if (grabDisable !== this.grabDisable) this._onGrabDisableChangeEmitter.fire(this.grabDisable);
  }
  /**
   * 缩放比例
   * 使用 zoom 替代
   * @deprecated
   */
  get finalScale() {
    if (!this.zoomEnable) return 1;
    return this.config.zoom;
  }
  /**
   * 缩放比例
   */
  get zoom() {
    if (!this.zoomEnable) return 1;
    return this.config.zoom;
  }
  get scrollData() {
    return {
      scrollX: this.config.scrollX,
      scrollY: this.config.scrollY
    };
  }
  normalizeZoom(zoom) {
    if (!this.zoomEnable) return 1;
    if (zoom < this.config.minZoom) {
      zoom = this.config.minZoom;
    } else if (zoom > this.config.maxZoom) {
      zoom = this.config.maxZoom;
    }
    return zoom;
  }
  /**
   * 修改画布光标
   * @param cursor
   */
  updateCursor(cursor) {
    if (this.cursor !== cursor) {
      this.cursor = cursor;
      this.fireChange();
    }
  }
  /**
   * 获取相对画布的位置
   * @param event
   * @param widthScale 是否要计算缩放
   */
  getPosFromMouseEvent(event, withScale = true) {
    const { config } = this;
    const scale = withScale ? this.finalScale : 1;
    return {
      x: (event.clientX + config.scrollX - config.clientX) / scale,
      y: (event.clientY + config.scrollY - config.clientY) / scale
    };
  }
  /**
   * 将画布中的位置转成相对 window 的位置
   * @param pos
   */
  toFixedPos(pos) {
    const { config } = this;
    return {
      x: pos.x - config.scrollX + config.clientX,
      y: pos.y - config.scrollY + config.clientY
    };
  }
  /**
   * 获取可视区域
   */
  getViewport(withScale = true) {
    const { config } = this;
    const scale = withScale ? this.finalScale : 1;
    return new Rectangle3(
      config.scrollX / scale,
      config.scrollY / scale,
      config.width / scale,
      config.height / scale
    );
  }
  /**
   * 判断矩形是否在可视区域，如果有擦边页代表在可是区域
   * @param bounds
   * @param rotation
   * @param includeAll - 是否包含在里边，默认 false
   */
  isViewportVisible(bounds, rotation = 0, includeAll = false) {
    return Rectangle3.isViewportVisible(bounds, this.getViewport(), rotation, includeAll);
  }
  /**
   * 按下边顺序执行
   * 1. 指定的 entity 位置或 pos 位置
   * 3. 初始化位置
   */
  scrollToView(opts = {}) {
    const {
      scrollDelta,
      position: pos,
      // selection = true,
      easing = true,
      easingDuration = 300,
      entities
    } = opts;
    const { config } = this;
    const scale = opts.zoom ? opts.zoom : this.finalScale;
    let bounds;
    if (entities && entities.length > 0) {
      const entitiesBounds = entities.map((e) => {
        const transform = e.getData(TransformData);
        if (transform) return transform.bounds;
        const position = e.getData(PositionData);
        const size = e.getData(SizeData) || { width: 0, height: 0 };
        if (!position) return;
        return new Rectangle3(position.x, position.y, size.width, size.height || 0);
      }).filter((e) => !!e);
      if (entitiesBounds.length > 0) {
        bounds = Rectangle3.enlarge(entitiesBounds);
      }
    } else if (pos) {
      bounds = new Rectangle3(pos.x, pos.y, 0, 0);
    } else if (opts.bounds) {
      bounds = opts.bounds;
    }
    if (!bounds) {
      const defaultConfig = this.getDefaultConfig();
      bounds = new Rectangle3(
        (defaultConfig.scrollX + config.width / 2) / scale,
        (defaultConfig.scrollY + config.height / 2) / scale,
        0,
        0
      );
    }
    if (!opts.scrollToCenter) {
      const boundsVisible = this.getViewport();
      if (boundsVisible.containsRectangle(bounds)) {
        return Promise.resolve();
      }
    }
    const toValues = {
      scrollX: (bounds.x + bounds.width / 2 + (scrollDelta ? scrollDelta.x : 0)) * scale - config.width / 2,
      scrollY: (bounds.y + bounds.height / 2 + (scrollDelta ? scrollDelta.y : 0)) * scale - config.height / 2,
      zoom: opts.zoom
    };
    return this.scroll(toValues, easing, easingDuration);
  }
  /**
   * 这只画布边框，元素编辑的时候回吸附画布边框
   * @param bounds
   */
  setPageBounds(bounds) {
    this.updateConfig({
      pageBounds: {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: bounds.height
      }
    });
  }
  getPageBounds() {
    const { pageBounds } = this.config;
    if (pageBounds) {
      return new Rectangle3(pageBounds.x, pageBounds.y, pageBounds.width, pageBounds.height);
    }
  }
  /**
   * 滚动到画布中央
   * @param zoomToFit 是否缩放并适配外围大小
   * @param fitPadding 适配外围的留白
   * @param easing 是否缓动
   */
  scrollPageBoundsToCenter(zoomToFit = true, fitPadding = 16, easing = true) {
    const pageBounds = this.getPageBounds();
    if (pageBounds) {
      let zoom;
      const fitPaddingDouble = fitPadding * 2;
      if (zoomToFit) {
        const fixedScale = SizeSchema.fixSize(
          {
            width: pageBounds.width,
            height: pageBounds.height
          },
          {
            width: fitPaddingDouble > this.config.width ? fitPaddingDouble : this.config.width - fitPaddingDouble,
            height: fitPaddingDouble > this.config.height ? fitPaddingDouble : this.config.height - fitPaddingDouble
          }
        );
        zoom = fixedScale;
      }
      return this.scrollToView({
        bounds: pageBounds,
        zoom,
        scrollToCenter: true,
        // selection: false,
        easing
      });
    }
    return this.scrollToView({ easing });
  }
  /**
   * 滚动
   * @param scroll
   * @param easing - 是否开启缓动，默认开启
   * @param easingDuration - 滚动持续时间，默认 300ms
   */
  scroll(scroll, easing = true, easingDuration = 300) {
    const deferred = new PromiseDeferred();
    if (this.cancelScrollTeeen) this.cancelScrollTeeen.dispose();
    if (easing) {
      const fromValues = {
        scrollX: this.config.scrollX,
        scrollY: this.config.scrollY,
        zoom: this.config.zoom
      };
      this.cancelScrollTeeen = startTween({
        from: fromValues,
        to: {
          ...fromValues,
          ...scroll
        },
        onUpdate: (v) => {
          this.updateConfig(v);
        },
        onComplete: () => {
          this.cancelScrollTeeen = void 0;
          deferred.resolve();
        },
        onDispose: () => {
          deferred.resolve();
        },
        duration: easingDuration
      });
    } else {
      this.updateConfig(scroll);
      deferred.resolve();
    }
    return deferred.promise;
  }
  /**
   * 让 layer 的 node 节点不随着画布滚动条滚动
   * @param layerNode
   */
  fixLayerPosition(layerNode) {
    domUtils2.setStyle(layerNode, {
      left: this.config.scrollX,
      top: this.config.scrollY
    });
  }
  get loading() {
    return this._loading;
  }
  set loading(loading) {
    if (this.loading !== loading) {
      this._loading = loading;
      this.fireChange();
    }
  }
  get zoomEnable() {
    return this._zoomEnable;
  }
  /**
   * 开启缩放
   * @param zoomEnable
   */
  set zoomEnable(zoomEnable) {
    if (this._zoomEnable !== zoomEnable) {
      this._zoomEnable = zoomEnable;
      this.fireChange();
    }
  }
  /**
   * 放大
   */
  zoomin(easing, easingDuration) {
    const unit = this.config.zoom / 10;
    const newZoom = Math.ceil((this.config.zoom + unit) * 10) / 10;
    this.updateZoom(newZoom, easing, easingDuration);
  }
  /**
   * 缩小
   */
  zoomout(easing, easingDuration) {
    const unit = this.config.zoom / 10;
    const newZoom = Math.floor((this.config.zoom - unit) * 10) / 10;
    this.updateZoom(newZoom, easing, easingDuration);
  }
  updateZoom(newZoom, easing = true, easingDuration = 200) {
    newZoom = this.normalizeZoom(newZoom);
    const { center } = this.getViewport();
    const oldScale = this.finalScale;
    const newScale = !this.zoomEnable ? oldScale : newZoom;
    if (newScale !== oldScale) {
      const delta = {
        x: center.x * newScale - center.x * oldScale,
        y: center.y * newScale - center.y * oldScale
      };
      this.scroll(
        {
          scrollX: this.config.scrollX + delta.x,
          scrollY: this.config.scrollY + delta.y,
          zoom: newZoom
        },
        easing,
        easingDuration
      );
    }
  }
  get disabled() {
    return this.config.disabled;
  }
  get readonly() {
    return this.config.readonly;
  }
  get readonlyOrDisabled() {
    return this.config.readonly || this.config.disabled;
  }
  set readonly(readonly) {
    this.updateConfig({
      readonly
    });
  }
  set disabled(disabled) {
    this.updateConfig({
      disabled
    });
  }
  /**
   * 适应大小
   * @param bounds 目标大小
   * @param easing 是否开启动画，默认开启
   * @param padding 边界空白
   */
  fitView(bounds, easing = true, padding = 0) {
    const viewport = this.getViewport(false);
    const zoom = SizeSchema.fixSize(bounds.pad(padding, padding), viewport);
    return this.scrollToView({
      bounds,
      zoom,
      easing,
      scrollToCenter: true
    });
  }
};
PlaygroundConfigEntity.type = "PlaygroundConfigEntity";

// src/core/layer/layer.ts
import { inject as inject6, injectable as injectable9 } from "inversify";
import {
  DisposableCollection as DisposableCollection5,
  domUtils as domUtils3
} from "@flowgram.ai/utils";
var LayerOptions = Symbol("LayerOptions");
var Layer = class {
  constructor() {
    this.toDispose = new DisposableCollection5();
    /**
     * 默认在渲染时候都会启用 react memo 进行隔离，这种情况就需要数据驱动更新
     */
    this.renderWithReactMemo = true;
  }
  /**
   * 销毁
   */
  dispose() {
    this.toDispose.dispose();
  }
  /**
   * 创建 dom 缓冲池
   * @param className
   */
  createDOMCache(className, children) {
    if (!this.node) throw new Error("DomCache need a parent dom node.");
    return domUtils3.createDOMCache(this.node, className, children);
  }
  /**
   * 获取鼠标在 Playground 的位置
   */
  getPosFromMouseEvent(event, addScale = true) {
    const pos = this.config.getPosFromMouseEvent(event, addScale);
    return {
      x: pos.x,
      y: pos.y
    };
  }
};
__decorateClass([
  inject6(LayerOptions)
], Layer.prototype, "options", 2);
__decorateClass([
  inject6(EntityManager)
], Layer.prototype, "entityManager", 2);
__decorateClass([
  injectPlaygroundContext()
], Layer.prototype, "context", 2);
Layer = __decorateClass([
  injectable9()
], Layer);

// src/core/layer/playground-layer.ts
import { inject as inject7, injectable as injectable10, optional as optional3 } from "inversify";
import { Disposable as Disposable9, domUtils as domUtils4 } from "@flowgram.ai/utils";
var PlaygroundLayer = class extends Layer {
  constructor() {
    super(...arguments);
    this.startGrabScroll = {
      scrollX: 0,
      scrollY: 0
    };
    this.cursorStyle = document.createElement("style");
    this.maskNode = document.createElement("div");
    this.grabDragger = new PlaygroundDrag({
      onDragStart: (e) => {
        if (this.config.grabDisable) return;
        this.config.updateCursor("grabbing");
        this.startGrabScroll = {
          scrollX: this.config.config.scrollX,
          scrollY: this.config.config.scrollY
        };
      },
      onDrag: (e) => {
        if (this.config.grabDisable) return;
        this.config.updateConfig({
          scrollX: this.startGrabScroll.scrollX - e.endPos.x + e.startPos.x,
          scrollY: this.startGrabScroll.scrollY - e.endPos.y + e.startPos.y
        });
      },
      onDragEnd: (e) => {
        if (this.isGrab()) {
          this.config.updateCursor("grab");
        }
        const isMouseCenterButton = e.button === 1;
        if (isMouseCenterButton) {
          if (this.isMouseMode()) {
            this.editorStateConfig.changeState(EditorState.STATE_MOUSE_FRIENDLY_SELECT.id);
            this.config.updateCursor("grab");
          } else {
            this.editorStateConfig.toDefaultState();
            this.config.updateCursor("");
          }
        }
      }
    });
  }
  onReady() {
    this.options = {
      preventGlobalGesture: false,
      ...this.options
    };
    if (this.options.preventGlobalGesture) {
      const gesturePreventGlobal = new Gesture(document.body, {
        /* v8 ignore next 3 */
        onPinch: () => {
        }
      });
      if (document.documentElement) {
        document.documentElement.style.overscrollBehaviorX = "none";
      }
      document.body.style.overscrollBehaviorX = "none";
      this.toDispose.push(Disposable9.create(() => gesturePreventGlobal.destroy()));
    }
    this.toDispose.pushAll([
      this.config.onGrabDisableChange((disable) => {
        if (disable) {
          this.grabDragger.stop(0, 0);
        }
      }),
      /**
       * 防止滚动事件被透出到业务层滚动
       */
      domUtils4.addStandardDisposableListener(this.playgroundNode, "wheel", (event) => {
        if (this.getScrollParent(event.target)) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
      }),
      /**
       * 在父节点上监听滚动事件
       */
      this.listenPlaygroundEvent(
        "wheel",
        this.handleWheelEvent.bind(this),
        -2 /* BASE_LAYER */,
        { passive: true }
      ),
      this.listenPlaygroundEvent(
        "mousedown",
        (e) => {
          const isMouseCenterButton = e.button === 1;
          if (isMouseCenterButton && !this.isMouseMode()) {
            this.editorStateConfig.changeState(EditorState.STATE_GRAB.id);
          }
          if (this.isGrab() && (this.editorStateConfig.isPressingSpaceBar || isMouseCenterButton)) {
            this.grabDragger.start(e.clientX, e.clientY);
          }
        },
        -2 /* BASE_LAYER */
      ),
      this.listenPlaygroundEvent(
        "mousedown",
        (e) => {
          const isSomeHovered = this.options?.hoverService?.isSomeHovered();
          if (this.isMouseMode() && !isSomeHovered && !this.editorStateConfig.isPressingShift) {
            this.grabDragger.start(e.clientX, e.clientY);
          }
        },
        // 这里必须监听 NORMAL_LAYER，该图层最先触发
        0 /* NORMAL_LAYER */
      ),
      this.editorStateConfig.onStateChange(this.onStateChanged.bind(this)),
      // 单独监听 shift 按键
      // 只有 keydown 能监听到 shift 按键，keypress 无法监听到
      this.listenGlobalEvent(
        "keydown",
        (e) => {
          if (e.shiftKey) {
            this.editorStateConfig.isPressingShift = true;
            if (this.isMouseMode()) {
              this.config.updateCursor("");
            }
          }
        },
        -2 /* BASE_LAYER */
      ),
      // 监听快捷键
      this.listenGlobalEvent(
        "keypress",
        (e) => {
          if (!this.isFocused || e.target !== this.playgroundNode) return;
          if (this.isMouseMode()) {
            return;
          }
          const state = this.editorStateConfig.getStateFromShortcut(e);
          if (e.key === " ") {
            this.editorStateConfig.isPressingSpaceBar = true;
          }
          if (state?.shortcutWorksOnlyOnStateChanged === true && state === this.editorStateConfig.getCurrentState()) {
            return;
          }
          this.lastShortcutState = state;
          if (state) {
            this.editorStateConfig.changeState(state.id);
          }
        },
        -2 /* BASE_LAYER */
      ),
      this.listenGlobalEvent("keyup", (e) => {
        if (e.key === " ") {
          this.editorStateConfig.isPressingSpaceBar = false;
        }
        this.editorStateConfig.isPressingShift = false;
        if (this.lastShortcutState && this.lastShortcutState.shortcutAutoEsc) {
          this.editorStateConfig.toDefaultState();
        }
        this.lastShortcutState = void 0;
      }),
      {
        // 在进入 grab 模式后，此时后退页面，需清理样式
        dispose: () => {
          if (this.maskNode.parentNode) {
            this.maskNode.parentNode.removeChild(this.maskNode);
          }
          if (this.cursorStyle.parentNode) {
            this.cursorStyle.parentNode.removeChild(this.cursorStyle);
          }
        }
      }
    ]);
    if (this.options.ineractiveType === "MOUSE") {
      this.editorStateConfig.changeState(EditorState.STATE_MOUSE_FRIENDLY_SELECT.id);
    }
  }
  getCursor(cursor) {
    if (!cursor) {
      return "";
    }
    return this.playgroundConfigEntity.getCursors?.()?.[cursor] ?? cursor;
  }
  /** 是否为鼠标优先模式 */
  isMouseMode() {
    return this.editorStateConfig.isMouseFriendlyMode();
  }
  onStateChanged(e) {
    const { state } = e;
    if (this.cancelStateListen) {
      this.cancelStateListen.dispose();
      this.cancelStateListen = void 0;
    }
    if (state.handle) {
      state.handle(this.config, e);
    }
    if (state.cursor) {
      this.playgroundConfigEntity.updateCursor(state.cursor);
      if (this.currentGesture && this.currentGesture.target.parentNode) {
        this.currentGesture.target.parentNode.style.cursor = this.getCursor(
          state.cursor
        );
      }
    } else {
      this.playgroundConfigEntity.updateCursor("");
      if (this.currentGesture && this.currentGesture.target.parentNode) {
        this.currentGesture.target.parentNode.style.cursor = "";
      }
    }
    if (state.cursor === "grab" || state.cursor === "grabbing") {
      if (state === EditorState.STATE_MOUSE_FRIENDLY_SELECT) {
        return;
      }
      this.maskNode.style.cssText = `
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 100;
      `;
      this.playgroundNode.appendChild(this.maskNode);
    } else {
      if (this.maskNode.parentNode) {
        this.maskNode.parentNode.removeChild(this.maskNode);
      }
    }
    if (state.cancelMode === "esc") {
      this.cancelStateListen = domUtils4.addStandardDisposableListener(
        document.body,
        "keydown",
        (keyboard) => {
          if (keyboard.key === "Escape" || keyboard.key === "Enter") {
            this.editorStateConfig.toDefaultState();
          }
        },
        true
      );
    } else if (state.cancelMode === "once") {
      this.editorStateConfig.toDefaultState();
    }
  }
  isGrab() {
    const currentState = this.editorStateConfig.getCurrentState();
    return currentState === EditorState.STATE_GRAB || currentState === EditorState.STATE_MOUSE_FRIENDLY_SELECT;
  }
  createGesture() {
    if (!this.currentGesture) {
      this.currentGesture = new PlaygroundGesture(this.pipelineNode.parentElement, this.config);
      this.currentGesture.onDispose(() => {
        this.currentGesture = void 0;
      });
      this.toDispose.push(this.currentGesture);
    }
  }
  /**
   * 监听 resize
   * @param size
   */
  onResize(size) {
    this.size = { ...size };
    this.updateSizeWithRulerConfig();
  }
  updateSizeWithRulerConfig() {
    const { size } = this;
    if (!size) return;
    this.config.updateConfig({
      width: size.width,
      height: size.height,
      clientX: size.clientX,
      clientY: size.clientY
    });
  }
  handleScrollEvent(event) {
    const { playgroundConfigEntity } = this;
    const scrollX = playgroundConfigEntity.config.scrollX + event.deltaX;
    const scrollY = playgroundConfigEntity.config.scrollY + event.deltaY;
    const state = {
      scrollX,
      scrollY
    };
    playgroundConfigEntity.updateConfig(state);
  }
  getMouseScaleDelta() {
    const { mouseScrollDelta, zoom } = this.config.config;
    if (typeof mouseScrollDelta === "function") {
      return mouseScrollDelta(zoom);
    }
    return mouseScrollDelta ?? MOUSE_SCROLL_DELTA;
  }
  /**
   * 监听滚动事件
   * @param event
   */
  handleWheelEvent(event) {
    const e = event;
    if (this.currentGesture && this.currentGesture.pinching || event.ctrlKey || event.metaKey)
      return;
    if (this.getScrollParent(event.target)) {
      return;
    }
    if (this.isMouseMode()) {
      const { zoom, minZoom, maxZoom, scrollX, scrollY } = this.playgroundConfigEntity.config;
      const scaleStep = this.getMouseScaleDelta();
      const scaleMin = minZoom;
      const scaleMax = maxZoom;
      const getDelta = (wheelDelta2) => wheelDelta2 > 0 ? -scaleStep : scaleStep;
      const wheelDelta = Math.abs(e.deltaY) > 0 ? e.deltaY : e.deltaX;
      const delta = getDelta(wheelDelta);
      const oldScale = this.config.finalScale;
      const originX = event.clientX;
      const originY = event.clientY;
      const newScale = Math.max(scaleMin, Math.min(scaleMax, zoom + delta));
      const origin = this.config.getPosFromMouseEvent(
        { clientX: originX, clientY: originY },
        false
      );
      const finalPos = {
        x: origin.x / oldScale * newScale,
        y: origin.y / oldScale * newScale
      };
      this.config.updateConfig({
        scrollX: scrollX + finalPos.x - origin.x,
        scrollY: scrollY + finalPos.y - origin.y,
        zoom: newScale
      });
      return;
    }
    this.handleScrollEvent(e);
  }
  /**
   * 获取 wheel 事件滚动的父元素
   * @param dom
   */
  getScrollParent(ele) {
    if (!ele || ele === this.pipelineNode.parentElement) {
      return null;
    }
    const hasScrollableXContent = ele.scrollWidth > ele.clientWidth;
    const hasScrollableYContent = ele.scrollHeight > ele.clientHeight;
    const overflowXStyle = window.getComputedStyle(ele).overflowX;
    const overflowYStyle = window.getComputedStyle(ele).overflowY;
    const isOverflowXScrollable = ["auto", "scroll", "overlay"].includes(overflowXStyle);
    const isOverflowYScrollable = ["auto", "scroll", "overlay"].includes(overflowYStyle);
    const hasScrollableContent = hasScrollableXContent && isOverflowXScrollable || hasScrollableYContent && isOverflowYScrollable;
    if (hasScrollableContent || this.protectWheelArea?.(ele)) {
      return ele;
    }
    return this.getScrollParent(ele.parentElement);
  }
  autorun() {
    const playgroundConfig = this.playgroundConfigEntity.config;
    const { cursor } = this.playgroundConfigEntity;
    const finalCursor = this.getCursor(cursor);
    if (this.config.zoomEnable) {
      this.createGesture();
    } else if (this.currentGesture) {
      this.currentGesture.dispose();
    }
    domUtils4.setStyle(this.pipelineNode, {
      left: -playgroundConfig.scrollX,
      top: -playgroundConfig.scrollY,
      width: playgroundConfig.width,
      height: playgroundConfig.height
    });
    this.pipelineNode.parentElement.style.cursor = finalCursor;
    if (cursor === "grab" || cursor === "grabbing") {
      let classSelector = "";
      this.playgroundNode.classList.forEach((className) => {
        classSelector += `.${className}`;
      });
      this.cursorStyle.innerText = `.${classSelector} * { cursor: ${finalCursor} }`;
      if (!this.cursorStyle.parentNode) {
        document.head.appendChild(this.cursorStyle);
      }
    } else {
      if (this.cursorStyle.parentNode) {
        this.cursorStyle.parentNode.removeChild(this.cursorStyle);
      }
    }
  }
};
__decorateClass([
  observeEntity(PlaygroundConfigEntity)
], PlaygroundLayer.prototype, "playgroundConfigEntity", 2);
__decorateClass([
  observeEntity(EditorStateConfigEntity)
], PlaygroundLayer.prototype, "editorStateConfig", 2);
__decorateClass([
  optional3(),
  inject7(ProtectWheelArea)
], PlaygroundLayer.prototype, "protectWheelArea", 2);
PlaygroundLayer = __decorateClass([
  injectable10()
], PlaygroundLayer);

// src/core/pipeline/pipeline-entities.ts
var PipelineEntitiesImpl = class {
  constructor(entityManager) {
    this.entityManager = entityManager;
    this.observeEntities = [];
    this.observeDatas = [];
    // @Action 这里要加多个缓存的原因是，每次 decorator 触发都会频繁调用获取方法，"this.xxx" 也会触发 decorator 方法
    this.entitiesTypeCache = /* @__PURE__ */ new Map();
    this.entitiesAbleCache = /* @__PURE__ */ new Map();
    this.entitiyDataCache = /* @__PURE__ */ new Map();
  }
  get size() {
    return this.observeEntities.length;
  }
  /**
   * 加载订阅数据，会缓存到 layer 内部，layer 只能拿到订阅数据的子集
   * @param observeEntites
   * @param observeDatas
   */
  load(observeEntites, observeDatas) {
    this.observeEntities = observeEntites;
    this.observeDatas = observeDatas;
    this.entitiesTypeCache.clear();
    this.entitiesAbleCache.clear();
    this.entitiyDataCache.clear();
  }
  get(registry, id2) {
    const entities = this.getEntities(registry);
    if (id2 !== void 0) {
      return entities.find((e) => e.id === id2);
    }
    return entities[0];
  }
  has(registy) {
    return !!this.get(registy);
  }
  getEntities(registry) {
    let result = this.entitiesTypeCache.get(registry);
    if (!result) {
      result = [];
      this.observeEntities.forEach((e) => {
        if (e.type === registry.type) result.push(e);
      });
      this.entitiesTypeCache.set(registry, result);
    }
    return result.filter((r) => !r.disposed);
  }
  getEntityDatas(entityRegistry, dataRegistry) {
    const dataKey = `${entityRegistry.type}:${dataRegistry.type}`;
    let result = this.entitiyDataCache.get(dataKey);
    if (result) {
      return result;
    }
    result = this.observeDatas.filter(
      (data) => data.type === dataRegistry.type && data.entity.type === entityRegistry.type
    );
    this.entitiyDataCache.set(dataKey, result);
    return result;
  }
  // getEntitiesByAble<T extends Entity = Entity>(able: AbleRegistry): T[] {
  //   return this.getEntitiesByAbles([able]);
  // }
  // getEntitiesByAbles<T extends Entity = Entity>(
  //   andAbles: AbleRegistry[] = [],
  //   orAbles: AbleRegistry[] = [],
  // ): T[] {
  //   const ableKey = `${andAbles.map(a => a.type).join(':')}_${orAbles.map(a => a.type).join(':')}`;
  //   let result = this.entitiesAbleCache.get(ableKey) as T[];
  //   // 缓存查询结果
  //   if (!result) {
  //     result = [];
  //     this.observeEntities.forEach(entity => {
  //       const checkAnd = andAbles.length === 0 || !andAbles.find(able => !entity.ables.has(able));
  //       const checkOr = orAbles.length === 0 || orAbles.find(able => entity.ables.has(able));
  //       if (checkAnd && checkOr) {
  //         result.push(entity as T);
  //       }
  //     });
  //     this.entitiesAbleCache.set(ableKey, result);
  //   }
  //   // 可能会出现延迟更新
  //   return result.filter(r => !r.disposed);
  // }
  updateConfig(registry, props) {
    const entity = this.get(registry);
    if (entity && entity.updateConfig) {
      entity.updateConfig(props);
    }
  }
  getConfig(registry) {
    const entity = this.get(registry);
    if (entity) {
      return entity.config;
    }
  }
  /**
   * 创建实体
   */
  createEntity(registry, opts) {
    return this.entityManager.createEntity(registry, opts);
  }
  /**
   * 批量删除实体
   */
  removeEntities(registry) {
    this.entityManager.removeEntities(registry);
  }
  [Symbol.iterator]() {
    let index = 0;
    const len = this.observeEntities.length;
    return {
      next: () => {
        const current = index++;
        const done = current === len;
        return {
          value: this.observeEntities[current],
          done
        };
      }
    };
  }
};

// src/core/pipeline/pipeline-registry.ts
var PipelineMessage = /* @__PURE__ */ ((PipelineMessage2) => {
  PipelineMessage2["ZOOM"] = "PIPELINE_ZOOM";
  PipelineMessage2["SCROLL"] = "PIPELINE_SCROLL";
  return PipelineMessage2;
})(PipelineMessage || {});
var zoomMessage = new ConflatableMessage2("PIPELINE_ZOOM" /* ZOOM */);
var scrollMessage = new ConflatableMessage2("PIPELINE_SCROLL" /* SCROLL */);
var PipelineRegistry = class {
  constructor() {
    this._isFocused = false;
    this.toDispose = new DisposableCollection6();
    this.allLayersMap = /* @__PURE__ */ new Map();
    this.onResizeEmitter = new Emitter11();
    this.onFocusEmitter = new Emitter11();
    this.onBlurEmitter = new Emitter11();
    this.onZoomEmitter = new Emitter11();
    this.onScrollEmitter = new Emitter11();
    this.onFocus = this.onFocusEmitter.event;
    this.onBlur = this.onBlurEmitter.event;
    this.onZoom = this.onZoomEmitter.event;
    this.onScroll = this.onScrollEmitter.event;
    // @inject(SelectionService) @optional() selectionService?: SelectionService;
    this.playgroundEvents = {};
    this.globalEvents = {};
    /**
     * pipline 大小变化时候会触发
     */
    this.onResize = this.onResizeEmitter.event;
    this.toDispose.pushAll([
      this.onResizeEmitter,
      this.onFocusEmitter,
      this.onZoomEmitter,
      this.onBlurEmitter,
      this.onScrollEmitter
    ]);
    this.onFocusEmitter.event(() => {
      this._isFocused = true;
    });
    this.onBlurEmitter.event(() => {
      this._isFocused = false;
    });
  }
  _listenEvent(name, handle, isGlobal, priority = 0, options) {
    const eventsCache = isGlobal ? this.globalEvents : this.playgroundEvents;
    const domNode = isGlobal ? document : this.renderer.node.parentNode;
    let eventRegister = eventsCache[name];
    if (!eventRegister) {
      const realHandler = {
        handleEvent: (e) => {
          const list = eventRegister.handlers;
          for (let i = 0, len = list.length; i < len; i++) {
            const prevent = list[i].handle(e);
            if (prevent) return;
          }
        }
      };
      domNode.addEventListener(name, realHandler, options);
      eventRegister = eventsCache[name] = {
        handlers: [],
        dispose: () => {
          domNode.removeEventListener(name, realHandler);
          delete eventsCache[name];
        }
      };
    }
    const { handlers } = eventRegister;
    const item = { handle, priority };
    handlers.unshift(item);
    handlers.sort((a, b) => b.priority - a.priority);
    const dispose = Disposable10.create(() => {
      const index = eventRegister.handlers.indexOf(item);
      if (index !== -1) eventRegister.handlers.splice(index, 1);
      if (eventRegister.handlers.length === 0) {
        eventRegister.dispose();
      }
    });
    this.toDispose.push(dispose);
    return dispose;
  }
  /**
   * 监听画布上的浏览器事件
   */
  listenPlaygroundEvent(name, handle, priority, options) {
    return this._listenEvent(name, handle, false, priority, options);
  }
  /**
   * 监听全局的事件
   * @param name
   * @param handle
   */
  listenGlobalEvent(name, handle, priority, options) {
    return this._listenEvent(name, handle, true, priority, options);
  }
  /**
   * 注册 layer
   * @param layerRegistry
   * @param layerOptions 配置
   */
  registerLayer(layerRegistry, layerOptions) {
    if (this.allLayersMap.has(layerRegistry)) return;
    const layer = this.layerFactory(layerRegistry, layerOptions);
    this.allLayersMap.set(layerRegistry, layer);
    const entityRegistries = getEntityMetadata(layerRegistry);
    const entityDataRegistries = getEntityDatasMetadata(layerRegistry);
    entityRegistries.forEach((r) => {
      this.entityManager.registerEntity(r);
      if (Entity.isRegistryOf(r, ConfigEntity)) {
        this.entityManager.createEntity(r);
      }
    });
    entityDataRegistries.forEach((r) => {
      this.entityManager.registerEntity(r.entity);
      this.entityManager.registerEntityData(r.data);
    });
    this.selector.subscribeEntities(layer, entityRegistries);
    entityDataRegistries.forEach(
      (r) => this.selector.subscribleEntityByData(layer, r.entity, r.data)
    );
    layer.observeManager = new PipelineEntitiesImpl(this.entityManager);
    layer.reloadEntities = () => {
      const result = this.selector.getLayerData(layer);
      if (result.changed) {
        layer.observeManager.load(
          result.observeEntities,
          result.observeDatas
        );
      }
      return result.changed;
    };
    layer.listenPlaygroundEvent = this.listenPlaygroundEvent.bind(this);
    layer.listenGlobalEvent = this.listenGlobalEvent.bind(this);
    layer.config = this.configEntity;
    layer.getOtherLayer = this.getLayer.bind(this);
    Object.defineProperty(layer, "isFocused", {
      get: () => this._isFocused
    });
    if (layer.onResize) {
      this.onResize(layer.onResize.bind(layer));
    }
    if (layer.onBlur) {
      this.onBlurEmitter.event(layer.onBlur.bind(layer));
    }
    if (layer.onFocus) {
      this.onFocusEmitter.event(layer.onFocus.bind(layer));
    }
    if (layer.onZoom) {
      this.onZoomEmitter.event(layer.onZoom.bind(layer));
    }
    if (layer.onScroll) {
      this.onScrollEmitter.event(layer.onScroll.bind(layer));
    }
    if (layer.onViewportChange) {
      const viewportChange = layer.onViewportChange.bind(layer);
      this.onResize(viewportChange);
      this.onZoomEmitter.event(viewportChange);
      this.onScrollEmitter.event(viewportChange);
    }
    if (layer.onReadonlyOrDisabledChange) {
      this.configEntity.onReadonlyOrDisabledChange(layer.onReadonlyOrDisabledChange.bind(layer));
    }
    this.renderer.addLayer(layer);
  }
  /**
   * 获取 layer
   */
  getLayer(layerRegistry) {
    return this.allLayersMap.get(layerRegistry);
  }
  get configEntity() {
    return this.entityManager.getEntity(PlaygroundConfigEntity, true);
  }
  ready() {
    const config = this.configEntity;
    let lastScale = config.finalScale;
    let lastScroll = config.scrollData;
    config.onConfigChanged(() => {
      const newScale = config.finalScale;
      const newScroll = config.scrollData;
      if (newScale !== lastScale) {
        lastScale = newScale;
        if (process.env.NODE_ENV === "test") {
          this.processMessage(zoomMessage);
        } else {
          MessageLoop2.postMessage(this, zoomMessage);
        }
      }
      if (lastScroll.scrollX !== newScroll.scrollX || lastScroll.scrollY !== newScroll.scrollY) {
        lastScroll = newScroll;
        if (process.env.NODE_ENV === "test") {
          this.processMessage(scrollMessage);
        } else {
          MessageLoop2.postMessage(this, scrollMessage);
        }
      }
    });
  }
  processMessage(msg) {
    const config = this.configEntity;
    switch (msg.type) {
      case "PIPELINE_SCROLL" /* SCROLL */:
        this.onScrollEmitter.fire(config.scrollData);
        break;
      case "PIPELINE_ZOOM" /* ZOOM */:
        this.onZoomEmitter.fire(config.finalScale);
        break;
      default:
    }
  }
  dispose() {
    this.toDispose.dispose();
  }
};
__decorateClass([
  inject8(PipelineRenderer)
], PipelineRegistry.prototype, "renderer", 2);
__decorateClass([
  inject8(PipelineEntitiesSelector)
], PipelineRegistry.prototype, "selector", 2);
__decorateClass([
  inject8(EntityManager)
], PipelineRegistry.prototype, "entityManager", 2);
__decorateClass([
  injectPlaygroundContext()
], PipelineRegistry.prototype, "context", 2);
__decorateClass([
  inject8(PipelineLayerFactory)
], PipelineRegistry.prototype, "layerFactory", 2);
PipelineRegistry = __decorateClass([
  injectable11()
], PipelineRegistry);

// src/react/playground-react-context.ts
import React3 from "react";
var PlaygroundReactContext = React3.createContext({});
var PlaygroundReactContainerContext = React3.createContext({});
var PlaygroundReactRefContext = React3.createContext({});
var PlaygroundEntityContext = React3.createContext(void 0);

// src/react/playground-react-provider.tsx
import React4, { useMemo, useImperativeHandle, forwardRef } from "react";

// src/plugin/plugin.ts
import { ContainerModule } from "inversify";

// src/playground-contribution.ts
import { inject as inject9, injectable as injectable12 } from "inversify";

// src/playground-config.ts
var PlaygroundConfig = Symbol("PlaygroundConfig");
function createDefaultPlaygroundConfig() {
  return {
    autoFocus: true,
    autoResize: true,
    zoomEnable: true,
    layers: [
      // PlaygroundLayer, // 基础配置
      // SelectorLayer, // 节点选择器
      // SelectorBoxLayer, // 选择框
      // SnaplineLayer, // 参考线
      // AlignLayer, // 对齐线
    ]
    // ables: [Dragable, Selectable, Resizable],
    // entities: [
    //   SelectableEntity,
    //   SnaplineConfigEntity,
    //   PlaygroundConfigEntity,
    //   SelectorBoxConfigEntity,
    //   EditorStateConfigEntity,
    // ],
  };
}

// src/playground-contribution.ts
var PlaygroundContribution = Symbol("PlaygroundContribution");
var PlaygroundRegistry = class {
  config(config) {
    Object.assign(this.playgroundConfig, config);
  }
  registerLayer(layerRegistry) {
    this.pipeline.registerLayer(layerRegistry);
  }
  registerEntity(entityRegistry) {
    this.entityManager.registerEntity(entityRegistry);
  }
  // registerAble(ableRegistry: AbleRegistry): void {
  //   this.ableManager.registerAble(ableRegistry);
  // }
  registerEditorState(state) {
    const stateConfig = this.entityManager.getEntity(EditorStateConfigEntity);
    stateConfig?.registerState(state);
  }
};
__decorateClass([
  inject9(PipelineRegistry)
], PlaygroundRegistry.prototype, "pipeline", 2);
__decorateClass([
  inject9(EntityManager)
], PlaygroundRegistry.prototype, "entityManager", 2);
__decorateClass([
  inject9(PlaygroundConfig)
], PlaygroundRegistry.prototype, "playgroundConfig", 2);
PlaygroundRegistry = __decorateClass([
  injectable12()
], PlaygroundRegistry);

// src/plugin/plugin.ts
var PluginContext = Symbol("PluginContext");
var Plugin = Symbol("Plugin");
function loadPlugins(plugins, container) {
  const pluginInitSet = /* @__PURE__ */ new Set();
  const singletonPluginIds = /* @__PURE__ */ new Set();
  const modules = plugins.reduceRight((result, plugin) => {
    const shouldSkip = plugin.singleton && singletonPluginIds.has(plugin.pluginId);
    if (plugin.singleton) {
      singletonPluginIds.add(plugin.pluginId);
    }
    return shouldSkip ? result : [plugin, ...result];
  }, []).reduce((res, plugin) => {
    if (!pluginInitSet.has(plugin.pluginId)) {
      plugin.initPlugin();
      pluginInitSet.add(plugin.pluginId);
    }
    if (plugin.containerModules && plugin.containerModules.length > 0) {
      for (let module of plugin.containerModules) {
        if (!res.includes(module)) {
          res.push(module);
        }
      }
      return res;
    }
    return res;
  }, []);
  modules.forEach((module) => container.load(module));
  plugins.forEach((plugin) => {
    if (plugin.contributionKeys) {
      for (const contribution of plugin.contributionKeys) {
        container.bind(contribution).toConstantValue(plugin.options);
      }
    }
  });
}
function toPlaygroundContainerModule(config, opts) {
  return new ContainerModule((bind) => {
    bind(PlaygroundContribution).toDynamicValue((ctx) => {
      const pluginContext = ctx.container.get(PluginContext);
      return {
        onInit: () => {
          config.onInit?.(pluginContext, opts);
        },
        onReady: () => {
          config.onReady?.(pluginContext, opts);
        },
        onDispose: () => {
          config.onDispose?.(pluginContext, opts);
        },
        onAllLayersRendered: () => {
          config.onAllLayersRendered?.(pluginContext, opts);
        }
      };
    });
  });
}
var pluginIndex = 0;
function definePluginCreator(config) {
  const { contributionKeys, singleton = false } = config;
  pluginIndex += 1;
  const pluginId = `Playground_${pluginIndex}`;
  return (opts) => {
    const containerModules = [];
    let isInit = false;
    return {
      pluginId,
      singleton,
      initPlugin: () => {
        if (isInit) {
          return;
        }
        isInit = true;
        if (config.containerModules) {
          containerModules.push(...config.containerModules);
        }
        if (config.onBind) {
          containerModules.push(
            new ContainerModule((bind, unbind, isBound, rebind) => {
              config.onBind(
                {
                  bind,
                  unbind,
                  isBound,
                  rebind
                },
                opts
              );
            })
          );
        }
        if (config.onInit || config.onDispose || config.onReady || config.onAllLayersRendered) {
          containerModules.push(toPlaygroundContainerModule(config, opts));
        }
      },
      options: opts,
      contributionKeys,
      containerModules
    };
  };
}
var createPlaygroundPlugin = (options) => definePluginCreator(options)(void 0);

// src/playground-container.ts
import { Container, ContainerModule as ContainerModule2 } from "inversify";
import { CommandService as CommandService2, CommandContainerModule } from "@flowgram.ai/command";

// src/playground.ts
import { nanoid as nanoid2 } from "nanoid";
import { debounce } from "lodash";
import { inject as inject10, injectable as injectable13, optional as optional4, named } from "inversify";
import {
  Disposable as Disposable11,
  DisposableCollection as DisposableCollection7,
  domUtils as domUtils5,
  Emitter as Emitter12
} from "@flowgram.ai/utils";
import { CommandService } from "@flowgram.ai/command";
var playgroundInstances = /* @__PURE__ */ new Set();
var playgroundInstanceCreateEmitter = new Emitter12();
var playgroundInstanceDisposeEmitter = new Emitter12();
var Playground = class {
  constructor(entityManager, registry, contextProvider, pipelineRenderer, pipelineRegistry, playgroundConfig, contributionProvider, commandService, selectionService) {
    this.entityManager = entityManager;
    this.registry = registry;
    this.contextProvider = contextProvider;
    this.pipelineRenderer = pipelineRenderer;
    this.pipelineRegistry = pipelineRegistry;
    this.playgroundConfig = playgroundConfig;
    this.contributionProvider = contributionProvider;
    this.commandService = commandService;
    this.selectionService = selectionService;
    this.toDispose = new DisposableCollection7();
    this._focused = false;
    // 唯一 className，适配画布多实例场景
    this.playgroundClassName = nanoid2();
    /**
     * 执行命令
     * @param commandId
     * @param args
     */
    // execCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined> {
    //   return this.commands.executeCommand<T>(commandId, ...args);
    // }
    this.isReady = false;
    this.toDispose.pushAll([
      this.pipelineRenderer,
      this.pipelineRegistry,
      this.entityManager,
      // this.ableManager,
      this.commandService,
      this.selectionService,
      Disposable11.create(() => {
        playgroundInstances.delete(this);
        this.node.remove();
        playgroundInstanceDisposeEmitter.fire(this);
      }),
      pipelineRenderer.onAllLayersRendered(() => {
        this.contributions.forEach((contrib) => contrib.onAllLayersRendered?.(this));
      })
    ]);
    const editStates = this.entityManager.createEntity(EditorStateConfigEntity);
    this.entityManager.createEntity(PlaygroundConfigEntity);
    this.node = playgroundConfig.node || document.createElement("div");
    this.toDispose.pushAll([
      // 浏览器原生的 scrollIntoView 会导致页面的滚动
      // 需要禁用这种操作，否则会引发画布 viewport 计算问题
      domUtils5.addStandardDisposableListener(this.node, "scroll", (event) => {
        this.node.scrollTop = 0;
        this.node.scrollLeft = 0;
        event.preventDefault();
        event.stopPropagation();
      })
    ]);
    this.node.classList.add("gedit-playground");
    if (process.env.NODE_ENV !== "test") {
      this.node.classList.add(this.playgroundClassName);
    }
    this.node.dataset.testid = "sdk.workflow.canvas";
    if (playgroundConfig.layers)
      playgroundConfig.layers.forEach((layer) => this.registry.registerLayer(layer));
    if (playgroundConfig.editorStates)
      playgroundConfig.editorStates.forEach((state) => editStates.registerState(state));
    if (playgroundConfig.zoomEnable !== void 0) this.zoomEnable = playgroundConfig.zoomEnable;
    if (playgroundConfig.entityConfigs) {
      for (const [k, v] of playgroundConfig.entityConfigs) {
        const entity = this.entityManager.getEntity(k, true);
        entity?.updateConfig(v);
      }
    }
    this.node.addEventListener("blur", () => {
      this.blur();
    });
    this.node.addEventListener("focus", () => {
      this.focus();
    });
    this.node.tabIndex = 0;
    this.node.appendChild(this.pipelineRenderer.node);
    this.onBlur = this.pipelineRegistry.onBlurEmitter.event;
    this.onFocus = this.pipelineRegistry.onFocusEmitter.event;
    this.onZoom = this.pipelineRegistry.onZoomEmitter.event;
    this.onScroll = this.pipelineRegistry.onScrollEmitter.event;
    playgroundInstances.add(this);
  }
  static getLatest() {
    const instances = Playground.getAllInstances();
    return instances[instances.length - 1];
  }
  // static getSelection(selectionService: SelectionService): Entity[] {
  //   const selection = selectionService.selection;
  //   if (!selection || !Array.isArray(selection)) return [];
  //   if (selection.find(s => !(s instanceof Entity) || !s.hasAble(Selectable))) return [];
  //   return selection;
  // }
  static getAllInstances() {
    const result = [];
    for (const p of playgroundInstances.values()) {
      result.push(p);
    }
    return result;
  }
  get context() {
    return this.contextProvider?.();
  }
  get contributions() {
    return this.contributionProvider.getContributions();
  }
  init() {
    const { contributions } = this;
    for (const contrib of contributions) {
      if (contrib.registerPlayground) contrib.registerPlayground(this.registry);
    }
    for (const contrib of contributions) {
      if (contrib.onInit) contrib.onInit(this);
    }
    playgroundInstanceCreateEmitter.fire(this);
  }
  get pipelineNode() {
    return this.pipelineRenderer.node;
  }
  setParent(parent) {
    parent.appendChild(this.node);
    this.resize();
  }
  // get onDispatch(): Event<AbleDispatchEvent> {
  //   return this.ableManager.onAbleDispatch;
  // }
  /**
   * 对应的右键菜单路径
   */
  // get contextMenuPath(): string[] {
  //   return this.playgroundConfig.contextMenuPath ? this.playgroundConfig.contextMenuPath : toContextMenuPath(this.id);
  // }
  get zoomEnable() {
    return this.config.zoomEnable;
  }
  set zoomEnable(zoomEnable) {
    this.config.zoomEnable = zoomEnable;
  }
  /**
   * 转换为内部的命令 id
   * @param commandId
   */
  // toPlaygroundCommandId(commandId: string): string {
  //   return this.registry.commands.toCommandId(commandId);
  // }
  /**
   * 通知所有关联 able 的 entity
   */
  // dispatch<P>(payloadKey: string | symbol, payload: P): string[] {
  //   return this.ableManager.dispatch(payloadKey, payload);
  // }
  /**
   * 刷新所有 layer
   */
  flush() {
    this.pipelineRenderer.flush();
  }
  ready() {
    if (this.isReady) return;
    this.isReady = true;
    if (this.playgroundConfig.autoResize) {
      const resize = debounce(() => {
        if (this.disposed) return;
        this.resize();
      }, 0);
      if (typeof ResizeObserver !== "undefined") {
        const resizeObserver = new ResizeObserver(resize);
        resizeObserver.observe(this.node);
        this.toDispose.push(
          Disposable11.create(() => {
            resizeObserver.disconnect();
          })
        );
      } else {
        this.toDispose.push(
          domUtils5.addStandardDisposableListener(window.document.body, "resize", resize, {
            passive: true
          })
        );
      }
      this.toDispose.push(
        domUtils5.addStandardDisposableListener(window.document, "scroll", resize, {
          passive: true
        })
      );
      this.resize();
    }
    this.pipelineRegistry.ready();
    this.pipelineRenderer.ready();
    const { contributions } = this;
    for (const contrib of contributions) {
      if (contrib.onReady) contrib.onReady(this);
    }
  }
  /**
   * 按下边顺序执行
   * 1. 指定的 entity 位置或 pos 位置
   * 2. selection 位置
   * 3. 初始化位置
   */
  scrollToView(opts) {
    const playgroundEntity = this.entityManager.getEntity(PlaygroundConfigEntity);
    return playgroundEntity.scrollToView(opts);
  }
  /**
   * 这里会由 widget 透传进来
   * @param msg
   */
  resize(msg, scrollToCenter = true) {
    if (!msg) {
      const boundingRect = this.node.getBoundingClientRect();
      msg = {
        clientX: boundingRect.left,
        clientY: boundingRect.top,
        width: boundingRect.width,
        height: boundingRect.height
      };
    }
    const { width, height } = this.config.config;
    if (msg.width === 0 || msg.height === 0) {
      return;
    }
    let { scrollX, scrollY } = this.config.config;
    if (scrollToCenter && width && Math.round(msg.width) !== width) {
      scrollX += (width - msg.width) / 2;
    }
    if (scrollToCenter && height && Math.round(msg.height) !== height) {
      scrollY += (height - msg.height) / 2;
    }
    this.config.updateConfig({ ...msg, scrollX, scrollY });
    this.pipelineRegistry.onResizeEmitter.fire(msg);
  }
  /**
   * 触发 focus
   */
  focus() {
    if (this._focused) return;
    this._focused = true;
    this.pipelineRegistry.onFocusEmitter.fire();
  }
  /**
   * 触发 blur
   */
  blur() {
    if (!this._focused) return;
    this._focused = false;
    this.pipelineRegistry.onBlurEmitter.fire();
  }
  get focused() {
    return this._focused;
  }
  /**
   * 画布配置数据
   */
  get config() {
    return this.entityManager.getEntity(PlaygroundConfigEntity);
  }
  /**
   * 画布编辑状态管理
   */
  get editorState() {
    return this.entityManager.getEntity(EditorStateConfigEntity);
  }
  getConfigEntity(r) {
    return this.entityManager.getEntity(r, true);
  }
  dispose() {
    if (this.disposed) return;
    const { contributions } = this;
    for (const contrib of contributions) {
      if (contrib.onDispose) contrib.onDispose(this);
    }
    this.toDispose.dispose();
  }
  get disposed() {
    return this.toDispose.disposed;
  }
  /**
   * 转换成 react 组件
   */
  toReactComponent() {
    return this.pipelineRenderer.toReactComponent();
  }
  /**
   * 注册 layer
   */
  registerLayer(layerRegistry, layerOptions) {
    this.pipelineRegistry.registerLayer(layerRegistry, layerOptions);
  }
  /**
   * 注册 多个 layer
   */
  registerLayers(...layerRegistries) {
    layerRegistries.forEach((layer) => this.pipelineRegistry.registerLayer(layer));
  }
  /**
   * 获取 layer
   */
  getLayer(layerRegistry) {
    return this.pipelineRegistry.getLayer(layerRegistry);
  }
  get onAllLayersRendered() {
    return this.pipelineRenderer.onAllLayersRendered;
  }
};
/**
 * 有实例创建
 */
Playground.onInstanceCreate = playgroundInstanceCreateEmitter.event;
/**
 * 有实例销毁
 */
Playground.onInstanceDispose = playgroundInstanceDisposeEmitter.event;
Playground = __decorateClass([
  injectable13(),
  __decorateParam(0, inject10(EntityManager)),
  __decorateParam(1, inject10(PlaygroundRegistry)),
  __decorateParam(2, inject10(PlaygroundContextProvider)),
  __decorateParam(2, optional4()),
  __decorateParam(3, inject10(PipelineRenderer)),
  __decorateParam(4, inject10(PipelineRegistry)),
  __decorateParam(5, inject10(PlaygroundConfig)),
  __decorateParam(6, inject10(ContributionProvider)),
  __decorateParam(6, named(PlaygroundContribution)),
  __decorateParam(6, optional4()),
  __decorateParam(7, inject10(CommandService)),
  __decorateParam(8, inject10(SelectionService))
], Playground);

// src/playground-container.ts
function createPluginContextDefault(container) {
  return {
    container,
    playground: container.get(Playground),
    get(identifier) {
      return container.get(identifier);
    },
    getAll(identifier) {
      return container.getAll(identifier);
    }
  };
}
function createPlaygroundLayerDefault(container, layerRegistry, options = {}) {
  const layerContainer = container.createChild();
  layerContainer.bind(layerRegistry).toSelf().inSingletonScope();
  layerContainer.bind(LayerOptions).toConstantValue(options);
  const layerInstance = layerContainer.get(layerRegistry);
  removeInjectedProperties(layerInstance);
  return layerInstance;
}
var PlaygroundContainerModule = new ContainerModule2((bind) => {
  bind(EntityManager).toSelf().inSingletonScope();
  bind(PipelineRenderer).toSelf().inSingletonScope();
  bind(PlaygroundRegistry).toSelf().inSingletonScope();
  bind(Playground).toSelf().inSingletonScope();
  bind(PipelineEntitiesSelector).toSelf().inSingletonScope();
  bind(PipelineLayerFactory).toDynamicValue(
    (context) => (layerRegistry, options) => createPlaygroundLayerDefault(context.container, layerRegistry, options)
  ).inSingletonScope();
  bind(PipelineRegistry).toSelf().inSingletonScope();
  bind(PlaygroundContainerFactory).toDynamicValue((ctx) => ctx.container).inSingletonScope();
  bind(PlaygroundConfig).toConstantValue(createDefaultPlaygroundConfig());
  bind(PlaygroundContext).toConstantValue({});
  bindPlaygroundContextProvider(bind);
  bind(LoggerService).toSelf().inSingletonScope();
  bind(ContextMenuService).toSelf().inSingletonScope();
  bind(SelectionService).toSelf().inSingletonScope();
  bind(StorageService).to(LocalStorageService).inSingletonScope();
  bind(ClipboardService).to(DefaultClipboardService).inSingletonScope();
  bindConfigEntity(bind, PlaygroundConfigEntity);
  bindContributionProvider(bind, PlaygroundContribution);
  bind(PluginContext).toDynamicValue((ctx) => createPluginContextDefault(ctx.container)).inSingletonScope();
  bind(LazyInjectContext).toService(PluginContext);
});
function createPlaygroundContainer(config, parent, container) {
  const child = container || new Container({ defaultScope: "Singleton" });
  if (parent) {
    child.parent = parent;
  }
  child.load(PlaygroundContainerModule);
  if (!child.isBound(CommandService2)) {
    child.load(CommandContainerModule);
  }
  if (config) {
    child.rebind(PlaygroundConfig).toConstantValue(config);
    if (config.context) {
      child.rebind(PlaygroundContext).toConstantValue(config.context);
    }
  }
  return child;
}

// src/react/playground-react-provider.tsx
var PlaygroundReactProvider = forwardRef(function PlaygroundReactProvider2(props, ref) {
  const {
    containerModules,
    playgroundContext,
    parentContainer: fromContainer,
    playgroundContainer,
    plugins,
    customPluginContext,
    ...others
  } = props;
  const container = useMemo(() => {
    let flowContainer;
    if (playgroundContainer) {
      flowContainer = playgroundContainer;
    } else {
      flowContainer = createPlaygroundContainer(
        {
          autoFocus: true,
          autoResize: true,
          zoomEnable: true,
          ...others
        },
        fromContainer
      );
      if (playgroundContext) {
        flowContainer.rebind(PlaygroundContext).toConstantValue(playgroundContext);
      }
      if (containerModules) {
        containerModules.forEach((module) => flowContainer.load(module));
      }
    }
    return flowContainer;
  }, []);
  const playground = useMemo(() => {
    const playground2 = container.get(Playground);
    let ctx;
    if (customPluginContext) {
      ctx = customPluginContext(container);
      container.rebind(PluginContext).toConstantValue(ctx);
    } else {
      ctx = container.get(PluginContext);
    }
    if (plugins) {
      loadPlugins(plugins(ctx), container);
    }
    playground2.init();
    return playground2;
  }, []);
  useImperativeHandle(ref, () => container.get(PluginContext), []);
  return /* @__PURE__ */ React4.createElement(PlaygroundReactContainerContext.Provider, { value: container }, /* @__PURE__ */ React4.createElement(PlaygroundReactRefContext.Provider, { value: playground }, /* @__PURE__ */ React4.createElement(PlaygroundReactContext.Provider, { value: playgroundContext }, props.children)));
});

// src/react/playground-react-renderer.tsx
import ReactDOM2 from "react-dom";
import React8, { useEffect as useEffect3, useRef } from "react";

// src/react-hooks/use-playground.ts
import React5 from "react";
function usePlayground() {
  return React5.useContext(PlaygroundReactRefContext);
}

// src/react-hooks/use-entities.ts
import { useLayoutEffect } from "react";

// src/react-hooks/use-refresh.ts
import { useRefresh } from "@flowgram.ai/utils";

// src/react-hooks/use-playground-container.ts
import React6 from "react";
function usePlaygroundContainer() {
  return React6.useContext(PlaygroundReactContainerContext);
}

// src/react-hooks/use-entities.ts
function useEntities(entityRegistry) {
  const entityManager = usePlaygroundContainer().get(EntityManager);
  const refresh = useRefresh();
  useLayoutEffect(() => {
    const dispose = entityManager.onEntityChange((entityKey) => {
      if (entityKey === entityRegistry.type) {
        refresh();
      }
    });
    return () => dispose.dispose();
  }, [entityManager, refresh]);
  return entityManager.getEntities(entityRegistry);
}

// src/react-hooks/use-entity-data-from-context.ts
import { useLayoutEffect as useLayoutEffect3 } from "react";

// src/react-hooks/use-entity-from-context.ts
import { useContext, useLayoutEffect as useLayoutEffect2 } from "react";
function useEntityFromContext(listenChange = false) {
  const entityManager = usePlaygroundContainer().get(EntityManager);
  const entity = useContext(PlaygroundEntityContext);
  if (!entity) {
    throw new Error('[useEntityFromContext] Unknown entity from "PlaygroundEntityContext"');
  }
  const refresh = useRefresh(entity.version);
  useLayoutEffect2(() => {
    let dispose;
    if (listenChange) {
      dispose = entity.onEntityChange(() => refresh(entity.version));
    }
    return () => dispose?.dispose();
  }, [entityManager, refresh, entity, listenChange]);
  return entity;
}

// src/react-hooks/use-entity-data-from-context.ts
function useEntityDataFromContext(dataRegistry, listenChange = false) {
  const entityManager = usePlaygroundContainer().get(EntityManager);
  const entityData = useEntityFromContext().getData(dataRegistry);
  if (!entityData) {
    throw new Error(
      `[useEntityDataFromContext] Unknown entity Data ${dataRegistry.name} from "PlaygroundEntityContext".`
    );
  }
  const refresh = useRefresh(entityData.version);
  useLayoutEffect3(() => {
    const dispose = entityData.onDataChange(() => {
      if (listenChange) refresh(entityData.version);
    });
    return () => dispose.dispose();
  }, [entityManager, refresh, entityData, listenChange]);
  return entityData;
}

// src/react-hooks/use-listen-events.ts
import { useLayoutEffect as useLayoutEffect4 } from "react";
import { DisposableCollection as DisposableCollection8 } from "@flowgram.ai/utils";
function useListenEvents(...events) {
  const refresh = useRefresh();
  useLayoutEffect4(() => {
    const collection = new DisposableCollection8();
    collection.pushAll(events.map((e) => e(() => refresh())));
    return () => collection.dispose();
  }, [events, refresh]);
}

// src/react-hooks/use-playground-context.ts
import React7 from "react";
function usePlaygroundContext() {
  return React7.useContext(PlaygroundReactContext);
}

// src/react-hooks/use-playground-latest.ts
import { useEffect as useEffect2, useState as useState2 } from "react";
function usePlaygroundLatest() {
  const [playground, updatePlayground] = useState2(
    () => Playground.getLatest()
  );
  useEffect2(() => {
    const newPlayground = Playground.getLatest();
    if (newPlayground !== playground) {
      updatePlayground(newPlayground);
    }
    const dispose = Playground.onInstanceCreate((p) => {
      updatePlayground(p);
    });
    const dispose2 = Playground.onInstanceDispose((playgroundDisposed) => {
      if (playground === playgroundDisposed) {
        updatePlayground(void 0);
      }
    });
    return () => {
      dispose.dispose();
      dispose2.dispose();
    };
  }, [playground]);
  return playground;
}

// src/react-hooks/use-service.ts
function useService(identifier) {
  const container = usePlaygroundContainer();
  return container.get?.(identifier);
}

// src/react-hooks/use-config-entity.ts
import { useLayoutEffect as useLayoutEffect5 } from "react";
import { Disposable as Disposable12 } from "@flowgram.ai/utils";
function useConfigEntity(entityRegistry, listenChange = false) {
  const entityManager = usePlaygroundContainer().get(EntityManager);
  const entity = entityManager.getEntity(entityRegistry, true);
  const refresh = useRefresh(entity.version);
  useLayoutEffect5(() => {
    const dispose = listenChange ? entity.onEntityChange(() => {
      refresh(entity.version);
    }) : Disposable12.NULL;
    return () => dispose.dispose();
  }, [entityManager, refresh, entity, listenChange]);
  return entity;
}

// src/react-hooks/use-playground-drag.ts
import { useMemo as useMemo2 } from "react";
function usePlaygroundDrag() {
  const playground = usePlayground();
  return useMemo2(
    () => ({
      start(e, opts) {
        return PlaygroundDrag.startDrag(e.clientX, e.clientY, {
          ...opts,
          config: playground.config
        });
      }
    }),
    []
  );
}

// src/react/playground-react-renderer.tsx
var PlaygroundReactRenderer = (props) => {
  const playground = usePlayground();
  const playgroundConfig = useService(PlaygroundConfig);
  const ref = useRef();
  useEffect3(() => {
    if (ref.current) {
      playground.setParent(ref.current);
      playground.ready();
      if (playgroundConfig.autoFocus) {
        playground.node.focus();
      }
      return () => {
        playground.dispose();
      };
    }
  }, []);
  const PlaygroundComp = playground.toReactComponent();
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(
    "div",
    {
      ref,
      className: `gedit-playground-container${props.className ? ` ${props.className}` : ""}`,
      style: props.style
    }
  ), /* @__PURE__ */ React8.createElement(PlaygroundComp, null), props.children ? ReactDOM2.createPortal(/* @__PURE__ */ React8.createElement(React8.Fragment, null, props.children), playground.node) : null);
};

// src/playground-mock-tools.ts
var PlaygroundMockTools;
((PlaygroundMockTools2) => {
  const LayerStateProvider = Symbol("LayerStateProvider");
  class LayerTestState {
    constructor(instance, playground, container) {
      this.instance = instance;
      this.playground = playground;
      this.container = container;
      this.hijackMethod(instance, "autorun");
      this.hijackMethod(instance, "render");
      this.hijackMethod(instance, "onReady");
      this.hijackMethod(instance, "onResize");
      this.hijackMethod(instance, "onFocus");
      this.hijackMethod(instance, "onBlur");
      this.hijackMethod(instance, "onZoom");
      this.hijackMethod(instance, "onScroll");
      this.hijackMethod(instance, "onViewportChange");
      this.hijackMethod(instance, "onReadonlyOrDisabledChange");
    }
    hijackMethod(layer, layerMethod) {
      if (typeof layer[layerMethod] === "function") {
        this[layerMethod] = vi.spyOn(layer, layerMethod);
      }
    }
  }
  PlaygroundMockTools2.LayerTestState = LayerTestState;
  function createContainer(modules) {
    const container = createPlaygroundContainer();
    container.bind(LayerStateProvider).toConstantValue(/* @__PURE__ */ new WeakMap());
    container.rebind(PipelineLayerFactory).toDynamicValue((context) => (layerRegistry, options) => {
      const layerInstance = createPlaygroundLayerDefault(
        context.container,
        layerRegistry,
        options
      );
      context.container.get(LayerStateProvider).set(
        layerRegistry,
        new LayerTestState(layerInstance, container.get(Playground), container)
      );
      return layerInstance;
    });
    if (modules) {
      modules.forEach((module) => container.load(module));
    }
    return container;
  }
  PlaygroundMockTools2.createContainer = createContainer;
  function createPlayground(modules) {
    return createContainer(modules).get(Playground);
  }
  PlaygroundMockTools2.createPlayground = createPlayground;
  function getLayerTestState(container, layerRegistry) {
    return container.get(LayerStateProvider).get(layerRegistry);
  }
  PlaygroundMockTools2.getLayerTestState = getLayerTestState;
  function createLayerTestState(layerRegistry, opts, modules) {
    const container = createContainer(modules);
    const playground = container.get(Playground);
    playground.registerLayer(layerRegistry, opts);
    playground.init();
    playground.ready();
    return getLayerTestState(container, layerRegistry);
  }
  PlaygroundMockTools2.createLayerTestState = createLayerTestState;
})(PlaygroundMockTools || (PlaygroundMockTools = {}));

// src/index.ts
import { CommandService as CommandService3, CommandRegistry, Command } from "@flowgram.ai/command";
export {
  Bounds,
  ClipboardService,
  Command,
  CommandRegistry,
  CommandService3 as CommandService,
  ConfigEntity,
  ContextMenuService,
  ContributionProvider,
  DefaultClipboardService,
  EDITOR_STATE_DEFAULTS,
  ENTITIES_BY_DATA_DECO_KEY,
  ENTITIES_DECO_KEY,
  EditorState,
  EditorStateConfigEntity,
  Entity,
  EntityData,
  EntityManager,
  EntityManagerContribution,
  FLUSH_LAYER_REQUEST,
  FlushLayerMessage,
  Layer,
  LayerOptions,
  LazyInjectContext,
  LocalStorageService,
  LoggerEvent,
  LoggerService,
  MOUSE_SCROLL_DELTA,
  OpacityData,
  OpacitySchemaDecoration,
  OriginData,
  OriginSchemaDecoration,
  PipelineEntitiesImpl,
  PipelineEntitiesSelector,
  PipelineLayerFactory,
  PipelineLayerPriority,
  PipelineMessage,
  PipelineRegistry,
  PipelineRenderer,
  Playground,
  PlaygroundConfig,
  PlaygroundConfigEntity,
  PlaygroundContainerFactory,
  PlaygroundContainerModule,
  PlaygroundContext,
  PlaygroundContextProvider,
  PlaygroundContribution,
  PlaygroundDrag,
  PlaygroundEntityContext,
  PlaygroundGesture,
  PlaygroundLayer,
  PlaygroundMockTools,
  PlaygroundReactContainerContext,
  PlaygroundReactContext,
  PlaygroundReactProvider,
  PlaygroundReactRefContext,
  PlaygroundReactRenderer,
  PlaygroundRegistry,
  PlaygroundSchedule,
  Plugin,
  PluginContext,
  PositionData,
  PositionSchemaDecoration,
  ProtectWheelArea,
  RotationData,
  RotationSchemaDecoration,
  SCALE_WIDTH,
  ScaleData,
  ScaleSchemaDecoration,
  SelectionService,
  SizeData,
  SizeSchema,
  SizeSchemaDecoration,
  SkewData,
  SkewSchemaDecoration,
  StorageService,
  TransformData,
  TransformSchema,
  TransformSchemaDecoration,
  bindConfigEntity,
  bindContributionProvider,
  bindContributions,
  bindPlaygroundContextProvider,
  createConfigDataRegistry,
  createDefaultPlaygroundConfig,
  createPlaygroundContainer,
  createPlaygroundLayerDefault,
  createPlaygroundPlugin,
  createPluginContextDefault,
  createRegistryDecorator,
  definePluginCreator,
  getEntityDatasMetadata,
  getEntityMetadata,
  getRegistryMetadata,
  injectByProvider,
  injectPlaygroundContext,
  lazyInject,
  loadPlugins,
  observeEntities,
  observeEntity,
  observeEntityDatas,
  removeInjectedProperties,
  scrollIntoViewWithTween,
  startTween,
  useConfigEntity,
  useEntities,
  useEntityDataFromContext,
  useEntityFromContext,
  useListenEvents,
  usePlayground,
  usePlaygroundContainer,
  usePlaygroundContext,
  usePlaygroundDrag,
  usePlaygroundLatest,
  useRefresh,
  useService
};
//# sourceMappingURL=index.js.map