var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/create-free-hover-plugin.ts
import { definePluginCreator } from "@flowgram.ai/core";

// src/hover-layer.tsx
import { inject, injectable } from "inversify";
import { SelectorBoxConfigEntity } from "@flowgram.ai/renderer";
import {
  WorkflowDocument,
  WorkflowDragService,
  WorkflowHoverService,
  WorkflowLineEntity,
  WorkflowLinesManager,
  WorkflowNodeEntity as WorkflowNodeEntity2,
  WorkflowSelectService
} from "@flowgram.ai/free-layout-core";
import { WorkflowPortEntity } from "@flowgram.ai/free-layout-core";
import { FlowNodeBaseType, FlowNodeTransformData as FlowNodeTransformData2 } from "@flowgram.ai/document";
import {
  EditorState,
  EditorStateConfigEntity,
  Layer,
  PlaygroundConfigEntity,
  observeEntities,
  observeEntity,
  observeEntityDatas
} from "@flowgram.ai/core";

// src/selection-utils.ts
import { Rectangle } from "@flowgram.ai/utils";
import { WorkflowNodeEntity } from "@flowgram.ai/free-layout-core";
import { FlowNodeTransformData } from "@flowgram.ai/document";
var BOUNDS_PADDING = 2;
function getSelectionBounds(selection, ignoreOneSelect = true) {
  const selectedNodes = selection.filter((node) => node instanceof WorkflowNodeEntity);
  return selectedNodes.length > (ignoreOneSelect ? 1 : 0) ? Rectangle.enlarge(selectedNodes.map((n) => n.getData(FlowNodeTransformData).bounds)).pad(
    BOUNDS_PADDING
  ) : Rectangle.EMPTY;
}

// src/hover-layer.tsx
var PORT_BG_CLASS_NAME = "workflow-port-bg";
var HoverLayerOptions;
((HoverLayerOptions2) => {
  HoverLayerOptions2.DEFAULT = {
    canHovered: () => true
  };
})(HoverLayerOptions || (HoverLayerOptions = {}));
var LINE_CLASS_NAME = ".gedit-flow-activity-line";
var NODE_CLASS_NAME = ".gedit-flow-activity-node";
var HoverLayer = class extends Layer {
  constructor() {
    super(...arguments);
    /**
     * 按选中排序
     * @private
     */
    this.nodeTransformsWithSort = [];
  }
  autorun() {
    const { activatedNode } = this.selectionService;
    this.nodeTransformsWithSort = this.nodeTransforms.filter((n) => n.entity.id !== "root" && n.entity.flowNodeType !== FlowNodeBaseType.GROUP).reverse().sort((n1) => n1.entity === activatedNode ? -1 : 0);
  }
  /**
   * 是否正在调整线条
   * @protected
   */
  get isDrawing() {
    return this.linesManager.isDrawing;
  }
  onReady() {
    this.options = {
      ...HoverLayerOptions.DEFAULT,
      ...this.options
    };
    this.toDispose.pushAll([
      // 监听画布鼠标移动事件
      this.listenPlaygroundEvent("mousemove", (e) => {
        this.hoverService.hoveredPos = this.config.getPosFromMouseEvent(e);
        if (!this.isEnabled()) {
          return;
        }
        if (!this.options.canHovered(e, this.hoverService)) {
          return;
        }
        const mousePos = this.config.getPosFromMouseEvent(e);
        this.updateHoveredState(mousePos, e?.target);
      }),
      this.selectionService.onSelectionChanged(() => this.autorun()),
      // 控制选中逻辑
      this.listenPlaygroundEvent("mousedown", (e) => {
        if (!this.isEnabled() || this.isDrawing) {
          return void 0;
        }
        const { hoveredNode } = this.hoverService;
        if (hoveredNode && hoveredNode instanceof WorkflowLineEntity) {
          this.dragService.resetLine(hoveredNode, e);
          return true;
        }
        if (hoveredNode && hoveredNode instanceof WorkflowPortEntity && hoveredNode.portType !== "input" && !hoveredNode.disabled && e.button !== 1) {
          e.stopPropagation();
          e.preventDefault();
          this.dragService.startDrawingLine(hoveredNode, e);
          return true;
        }
        const mousePos = this.config.getPosFromMouseEvent(e);
        const selectionBounds = getSelectionBounds(
          this.selectionService.selection,
          // 这里只考虑多选模式，单选模式已经下沉到 use-node-render 中
          true
        );
        if (selectionBounds.width > 0 && selectionBounds.contains(mousePos.x, mousePos.y)) {
          this.dragService.startDragSelectedNodes(e)?.then((dragSuccess) => {
            if (!dragSuccess) {
              if (hoveredNode && hoveredNode instanceof WorkflowNodeEntity2) {
                if (e.shiftKey) {
                  this.selectionService.toggleSelect(hoveredNode);
                } else {
                  this.selectionService.selectNode(hoveredNode);
                }
              } else {
                this.selectionService.clear();
              }
            }
          });
          return true;
        } else {
          if (!hoveredNode) {
            this.selectionService.clear();
          }
        }
        return void 0;
      })
    ]);
  }
  /**
   * 更新 hoverd
   * @param mousePos
   */
  updateHoveredState(mousePos, target) {
    const { hoverService } = this;
    const nodeTransforms = this.nodeTransformsWithSort;
    const portHovered = this.linesManager.getPortFromMousePos(mousePos);
    const lineDomNodes = this.playgroundNode.querySelectorAll(LINE_CLASS_NAME);
    const checkTargetFromLine = [...lineDomNodes].some(
      (lineDom) => lineDom.contains(target)
    );
    if (portHovered) {
      if (portHovered.portType === "output") {
        hoverService.updateHoveredKey(portHovered.id);
      } else if (checkTargetFromLine || target?.className?.includes?.(PORT_BG_CLASS_NAME)) {
        const lineHovered2 = this.linesManager.getCloseInLineFromMousePos(mousePos);
        if (lineHovered2) {
          this.updateHoveredKey(lineHovered2.id);
        }
      }
      return;
    }
    if (this.isDrawing) {
      return;
    }
    const nodeHovered = nodeTransforms.find(
      (trans) => trans.bounds.contains(mousePos.x, mousePos.y)
    )?.entity;
    const nodeDomNodes = this.playgroundNode.querySelectorAll(NODE_CLASS_NAME);
    const checkTargetFromNode = [...nodeDomNodes].some(
      (nodeDom) => nodeDom.contains(target)
    );
    if (nodeHovered || checkTargetFromNode) {
      if (nodeHovered?.id) {
        this.updateHoveredKey(nodeHovered.id);
      }
    }
    const nodeInContainer = !!(nodeHovered?.parent && nodeHovered.parent.flowNodeType !== "root");
    const lineHovered = checkTargetFromLine ? this.linesManager.getCloseInLineFromMousePos(mousePos) : void 0;
    const lineInContainer = !!lineHovered?.inContainer;
    if (nodeHovered && nodeInContainer) {
      this.updateHoveredKey(nodeHovered.id);
      return;
    }
    if (lineHovered && lineInContainer) {
      this.updateHoveredKey(lineHovered.id);
      return;
    }
    if (nodeHovered) {
      this.updateHoveredKey(nodeHovered.id);
      return;
    }
    if (lineHovered) {
      this.hoverService.updateHoveredKey(lineHovered.id);
      return;
    }
    hoverService.clearHovered();
    const currentState = this.editorStateConfig.getCurrentState();
    const isMouseFriendly = currentState === EditorState.STATE_MOUSE_FRIENDLY_SELECT;
    if (isMouseFriendly && !this.editorStateConfig.isPressingShift) {
      this.configEntity.updateCursor("grab");
    }
  }
  updateHoveredKey(key) {
    this.configEntity.updateCursor("default");
    this.hoverService.updateHoveredKey(key);
  }
  /**
   * 判断是否能够 hover
   * @returns 是否能 hover
   */
  isEnabled() {
    const currentState = this.editorStateConfig.getCurrentState();
    return (
      // 鼠标友好模式下，也需要支持 hover 效果，不然线条选择不到
      // Coze 中没有使用该插件，需要在 workflow/render 包相应位置改动
      (currentState === EditorState.STATE_SELECT || currentState === EditorState.STATE_MOUSE_FRIENDLY_SELECT) && !this.selectorBoxConfigEntity.isStart && !this.dragService.isDragging
    );
  }
};
HoverLayer.type = "HoverLayer";
__decorateClass([
  inject(WorkflowDocument)
], HoverLayer.prototype, "document", 2);
__decorateClass([
  inject(WorkflowSelectService)
], HoverLayer.prototype, "selectionService", 2);
__decorateClass([
  inject(WorkflowDragService)
], HoverLayer.prototype, "dragService", 2);
__decorateClass([
  inject(WorkflowHoverService)
], HoverLayer.prototype, "hoverService", 2);
__decorateClass([
  inject(WorkflowLinesManager)
], HoverLayer.prototype, "linesManager", 2);
__decorateClass([
  observeEntity(EditorStateConfigEntity)
], HoverLayer.prototype, "editorStateConfig", 2);
__decorateClass([
  observeEntity(SelectorBoxConfigEntity)
], HoverLayer.prototype, "selectorBoxConfigEntity", 2);
__decorateClass([
  inject(PlaygroundConfigEntity)
], HoverLayer.prototype, "configEntity", 2);
__decorateClass([
  observeEntityDatas(WorkflowNodeEntity2, FlowNodeTransformData2)
], HoverLayer.prototype, "nodeTransforms", 2);
__decorateClass([
  observeEntities(WorkflowLineEntity)
], HoverLayer.prototype, "lines", 2);
HoverLayer = __decorateClass([
  injectable()
], HoverLayer);

// src/create-free-hover-plugin.ts
var createFreeHoverPlugin = definePluginCreator({
  onInit(ctx) {
    ctx.playground.registerLayer(HoverLayer);
  }
});
export {
  createFreeHoverPlugin
};
//# sourceMappingURL=index.js.map