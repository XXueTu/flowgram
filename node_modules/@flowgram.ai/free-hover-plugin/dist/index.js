"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createFreeHoverPlugin: () => createFreeHoverPlugin
});
module.exports = __toCommonJS(src_exports);

// src/create-free-hover-plugin.ts
var import_core2 = require("@flowgram.ai/core");

// src/hover-layer.tsx
var import_inversify = require("inversify");
var import_renderer = require("@flowgram.ai/renderer");
var import_free_layout_core2 = require("@flowgram.ai/free-layout-core");
var import_free_layout_core3 = require("@flowgram.ai/free-layout-core");
var import_document2 = require("@flowgram.ai/document");
var import_core = require("@flowgram.ai/core");

// src/selection-utils.ts
var import_utils = require("@flowgram.ai/utils");
var import_free_layout_core = require("@flowgram.ai/free-layout-core");
var import_document = require("@flowgram.ai/document");
var BOUNDS_PADDING = 2;
function getSelectionBounds(selection, ignoreOneSelect = true) {
  const selectedNodes = selection.filter((node) => node instanceof import_free_layout_core.WorkflowNodeEntity);
  return selectedNodes.length > (ignoreOneSelect ? 1 : 0) ? import_utils.Rectangle.enlarge(selectedNodes.map((n) => n.getData(import_document.FlowNodeTransformData).bounds)).pad(
    BOUNDS_PADDING
  ) : import_utils.Rectangle.EMPTY;
}

// src/hover-layer.tsx
var PORT_BG_CLASS_NAME = "workflow-port-bg";
var HoverLayerOptions;
((HoverLayerOptions2) => {
  HoverLayerOptions2.DEFAULT = {
    canHovered: () => true
  };
})(HoverLayerOptions || (HoverLayerOptions = {}));
var LINE_CLASS_NAME = ".gedit-flow-activity-line";
var NODE_CLASS_NAME = ".gedit-flow-activity-node";
var HoverLayer = class extends import_core.Layer {
  constructor() {
    super(...arguments);
    /**
     * 按选中排序
     * @private
     */
    this.nodeTransformsWithSort = [];
  }
  autorun() {
    const { activatedNode } = this.selectionService;
    this.nodeTransformsWithSort = this.nodeTransforms.filter((n) => n.entity.id !== "root" && n.entity.flowNodeType !== import_document2.FlowNodeBaseType.GROUP).reverse().sort((n1) => n1.entity === activatedNode ? -1 : 0);
  }
  /**
   * 是否正在调整线条
   * @protected
   */
  get isDrawing() {
    return this.linesManager.isDrawing;
  }
  onReady() {
    this.options = {
      ...HoverLayerOptions.DEFAULT,
      ...this.options
    };
    this.toDispose.pushAll([
      // 监听画布鼠标移动事件
      this.listenPlaygroundEvent("mousemove", (e) => {
        this.hoverService.hoveredPos = this.config.getPosFromMouseEvent(e);
        if (!this.isEnabled()) {
          return;
        }
        if (!this.options.canHovered(e, this.hoverService)) {
          return;
        }
        const mousePos = this.config.getPosFromMouseEvent(e);
        this.updateHoveredState(mousePos, e?.target);
      }),
      this.selectionService.onSelectionChanged(() => this.autorun()),
      // 控制选中逻辑
      this.listenPlaygroundEvent("mousedown", (e) => {
        if (!this.isEnabled() || this.isDrawing) {
          return void 0;
        }
        const { hoveredNode } = this.hoverService;
        if (hoveredNode && hoveredNode instanceof import_free_layout_core2.WorkflowLineEntity) {
          this.dragService.resetLine(hoveredNode, e);
          return true;
        }
        if (hoveredNode && hoveredNode instanceof import_free_layout_core3.WorkflowPortEntity && hoveredNode.portType !== "input" && !hoveredNode.disabled && e.button !== 1) {
          e.stopPropagation();
          e.preventDefault();
          this.dragService.startDrawingLine(hoveredNode, e);
          return true;
        }
        const mousePos = this.config.getPosFromMouseEvent(e);
        const selectionBounds = getSelectionBounds(
          this.selectionService.selection,
          // 这里只考虑多选模式，单选模式已经下沉到 use-node-render 中
          true
        );
        if (selectionBounds.width > 0 && selectionBounds.contains(mousePos.x, mousePos.y)) {
          this.dragService.startDragSelectedNodes(e)?.then((dragSuccess) => {
            if (!dragSuccess) {
              if (hoveredNode && hoveredNode instanceof import_free_layout_core2.WorkflowNodeEntity) {
                if (e.shiftKey) {
                  this.selectionService.toggleSelect(hoveredNode);
                } else {
                  this.selectionService.selectNode(hoveredNode);
                }
              } else {
                this.selectionService.clear();
              }
            }
          });
          return true;
        } else {
          if (!hoveredNode) {
            this.selectionService.clear();
          }
        }
        return void 0;
      })
    ]);
  }
  /**
   * 更新 hoverd
   * @param mousePos
   */
  updateHoveredState(mousePos, target) {
    const { hoverService } = this;
    const nodeTransforms = this.nodeTransformsWithSort;
    const portHovered = this.linesManager.getPortFromMousePos(mousePos);
    const lineDomNodes = this.playgroundNode.querySelectorAll(LINE_CLASS_NAME);
    const checkTargetFromLine = [...lineDomNodes].some(
      (lineDom) => lineDom.contains(target)
    );
    if (portHovered) {
      if (portHovered.portType === "output") {
        hoverService.updateHoveredKey(portHovered.id);
      } else if (checkTargetFromLine || target?.className?.includes?.(PORT_BG_CLASS_NAME)) {
        const lineHovered2 = this.linesManager.getCloseInLineFromMousePos(mousePos);
        if (lineHovered2) {
          this.updateHoveredKey(lineHovered2.id);
        }
      }
      return;
    }
    if (this.isDrawing) {
      return;
    }
    const nodeHovered = nodeTransforms.find(
      (trans) => trans.bounds.contains(mousePos.x, mousePos.y)
    )?.entity;
    const nodeDomNodes = this.playgroundNode.querySelectorAll(NODE_CLASS_NAME);
    const checkTargetFromNode = [...nodeDomNodes].some(
      (nodeDom) => nodeDom.contains(target)
    );
    if (nodeHovered || checkTargetFromNode) {
      if (nodeHovered?.id) {
        this.updateHoveredKey(nodeHovered.id);
      }
    }
    const nodeInContainer = !!(nodeHovered?.parent && nodeHovered.parent.flowNodeType !== "root");
    const lineHovered = checkTargetFromLine ? this.linesManager.getCloseInLineFromMousePos(mousePos) : void 0;
    const lineInContainer = !!lineHovered?.inContainer;
    if (nodeHovered && nodeInContainer) {
      this.updateHoveredKey(nodeHovered.id);
      return;
    }
    if (lineHovered && lineInContainer) {
      this.updateHoveredKey(lineHovered.id);
      return;
    }
    if (nodeHovered) {
      this.updateHoveredKey(nodeHovered.id);
      return;
    }
    if (lineHovered) {
      this.hoverService.updateHoveredKey(lineHovered.id);
      return;
    }
    hoverService.clearHovered();
    const currentState = this.editorStateConfig.getCurrentState();
    const isMouseFriendly = currentState === import_core.EditorState.STATE_MOUSE_FRIENDLY_SELECT;
    if (isMouseFriendly && !this.editorStateConfig.isPressingShift) {
      this.configEntity.updateCursor("grab");
    }
  }
  updateHoveredKey(key) {
    this.configEntity.updateCursor("default");
    this.hoverService.updateHoveredKey(key);
  }
  /**
   * 判断是否能够 hover
   * @returns 是否能 hover
   */
  isEnabled() {
    const currentState = this.editorStateConfig.getCurrentState();
    return (
      // 鼠标友好模式下，也需要支持 hover 效果，不然线条选择不到
      // Coze 中没有使用该插件，需要在 workflow/render 包相应位置改动
      (currentState === import_core.EditorState.STATE_SELECT || currentState === import_core.EditorState.STATE_MOUSE_FRIENDLY_SELECT) && !this.selectorBoxConfigEntity.isStart && !this.dragService.isDragging
    );
  }
};
HoverLayer.type = "HoverLayer";
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowDocument)
], HoverLayer.prototype, "document", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowSelectService)
], HoverLayer.prototype, "selectionService", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowDragService)
], HoverLayer.prototype, "dragService", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowHoverService)
], HoverLayer.prototype, "hoverService", 2);
__decorateClass([
  (0, import_inversify.inject)(import_free_layout_core2.WorkflowLinesManager)
], HoverLayer.prototype, "linesManager", 2);
__decorateClass([
  (0, import_core.observeEntity)(import_core.EditorStateConfigEntity)
], HoverLayer.prototype, "editorStateConfig", 2);
__decorateClass([
  (0, import_core.observeEntity)(import_renderer.SelectorBoxConfigEntity)
], HoverLayer.prototype, "selectorBoxConfigEntity", 2);
__decorateClass([
  (0, import_inversify.inject)(import_core.PlaygroundConfigEntity)
], HoverLayer.prototype, "configEntity", 2);
__decorateClass([
  (0, import_core.observeEntityDatas)(import_free_layout_core2.WorkflowNodeEntity, import_document2.FlowNodeTransformData)
], HoverLayer.prototype, "nodeTransforms", 2);
__decorateClass([
  (0, import_core.observeEntities)(import_free_layout_core2.WorkflowLineEntity)
], HoverLayer.prototype, "lines", 2);
HoverLayer = __decorateClass([
  (0, import_inversify.injectable)()
], HoverLayer);

// src/create-free-hover-plugin.ts
var createFreeHoverPlugin = (0, import_core2.definePluginCreator)({
  onInit(ctx) {
    ctx.playground.registerLayer(HoverLayer);
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createFreeHoverPlugin
});
//# sourceMappingURL=index.js.map