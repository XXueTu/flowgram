import { interfaces } from 'inversify';

declare const PI: number;
/** Two Pi. */
declare const PI_2: number;
/** Conversion factor for converting radians to degrees. */
declare const RAD_TO_DEG: number;
/** Conversion factor for converting degrees to radians. */
declare const DEG_TO_RAD: number;
/** Constants that identify shapes. */
declare enum SHAPES {
    /** Polygon */
    POLY = 0,
    /** Rectangle */
    RECT = 1,
    /** Circle */
    CIRC = 2,
    /** Ellipse */
    ELIP = 3,
    /** Rounded Rectangle */
    RREC = 4
}

declare class Vector2 {
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    /**
     * 向量减法
     */
    sub(v: Vector2): Vector2;
    /**
     * 向量点乘
     */
    dot(v: Vector2): number;
}

/**
 * Common interface for points. Both Point and ObservablePoint implement it
 */
interface IPoint {
    /**
     * X coord
     */
    x: number;
    /**
     * Y coord
     */
    y: number;
}

type SchemaType = 'string' | 'integer' | 'float' | 'boolean' | 'enum' | 'object' | 'range' | 'color' | 'array';
interface SchemaMixinDefaults {
    [defaultKey: string]: any;
}
interface SchemaDecoration<SCHEMA = any> {
    type: SchemaType;
    label?: string;
    description?: string;
    properties?: {
        [K in keyof SCHEMA]: SchemaDecoration<SCHEMA[K]> & {
            priority?: number;
        };
    };
    enumValues?: (string | number)[];
    enumType?: string | number;
    enumLabels?: string[];
    rangeStep?: number;
    max?: number;
    min?: number;
    disabled?: boolean;
    default?: SCHEMA;
    mixinDefaults?: SchemaMixinDefaults;
}
declare namespace SchemaDecoration {
    /**
     * 扩展 SchemaDecoration
     *
     * @param properties - 定义新的属性
     * @param baseDecoration - 基类
     * @param mixinDefaults - 修改默认值
     * @example
     *    const MySchemaDecoration = SchemaDecoration.create({
     *      myProp: { label: '', default: 1, type: 'number' }
     *    },
     *    TransformSchemaDecoration, // 继承 Transform
     *    {
     *      'size.width': 100, // 修改 size 的默认值
     *      'size.height': 100,
     *    })
     */
    function create<T>(properties: {
        [key: string]: SchemaDecoration;
    }, baseDecoration?: SchemaDecoration, mixinDefaults?: SchemaMixinDefaults): SchemaDecoration<T>;
}
declare namespace Schema {
    function createDefault<T>(decoration: SchemaDecoration, mixinDefaults?: SchemaMixinDefaults, _key?: string): T;
    /**
     * 非 object 类
     */
    function isBaseType(decoration: SchemaDecoration): boolean;
}

interface PositionSchema {
    x: number;
    y: number;
}
type RotationSchema = number;
interface OriginSchema {
    x: number;
    y: number;
}
interface ScaleSchema {
    x: number;
    y: number;
}
interface ScrollSchema {
    scrollX: number;
    scrollY: number;
}
interface SkewSchema {
    x: number;
    y: number;
}
declare const SizeSchemaDecoration: SchemaDecoration<SizeSchema>;
declare const OriginSchemaDecoration: SchemaDecoration<OriginSchema>;
declare const PositionSchemaDecoration: SchemaDecoration<PositionSchema>;
declare const RotationSchemaDecoration: SchemaDecoration<RotationSchema>;
declare const ScaleSchemaDecoration: SchemaDecoration<ScaleSchema>;
declare const SkewSchemaDecoration: SchemaDecoration<SkewSchema>;
declare const TransformSchemaDecoration: SchemaDecoration<TransformSchema>;
interface TransformSchema {
    position: PositionSchema;
    size: SizeSchema;
    origin: OriginSchema;
    scale: ScaleSchema;
    skew: SkewSchema;
    rotation: RotationSchema;
}
declare namespace TransformSchema {
    function createDefault(): TransformSchema;
    function toJSON(obj: TransformSchema): TransformSchema;
    function getDelta(oldTransform: TransformSchema, newTransform: TransformSchema): TransformSchema;
    function mergeDelta(oldTransform: TransformSchema, newTransformDelta: TransformSchema, toFixedNum?: number): TransformSchema;
    function is(obj: object): obj is TransformSchema;
}
interface SizeSchema {
    width: number;
    height: number;
    locked?: boolean;
}
declare namespace SizeSchema {
    /**
     * 适配父节点宽高
     *
     * @return 返回需要缩放的比例，为 1 则不缩放
     */
    function fixSize(currentSize: SizeSchema, parentSize: SizeSchema): number;
    /**
     * 填充父节点的宽高
     *
     * @return 返回放大的比例
     */
    function coverSize(currentSize: SizeSchema, parentSize: SizeSchema): number;
    function empty(): SizeSchema;
}

type OpacitySchema = number;
interface FlipSchema {
    x: boolean;
    y: boolean;
}
interface ShadowSchema {
    color: string;
    offsetX: number;
    offsetY: number;
    blur: number;
}
interface PaddingSchema {
    left: number;
    right: number;
    top: number;
    bottom: number;
}
declare namespace PaddingSchema {
    const empty: () => {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
}
type MarginSchema = PaddingSchema;
interface TintSchema {
    topLeft: string;
    topRight: string;
    bottomLeft: string;
    bottomRight: string;
}
declare namespace TintSchema {
    function isEmpty(tint: Partial<TintSchema> | undefined): boolean;
}
declare const CropSchemaDecoration: SchemaDecoration<PositionSchema & SizeSchema>;
declare const FlipSchemaDecoration: SchemaDecoration<FlipSchema>;
declare const PaddingSchemaDecoration: SchemaDecoration<PaddingSchema>;
declare const ShadowSchemaDecoration: SchemaDecoration<ShadowSchema>;
declare const TintSchemaDecoration: SchemaDecoration<TintSchema>;
declare const OpacitySchemaDecoration: SchemaDecoration<OpacitySchema>;

/**
 * Size object, contains width and height
 */
type ISize = {
    width: number;
    height: number;
};
declare enum RectangleAlignType {
    ALIGN_LEFT = "align-left",
    ALIGN_CENTER = "align-center",
    ALIGN_RIGHT = "align-right",
    ALIGN_TOP = "align-top",
    ALIGN_MIDDLE = "align-middle",
    ALIGN_BOTTOM = "align-bottom",
    DISTRIBUTE_HORIZONTAL = "distribute-horizontal",
    DISTRIBUTE_VERTICAL = "distribute-vertical"
}
declare enum RectangleAlignTitle {
    ALIGN_LEFT = "\u5DE6\u5BF9\u9F50",
    ALIGN_CENTER = "\u5DE6\u53F3\u5C45\u4E2D\u5BF9\u9F50",
    ALIGN_RIGHT = "\u53F3\u5BF9\u9F50",
    ALIGN_TOP = "\u4E0A\u5BF9\u9F50",
    ALIGN_MIDDLE = "\u4E0A\u4E0B\u5C45\u4E2D\u5BF9\u9F50",
    ALIGN_BOTTOM = "\u4E0B\u5BF9\u9F50",
    DISTRIBUTE_HORIZONTAL = "\u6C34\u5E73\u5E73\u5747\u5206\u5E03",
    DISTRIBUTE_VERTICAL = "\u5782\u76F4\u5E73\u5747\u5206\u5E03"
}
/**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 */
declare class Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     */
    readonly type = SHAPES.RECT;
    /**
     * @param [x] - The X coordinate of the upper-left corner of the rectangle
     * @param [y] - The Y coordinate of the upper-left corner of the rectangle
     * @param [width] - The overall width of this rectangle
     * @param [height] - The overall height of this rectangle
     */
    constructor(x?: number, y?: number, width?: number, height?: number);
    /**
     * A constant empty rectangle. MUST NOT modify properties!
     */
    static get EMPTY(): Rectangle;
    get left(): number;
    get right(): number;
    get top(): number;
    get bottom(): number;
    /**
     * Creates a clone of this Rectangle.
     *
     * @return a copy of the rectangle
     */
    clone(): Rectangle;
    /**
     * Copies another rectangle to this one.
     *
     * @return Returns itself.
     */
    copyFrom(rectangle: Rectangle): Rectangle;
    /**
     * Copies this rectangle to another one.
     *
     * @return Returns given rectangle.
     */
    copyTo(rectangle: Rectangle): Rectangle;
    /**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param x - The X coordinate of the point to test
     * @param y - The Y coordinate of the point to test
     * @return Whether the x/y coordinates are within this Rectangle
     */
    contains(x: number, y: number): boolean;
    isEqual(rect: Rectangle): boolean;
    containsRectangle(rect: Rectangle): boolean;
    /**
     * Pads the rectangle making it grow in all directions.
     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
     *
     * @param [paddingX] - The horizontal padding amount.
     * @param [paddingY] - The vertical padding amount.
     */
    pad(paddingX?: number, paddingY?: number): this;
    /**
     * Fits this rectangle around the passed one.
     * Intersection 交集
     */
    fit(rectangle: Rectangle): this;
    /**
     * Enlarges rectangle that way its corners lie on grid
     */
    ceil(resolution?: number, precision?: number): this;
    /**
     * Enlarges this rectangle to include the passed rectangle.
     */
    enlarge(rectangle: Rectangle): this;
    get center(): IPoint;
    get rightBottom(): IPoint;
    get leftBottom(): IPoint;
    get rightTop(): IPoint;
    get leftTop(): IPoint;
    get bottomCenter(): IPoint;
    get topCenter(): IPoint;
    get rightCenter(): IPoint;
    get leftCenter(): IPoint;
    update(fn: (rect: Rectangle) => Rectangle): Rectangle;
    get crossDistance(): number;
    toStyleStr(): string;
    withPadding(padding: PaddingSchema): this;
    withoutPadding(padding: PaddingSchema): this;
    withHeight(height: number): this;
    clearSpace(): this;
}
declare namespace Rectangle {
    /**
     * 矩形对齐
     */
    function align(rectangles: Rectangle[], type: RectangleAlignType): Rectangle[];
    /**
     * 获取所有矩形的外围最大边框
     */
    function enlarge(rectangles: Rectangle[]): Rectangle;
    /**
     * 判断矩形相交
     *
     * @param [direction] 判断单一方向
     */
    function intersects(target1: Rectangle, target2: Rectangle, direction?: 'horizontal' | 'vertical'): boolean;
    /**
     * 使用 OBB 算法判断两个旋转矩形是否相交
     * @param rotate1 单位 radian
     * @param rotate2 单位 radian
     */
    function intersectsWithRotation(rect1: Rectangle, rotate1: number, rect2: Rectangle, rotate2: number): boolean;
    /**
     * 判断指定 rect 是否在 viewport 可见
     *
     * @param rotation rect 旋转，单位 radian
     * @param isContains 整个 bounds 是否全部可见
     */
    function isViewportVisible(rect: Rectangle, viewport: Rectangle, rotation?: number, isContains?: boolean): boolean;
    /**
     * 保证bounds 永远在 viewport 里边
     *
     * @param bounds
     * @param viewport
     * @param padding 距离 viewport 的安全边界
     */
    function setViewportVisible(bounds: Rectangle, viewport: Rectangle, padding?: number): Rectangle;
    /**
     * 根据两点创建矩形
     */
    function createRectangleWithTwoPoints(point1: IPoint, point2: IPoint): Rectangle;
}
/**
 * Oriented Bounding Box (OBB)
 * @see https://en.wikipedia.org/wiki/Bounding_volume
 */
declare class OBBRect {
    protected width: number;
    protected height: number;
    readonly axesX: Vector2;
    readonly axesY: Vector2;
    readonly centerPoint: Vector2;
    /**
     * @param rotation in radian
     */
    constructor(centerPoint: IPoint, width: number, height: number, rotation: number);
    /**
     * 计算投影半径
     */
    getProjectionRadius(axis: Vector2): number;
}

/**
 * The Circle object is used to help draw graphics and can also be used to specify a hit area for displayObjects.
 */
declare class Circle {
    x: number;
    y: number;
    radius: number;
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     */
    readonly type = SHAPES.CIRC;
    /**
     * @param x Circle center x
     * @param y Circle center y
     */
    constructor(x?: number, y?: number, radius?: number);
    /**
     * Creates a clone of this Circle instance
     *
     * @return a copy of the Circle
     */
    clone(): Circle;
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @return Whether the (x, y) coordinates are within this Circle
     */
    contains(x: number, y: number): boolean;
    /**
     * Returns the framing rectangle of the circle as a Rectangle object
     *
     * @return the framing rectangle
     */
    getBounds(): Rectangle;
}

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * An ObservablePoint is a point that triggers a callback when the point's position is changed.
 */
declare class ObservablePoint<T = any> implements IPoint {
    cb: (this: T) => any;
    scope: any;
    /**
     * @param {Function} cb - callback when changed
     * @param {object} scope - owner of callback
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    constructor(cb: (this: T) => any, scope: T, x?: number, y?: number);
    _x: number;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     */
    get x(): number;
    set x(value: number);
    _y: number;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     */
    get y(): number;
    set y(value: number);
    /**
     * Creates a clone of this point.
     * The callback and scope params can be overidden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param {Function} [cb=null] - callback when changed
     * @param {object} [scope=null] - owner of callback
     * @return {ObservablePoint} a copy of the point
     */
    clone(cb?: (this: T) => any, scope?: any): ObservablePoint;
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=x] - position of the point on the y axis
     * @returns {this} Returns itself.
     */
    set(x?: number, y?: number): this;
    /**
     * Copies x and y from the given point
     *
     * @param {IPoint} p - The point to copy from.
     * @returns {this} Returns itself.
     */
    copyFrom(p: IPoint): this;
    /**
     * Copies x and y into the given point
     *
     * @param {IPoint} p - The point to copy.
     * @returns {IPoint} Given point with values updated
     */
    copyTo<T2 extends IPoint>(p: T2): T2;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p: IPoint): boolean;
}

/**
 * Transform that takes care about its versions
 *
 * @class
 * @memberof PIXI
 */
declare class Transform {
    /**
     * A default (identity) transform
     *
     * @static
     * @constant
     * @member {PIXI.Transform}
     */
    static readonly IDENTITY: Transform;
    worldTransform: Matrix;
    localTransform: Matrix;
    position: ObservablePoint;
    scale: ObservablePoint;
    pivot: ObservablePoint;
    skew: ObservablePoint;
    _parentID: number;
    _worldID: number;
    protected _rotation: number;
    protected _cx: number;
    protected _sx: number;
    protected _cy: number;
    protected _sy: number;
    protected _localID: number;
    protected _currentLocalID: number;
    constructor();
    /**
     * Called when a value changes.
     *
     * @protected
     */
    protected onChange(): void;
    /**
     * Called when the skew or the rotation changes.
     *
     * @protected
     */
    protected updateSkew(): void;
    /**
     * Updates the local transformation matrix.
     */
    updateLocalTransform(): void;
    /**
     * Updates the local and the world transformation matrices.
     *
     * @param {PIXI.Transform} parentTransform - The parent transform
     */
    updateTransform(parentTransform: Transform): void;
    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */
    setFromMatrix(matrix: Matrix): void;
    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    get rotation(): number;
    set rotation(value: number);
}

/**
 * The PIXIJS Matrix as a class makes it a lot faster.
 *
 * Here is a representation of it:
 * ```js
 * | a | c | tx|
 * | b | d | ty|
 * | 0 | 0 | 1 |
 * // default:
 * | 1 | 0 | 0 |
 * | 0 | 1 | 0 |
 * | 0 | 0 | 1 |
 * ```
 */
declare class Matrix {
    a: number;
    b: number;
    c: number;
    d: number;
    tx: number;
    ty: number;
    array: Float32Array | null;
    /**
     * @param [a] x scale
     * @param [b] x skew
     * @param [c] y skew
     * @param [d] y scale
     * @param [tx] x translation
     * @param [ty] y translation
     */
    constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
    /**
     * A default (identity) matrix
     */
    static get IDENTITY(): Matrix;
    /**
     * A temp matrix
     */
    static get TEMP_MATRIX(): Matrix;
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * @param array The array that the matrix will be populated from.
     */
    fromArray(array: number[]): this;
    /**
     * sets the matrix properties
     *
     * @param a Matrix component
     * @param b Matrix component
     * @param c Matrix component
     * @param d Matrix component
     * @param tx Matrix component
     * @param ty Matrix component
     */
    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this;
    /**
     * Creates an array from the current Matrix object.
     *
     * @param transpose Whether we need to transpose the matrix or not
     * @param [out=new Float32Array(9)] If provided the array will be assigned to out
     * @return the newly created array which contains the matrix
     */
    toArray(transpose: boolean, out?: Float32Array): Float32Array;
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param pos The origin
     * @param [newPos] The point that the new position is assigned to (allowed to be same as input)
     * @return The new point, transformed through this matrix
     */
    apply(pos: IPoint, newPos?: IPoint): IPoint;
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param pos The origin
     * @param [newPos] The point that the new position is assigned to (allowed to be same as input)
     * @return The new point, inverse-transformed through this matrix
     */
    applyInverse(pos: IPoint, newPos?: IPoint): IPoint;
    /**
     * Translates the matrix on the x and y.
     *
     * @param x How much to translate x by
     * @param y How much to translate y by
     */
    translate(x: number, y: number): this;
    /**
     * Applies a scale transformation to the matrix.
     *
     * @param x The amount to scale horizontally
     * @param y The amount to scale vertically
     */
    scale(x: number, y: number): this;
    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param angle The angle in radians.
     */
    rotate(angle: number): this;
    /**
     * 矩阵乘法，当前矩阵 * matrix
     * Appends the given Matrix to this Matrix.
     */
    append(matrix: Matrix): this;
    /**
     * Sets the matrix based on all the available properties
     *
     * @param x Position on the x axis
     * @param y Position on the y axis
     * @param pivotX Pivot on the x axis
     * @param pivotY Pivot on the y axis
     * @param scaleX Scale on the x axis
     * @param scaleY Scale on the y axis
     * @param rotation Rotation in radians
     * @param skewX Skew on the x axis
     * @param skewY Skew on the y axis
     */
    setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number, scaleY: number, rotation: number, skewX: number, skewY: number): this;
    /**
     * 矩阵乘法，matrix * 当前矩阵
     * Prepends the given Matrix to this Matrix.
     */
    prepend(matrix: Matrix): this;
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param transform The transform to apply the properties to.
     * @return The transform with the newly applied properties
     */
    decompose(transform: Transform): Transform;
    /**
     * Inverts this matrix
     */
    invert(): this;
    /**
     * Resets this Matrix to an identity (default) matrix.
     */
    identity(): this;
    /**
     * 未做旋转的矩阵
     */
    isSimple(): boolean;
    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return A copy of this matrix.
     */
    clone(): Matrix;
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @return The matrix given in parameter with its values updated.
     */
    copyTo(matrix: Matrix): Matrix;
    /**
     * Changes the values of the matrix to be the same as the ones in given matrix
     */
    copyFrom(matrix: Matrix): this;
}

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 * @implements IPoint
 */
declare class Point implements IPoint {
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    /**
     * Creates a clone of this point
     *
     * @return {Point} a copy of the point
     */
    clone(): Point;
    /**
     * Copies x and y from the given point
     *
     * @param {IPoint} p - The point to copy from
     * @returns {this} Returns itself.
     */
    copyFrom(p: IPoint): this;
    /**
     * Copies x and y into the given point
     *
     * @param {IPoint} p - The point to copy.
     * @returns {IPoint} Given point with values updated
     */
    copyTo<T extends IPoint>(p: T): T;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p: IPoint): boolean;
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=x] - position of the point on the y axis
     * @returns {this} Returns itself.
     */
    set(x?: number, y?: number): this;
}
declare namespace Point {
    const EMPTY: IPoint;
    /**
     * 获取两点间的距离
     * @param p1
     * @param p2
     */
    function getDistance(p1: IPoint, p2: IPoint): number;
    /**
     * 获取两点间的中间点
     * @param p1
     * @param p2
     */
    function getMiddlePoint(p1: IPoint, p2: IPoint): IPoint;
    /**
     * 按一定比例，获取两点间的中间点
     * @param p1
     * @param p2
     */
    function getRatioPoint(p1: IPoint, p2: IPoint, ratio: number): IPoint;
    function fixZero(output: IPoint): IPoint;
    /**
     * 往目标点移动 distance 距离
     * @param current
     * @param direction
     */
    function move(current: IPoint, m: Partial<IPoint>): IPoint;
    /**
     * 往目标点移动 distance 距离
     * @param current
     * @param direction
     */
    function moveDistanceToDirection(current: IPoint, direction: IPoint, distance: number): IPoint;
}

declare namespace Angle {
    /**
     * Wrap an angle.
     *
     * Wraps the angle to a value in the range of -PI to PI.
     *
     * @param angle - The angle to wrap, in radians.
     * @return The wrapped angle, in radians.
     */
    function wrap(angle: number): number;
    /**
     * Wrap an angle in degrees.
     *
     * Wraps the angle to a value in the range of -180 to 180.
     *
     * @param angle - The angle to wrap, in degrees.
     * @return The wrapped angle, in degrees.
     */
    function wrapDegrees(angle: number): number;
    /**
     * 计算两个点的夹角
     *
     * @return The angle in radians.
     */
    function betweenPoints(point1: IPoint, point2: IPoint, originPoint?: IPoint): number;
}

declare function deepFreeze<T>(obj: T): T;
declare function notEmpty<T>(arg: T | undefined | null): arg is T;
/**
 * `true` if the argument is an empty object. Otherwise, `false`.
 */
declare function isEmpty(arg: Object): boolean;
declare const each: <T = any, K = string>(obj: any, fn: (value: T, key: K) => void) => void;
declare const values: (obj: any) => any[];
declare const filter: (obj: any, fn: (value: any, key: string) => boolean, dest?: any) => any;
declare const pick: (obj: any, fields: string[], dest?: any) => any;
declare const omit: (obj: any, fields: string[], dest?: any) => any;
declare const reduce: <V = any, R = any>(obj: any, fn: (res: R, value: V, key: string) => any, res?: R) => R;
declare const mapValues: <V = any>(obj: any, fn: (value: V, key: string) => any) => any;
declare const mapKeys: <V = any>(obj: any, fn: (value: V, key: string) => any) => any;
/**
 * @param target
 * @param key
 * @example
 *  const obj = {
 *    position: {
 *      x: 0
 *      y: 0
 *    }
 *  }
 *  getByKey(ob, 'position.x') // 0
 */
declare function getByKey(target: any, key: string): any | undefined;
/**
 * @param target
 * @param key
 * @param newValue
 * @param autoCreateObject
 * @example
 *  const obj = {
 *    position: {
 *      x: 0
 *      y: 0
 *    }
 *  }
 *  setByKey(ob, 'position.x', 100) // true
 *  setByKey(obj, 'size.width', 100) // false
 *  setBeyKey(obj, 'size.width', 100, true) // true
 */
declare function setByKey(target: any, key: string, newValue: any, autoCreateObject?: boolean, clone?: boolean): any;
declare const NOOP: () => void;
/**
 * @param obj The object to inspect.
 * @returns True if the argument appears to be a plain object.
 */
declare function isPlainObject(obj: any): boolean;

interface AsClass<T> {
    new (...args: any[]): T;
}
type UnknownObject<T extends object> = Record<string | number | symbol, unknown> & {
    [K in keyof T]: unknown;
};
declare function isObject<T extends object>(v: unknown): v is UnknownObject<T>;
declare function isString(v: unknown): v is string;
declare function isFunction<T extends (...args: unknown[]) => unknown>(v: unknown): v is T;
declare function getTag(v: unknown): string;
declare function isNumber(v: unknown): v is number;
type MaybeArray<T> = T | T[];
type MaybePromise<T> = T | PromiseLike<T>;
type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer I> ? Array<RecursivePartial<I>> : RecursivePartial<T[P]>;
};

/**
 * An object that performs a cleanup operation when `.dispose()` is called.
 *
 * Some examples of how disposables are used:
 *
 * - An event listener that removes itself when `.dispose()` is called.
 * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.
 */
interface Disposable {
    dispose(): void;
}
declare namespace Disposable {
    function is(thing: any): thing is Disposable;
    function create(func: () => void): Disposable;
    const NULL: Readonly<Disposable>;
}
declare class DisposableImpl implements Disposable {
    readonly toDispose: DisposableCollection;
    dispose(): void;
    get disposed(): boolean;
    get onDispose(): Event<void>;
}
declare class DisposableCollection implements Disposable {
    protected readonly disposables: (Disposable & {
        _origin: Disposable;
    })[];
    protected readonly onDisposeEmitter: Emitter<void>;
    private _disposed;
    constructor(...toDispose: Disposable[]);
    get onDispose(): Event<void>;
    get disposed(): boolean;
    dispose(): void;
    push(disposable: Disposable): Disposable;
    pushAll(disposables: Disposable[]): Disposable[];
}

interface EventListener$1<T> {
    (args: T): void;
}
interface Event<T> {
    (listener: EventListener$1<T>, thisArgs?: any): Disposable;
}
declare namespace Event {
    const None: Event<any>;
}
declare class Emitter<T = any> {
    static LEAK_WARNING_THRESHHOLD: number;
    private _event?;
    private _listeners?;
    private _disposed;
    get event(): Event<T>;
    fire(event: T): void;
    get disposed(): boolean;
    dispose(): void;
}

interface CancellationToken {
    /**
     * A flag signalling is cancellation has been requested.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An event which fires when cancellation is requested. This event
     * only ever fires `once` as cancellation can only happen once. Listeners
     * that are registered after cancellation will be called (next event loop run),
     * but also only once.
     * @event
     */
    readonly onCancellationRequested: Event<void>;
}
declare namespace CancellationToken {
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    const None: Readonly<CancellationToken>;
    const Cancelled: Readonly<CancellationToken>;
}
declare class MutableToken implements CancellationToken {
    private _isCancelled;
    private _emitter?;
    cancel(): void;
    get isCancellationRequested(): boolean;
    get onCancellationRequested(): Event<void>;
    dispose(): void;
}
declare class CancellationTokenSource {
    private _token;
    get token(): CancellationToken;
    cancel(): void;
    dispose(): void;
}
declare function cancelled(): Error;
declare function isCancelled(err: Error | undefined): boolean;
declare function checkCancelled(token?: CancellationToken): void;

/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
declare class PromiseDeferred<T> {
    resolve: (value?: T | PromiseLike<T>) => void;
    reject: (err?: any) => void;
    promise: Promise<T>;
}
declare const Deferred: typeof PromiseDeferred;
/**
 * @returns resolves after a specified number of milliseconds
 * @throws cancelled if a given token is cancelled before a specified number of milliseconds
 */
declare function delay(ms: number, token?: Readonly<CancellationToken>): Promise<void>;
declare function retry<T>(task: () => Promise<T>, delayTime: number, retries: number, shouldRetry?: (res: T) => boolean): Promise<T>;
interface PromiseTask<T> {
    (): Promise<T>;
}
interface PromisePoolOpts {
    intervalCount?: number;
    intervalTime?: number;
    retries?: number;
    retryDelay?: number;
}
declare class PromisePool {
    protected opts: Required<PromisePoolOpts>;
    constructor(opts?: PromisePoolOpts);
    protected tryToExec<T>(task: PromiseTask<T>, checkIfRetry?: (res: T) => boolean): Promise<T>;
    /**
     * @param tasks 执行任务
     * @param checkIfRetry 判断结果是否需要重试
     */
    run<T>(tasks: PromiseTask<T>[], checkIfRetry?: (res: T) => boolean): Promise<T[]>;
}

interface CacheManager<T, ITEM extends CacheOriginItem = CacheOriginItem> extends Disposable {
    get(): T;
    getMore(count: number, autoDelete?: boolean): T[];
    getMoreByItemKeys(item: ITEM[]): T[];
    getMoreByItems(item: ITEM[]): T[];
    /**
     * 从缓存中获取
     * @param key
     */
    getFromCacheByKey(key: string): T | undefined;
    /**
     * 获取所有缓存
     */
    getFromCache(): Cache<T>[];
    /**
     * 清空缓存数据
     */
    clear(): void;
}
interface ShortCache<T> {
    get(fn: () => T): T;
}
interface WeakCache {
    get(key: any): any;
    save(key: any, value: any): void;
    isChanged(key: any, value: any): boolean;
}
interface CacheOpts {
    deleteLimit?: number;
}
interface CacheOriginItem {
    key?: any;
}
type Cache<T> = {
    [P in keyof T]: T[P];
} & {
    dispose?: () => void;
    key?: any;
};
/**
 * 缓存工具：
 *  1. 可延迟按需创建，提升性能
 *  2. 可支持多个或单个，有些动态创建多个的场景可以共享已有的实例，提升性能
 *  3. 自动删除，超过一定的数目会自动做清空回收
 *
 * @example
 *  function htmlFactory<HTMLElement>(): Cache<HTMLElement> {
 *    const el = document.createElement('div')
 *    return Cache.assign(el, { dispose: () => el.remove() })
 *  }
 *  const htmlCache = Cache.create<HTMLElement>(htmlFactory)
 *  console.log(htmlCache.get() === htmlCache.get()) // true
 *  console.log(htmlCache.getMore(3)) // [HTMLElement, HTMLElement, HTMLElement]
 *  console.log(htmlCache.getMore(2)) // [HTMLElement, HTMLElement] 自动删除第三个
 */
declare namespace Cache {
    function create<T, ITEM extends CacheOriginItem = CacheOriginItem>(cacheFactory: (item?: ITEM) => Cache<T>, opts?: CacheOpts): CacheManager<T, ITEM>;
    function assign<T = any>(target: T, fn: Disposable): Cache<T>;
    /**
     * 短存储
     * @param timeout
     */
    function createShortCache<T>(timeout?: number): ShortCache<T>;
    function createWeakCache(): WeakCache;
}

declare namespace Compare {
    /**
     * 比较，默认浅比较
     * @param oldProps
     * @param newProps
     * @param depth - 比较的深度，默认是 1
     * @param partial - 比较对象的局部，默认 true
     */
    function isChanged(oldProps: any, newProps: any, depth?: number, partial?: boolean): boolean;
    /**
     * 深度比较
     * @param oldProps
     * @param newProps
     * @param partial - 比较对象的局部，默认 true
     */
    function isDeepChanged(oldProps: any, newProps: any, partial?: boolean): boolean;
    function isArrayShallowChanged(arr1: any[], arr2: any[]): boolean;
}

type CSSStyle = {
    [P in keyof CSSStyleDeclaration]?: string | number | undefined;
};
interface DOMCache extends HTMLElement, Disposable {
    setStyle(style: CSSStyle): void;
    key?: string | number;
}
declare namespace domUtils {
    function toPixel(num: number): string;
    function fromPercent(percent: string): number;
    function toPercent(percent: number): string;
    function enableEvent(element: HTMLDivElement): void;
    function disableEvent(element: HTMLDivElement): void;
    function createElement<T extends HTMLElement>(ele: string, ...classNames: string[]): T;
    function createDivWithClass(...classNames: string[]): HTMLDivElement;
    function addClass(element: Element, ...classNames: string[]): void;
    function delClass(element: Element, ...classNames: string[]): void;
    function coverClass(element: Element, ...classNames: string[]): void;
    function clearChildren(container: HTMLDivElement): void;
    function translatePercent(node: HTMLDivElement, x: number, y: number): void;
    function translateXPercent(node: HTMLDivElement, x: number): void;
    function translateYPercent(node: HTMLDivElement, y: number): void;
    function setStyle(node: HTMLElement, styles: CSSStyle): void;
    function classNameWithPrefix(prefix: string): (key: string, opts?: any) => string;
    function addStandardDisposableListener(dom: HTMLElement | HTMLDocument, type: string, listener: EventListenerOrEventListenerObject | any, options?: boolean | any): Disposable;
    /**
     * dom 缓存
     * @param parent
     * @param className
     */
    function createDOMCache<T extends DOMCache = DOMCache>(parent: HTMLElement, className: string | (() => HTMLElement), children?: string): CacheManager<T>;
}

type LocalId = number;
declare function generateLocalId(): LocalId;
declare function _setIdx(idx: number): void;

declare function iterToArray<T = any>(iter: IterableIterator<T>): T[];
declare function arrayToSet(arr: any[]): Set<any>;
/**
 * @see https://stackoverflow.com/a/9229821
 *  export function arrayUnion(arr: any[]): any[] {
 *     return [...new Set(arr)]
 *  }
 */
declare function arrayUnion(arr: any[]): any[];

declare function bindContributions(bind: interfaces.Bind, target: any, contribs: any[]): void;

type RequestFn = (...args: any[]) => Promise<any>;
/**
 * 请求缓存
 * @param req
 */
declare const RequestCache: Map<any, Promise<any>>;
declare function clearRequestCache(): void;
declare function requestWithMemo(req: RequestFn, cacheTime?: number, createCacheKey?: (...args: any[]) => any): RequestFn;

type FuncMaybePromise<D> = (d: D, ...others: any[]) => MaybePromise<D>;
type FuncPromise<D> = (d: D, ...others: any[]) => Promise<D>;
type Func<D> = (d: D, ...others: any[]) => D;
declare function composeAsync<D>(...fns: FuncMaybePromise<D>[]): FuncPromise<D>;
declare function compose<D>(...fns: Func<D>[]): Func<D>;

declare const ContributionProvider: unique symbol;
interface ContributionProvider<T extends object> {
    getContributions(): T[];
    forEach(fn: (v: T) => void): void;
}
declare function bindContributionProvider(bind: interfaces.Bind, id: symbol): void;

type EventListener<K extends keyof HTMLElementEventMap> = (this: HTMLElement, event: HTMLElementEventMap[K]) => any;
type EventListenerOrEventListenerObject$1<K extends keyof HTMLElementEventMap> = EventListener<K>;
declare function addEventListener<K extends keyof HTMLElementEventMap>(element: HTMLElement, type: K, listener: EventListenerOrEventListenerObject$1<K>, useCapture?: boolean): Disposable;

declare class Logger {
    isDevEnv(): boolean;
    info(...props: any): void;
    log(...props: any): void;
    error(...props: any): void;
    warn(...props: any): void;
}
declare const logger: Logger;

declare function createStyleElement(styleId: string, container?: HTMLElement): HTMLStyleElement;
declare const DecorationStyle: {
    createStyleElement: typeof createStyleElement;
};

declare function useRefresh(defaultValue?: any): (v?: any) => void;

export { Angle, type AsClass, type CSSStyle, Cache, type CacheManager, type CacheOpts, type CacheOriginItem, CancellationToken, CancellationTokenSource, Circle, Compare, ContributionProvider, CropSchemaDecoration, DEG_TO_RAD, type DOMCache, DecorationStyle, Deferred, Disposable, DisposableCollection, DisposableImpl, Emitter, Event, type EventListener$1 as EventListener, type FlipSchema, FlipSchemaDecoration, type IPoint, type ISize, type LocalId, type MarginSchema, Matrix, type MaybeArray, type MaybePromise, MutableToken, NOOP, OBBRect, type OpacitySchema, OpacitySchemaDecoration, type OriginSchema, OriginSchemaDecoration, PI, PI_2, PaddingSchema, PaddingSchemaDecoration, Point, type PositionSchema, PositionSchemaDecoration, PromiseDeferred, PromisePool, type PromisePoolOpts, type PromiseTask, RAD_TO_DEG, Rectangle, RectangleAlignTitle, RectangleAlignType, type RecursivePartial, RequestCache, type RotationSchema, RotationSchemaDecoration, SHAPES, type ScaleSchema, ScaleSchemaDecoration, Schema, SchemaDecoration, type SchemaType, type ScrollSchema, type ShadowSchema, ShadowSchemaDecoration, type ShortCache, SizeSchema, SizeSchemaDecoration, type SkewSchema, SkewSchemaDecoration, TintSchema, TintSchemaDecoration, Transform, TransformSchema, TransformSchemaDecoration, type WeakCache, _setIdx, addEventListener, arrayToSet, arrayUnion, bindContributionProvider, bindContributions, cancelled, checkCancelled, clearRequestCache, compose, composeAsync, deepFreeze, delay, domUtils, each, filter, generateLocalId, getByKey, getTag, isCancelled, isEmpty, isFunction, isNumber, isObject, isPlainObject, isString, iterToArray, logger, mapKeys, mapValues, notEmpty, omit, pick, reduce, requestWithMemo, retry, setByKey, useRefresh, values };
