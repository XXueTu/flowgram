// src/math/const.ts
var { PI } = Math;
var PI_2 = PI * 2;
var RAD_TO_DEG = 180 / PI;
var DEG_TO_RAD = PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});

// src/math/Vector2.ts
var Vector2 = class _Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  /**
   * 向量减法
   */
  sub(v) {
    return new _Vector2(this.x - v.x, this.y - v.y);
  }
  /**
   * 向量点乘
   */
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  /**
   * 向量叉乘
   */
  // cross(v: Vector2): number {
  // }
};

// src/math/Point.ts
var Point = class _Point {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  /**
   * Creates a clone of this point
   *
   * @return {Point} a copy of the point
   */
  clone() {
    return new _Point(this.x, this.y);
  }
  /**
   * Copies x and y from the given point
   *
   * @param {IPoint} p - The point to copy from
   * @returns {this} Returns itself.
   */
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  /**
   * Copies x and y into the given point
   *
   * @param {IPoint} p - The point to copy.
   * @returns {IPoint} Given point with values updated
   */
  copyTo(p) {
    p.x = this.x;
    p.y = this.y;
    return p;
  }
  /**
   * Returns true if the given point is equal to this point
   *
   * @param {IPoint} p - The point to check
   * @returns {boolean} Whether the given point equal to this point
   */
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   * If y is omitted, both x and y will be set to x.
   *
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns {this} Returns itself.
   */
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
};
((Point2) => {
  Point2.EMPTY = { x: 0, y: 0 };
  function getDistance(p1, p2) {
    return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  }
  Point2.getDistance = getDistance;
  function getMiddlePoint(p1, p2) {
    return getRatioPoint(p1, p2, 0.5);
  }
  Point2.getMiddlePoint = getMiddlePoint;
  function getRatioPoint(p1, p2, ratio) {
    return {
      x: p1.x + ratio * (p2.x - p1.x),
      y: p1.y + ratio * (p2.y - p1.y)
    };
  }
  Point2.getRatioPoint = getRatioPoint;
  function fixZero(output) {
    if (output.x === 0) output.x = 0;
    if (output.y === 0) output.y = 0;
    return output;
  }
  Point2.fixZero = fixZero;
  function move(current, m) {
    return {
      x: current.x + (m.x || 0),
      y: current.y + (m.y || 0)
    };
  }
  Point2.move = move;
  function moveDistanceToDirection(current, direction, distance) {
    const deltaX = direction.x - current.x;
    const deltaY = direction.y - current.y;
    const distanceX = deltaX === 0 ? 0 : Math.sqrt(distance ** 2 / (1 + deltaY ** 2 / deltaX ** 2));
    const moveX = deltaX > 0 ? distanceX : -distanceX;
    const distanceY = deltaX === 0 ? distance : Math.abs(distanceX * deltaY / deltaX);
    const moveY = deltaY > 0 ? distanceY : -distanceY;
    return {
      x: current.x + moveX,
      y: current.y + moveY
    };
  }
  Point2.moveDistanceToDirection = moveDistanceToDirection;
})(Point || (Point = {}));

// src/math/shapes/Rectangle.ts
var Rectangle = class _Rectangle {
  /**
   * @param [x] - The X coordinate of the upper-left corner of the rectangle
   * @param [y] - The Y coordinate of the upper-left corner of the rectangle
   * @param [width] - The overall width of this rectangle
   * @param [height] - The overall height of this rectangle
   */
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     */
    this.type = 1 /* RECT */;
  }
  // static _empty: Rectangle = Object.freeze(new Rectangle(0, 0, 0, 0))
  /**
   * A constant empty rectangle. MUST NOT modify properties!
   */
  static get EMPTY() {
    return new _Rectangle(0, 0, 0, 0);
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Creates a clone of this Rectangle.
   *
   * @return a copy of the rectangle
   */
  clone() {
    return new _Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   *
   * @return Returns itself.
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   *
   * @return Returns given rectangle.
   */
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   *
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @return Whether the x/y coordinates are within this Rectangle
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.right) {
      if (y >= this.y && y <= this.bottom) {
        return true;
      }
    }
    return false;
  }
  isEqual(rect) {
    return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
  }
  containsRectangle(rect) {
    return rect.left >= this.left && rect.right <= this.right && rect.top >= this.top && rect.bottom <= this.bottom;
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   *
   * @param [paddingX] - The horizontal padding amount.
   * @param [paddingY] - The vertical padding amount.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  /**
   * Fits this rectangle around the passed one.
   * Intersection 交集
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   */
  ceil(resolution = 1, precision = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - precision) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - precision) * resolution) / resolution;
    this.x = Math.floor((this.x + precision) * resolution) / resolution;
    this.y = Math.floor((this.y + precision) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  get center() {
    return {
      x: this.x + this.width / 2,
      y: this.y + this.height / 2
    };
  }
  get rightBottom() {
    return {
      x: this.right,
      y: this.bottom
    };
  }
  get leftBottom() {
    return {
      x: this.left,
      y: this.bottom
    };
  }
  get rightTop() {
    return {
      x: this.right,
      y: this.top
    };
  }
  get leftTop() {
    return {
      x: this.left,
      y: this.top
    };
  }
  get bottomCenter() {
    return {
      x: this.x + this.width / 2,
      y: this.bottom
    };
  }
  get topCenter() {
    return {
      x: this.x + this.width / 2,
      y: this.top
    };
  }
  get rightCenter() {
    return {
      x: this.right,
      y: this.y + this.height / 2
    };
  }
  get leftCenter() {
    return {
      x: this.left,
      y: this.y + this.height / 2
    };
  }
  update(fn) {
    return fn(this);
  }
  get crossDistance() {
    return Point.getDistance(this.leftTop, this.rightBottom);
  }
  toStyleStr() {
    return `left: ${this.x}px; top: ${this.y}px; width: ${this.width}px; height: ${this.height}px;`;
  }
  withPadding(padding) {
    this.x -= padding.left;
    this.y -= padding.top;
    this.width += padding.left + padding.right;
    this.height += padding.top + padding.bottom;
    return this;
  }
  withoutPadding(padding) {
    this.x += padding.left;
    this.y += padding.top;
    this.width = this.width - padding.left - padding.right;
    this.height = this.height - padding.top - padding.bottom;
    return this;
  }
  withHeight(height) {
    this.height = height;
    return this;
  }
  clearSpace() {
    this.width = 0;
    this.height = 0;
    return this;
  }
};
var RectangleAlignType = /* @__PURE__ */ ((RectangleAlignType2) => {
  RectangleAlignType2["ALIGN_LEFT"] = "align-left";
  RectangleAlignType2["ALIGN_CENTER"] = "align-center";
  RectangleAlignType2["ALIGN_RIGHT"] = "align-right";
  RectangleAlignType2["ALIGN_TOP"] = "align-top";
  RectangleAlignType2["ALIGN_MIDDLE"] = "align-middle";
  RectangleAlignType2["ALIGN_BOTTOM"] = "align-bottom";
  RectangleAlignType2["DISTRIBUTE_HORIZONTAL"] = "distribute-horizontal";
  RectangleAlignType2["DISTRIBUTE_VERTICAL"] = "distribute-vertical";
  return RectangleAlignType2;
})(RectangleAlignType || {});
var RectangleAlignTitle = /* @__PURE__ */ ((RectangleAlignTitle2) => {
  RectangleAlignTitle2["ALIGN_LEFT"] = "\u5DE6\u5BF9\u9F50";
  RectangleAlignTitle2["ALIGN_CENTER"] = "\u5DE6\u53F3\u5C45\u4E2D\u5BF9\u9F50";
  RectangleAlignTitle2["ALIGN_RIGHT"] = "\u53F3\u5BF9\u9F50";
  RectangleAlignTitle2["ALIGN_TOP"] = "\u4E0A\u5BF9\u9F50";
  RectangleAlignTitle2["ALIGN_MIDDLE"] = "\u4E0A\u4E0B\u5C45\u4E2D\u5BF9\u9F50";
  RectangleAlignTitle2["ALIGN_BOTTOM"] = "\u4E0B\u5BF9\u9F50";
  RectangleAlignTitle2["DISTRIBUTE_HORIZONTAL"] = "\u6C34\u5E73\u5E73\u5747\u5206\u5E03";
  RectangleAlignTitle2["DISTRIBUTE_VERTICAL"] = "\u5782\u76F4\u5E73\u5747\u5206\u5E03";
  return RectangleAlignTitle2;
})(RectangleAlignTitle || {});
((Rectangle2) => {
  function align(rectangles, type) {
    if (rectangles.length <= 1) return rectangles;
    switch (type) {
      /**
       * 下对齐
       */
      case "align-bottom" /* ALIGN_BOTTOM */:
        const maxBottom = Math.max(...rectangles.map((r) => r.bottom));
        rectangles.forEach((rect) => {
          rect.y = maxBottom - rect.height;
        });
        break;
      /**
       * 左右居中对齐
       */
      case "align-center" /* ALIGN_CENTER */:
        const centerX = enlarge(rectangles).center.x;
        rectangles.forEach((rect) => {
          rect.x = centerX - rect.width / 2;
        });
        break;
      /**
       * 左对齐
       */
      case "align-left" /* ALIGN_LEFT */:
        const minLeft = Math.min(...rectangles.map((r) => r.left));
        rectangles.forEach((rect) => {
          rect.x = minLeft;
        });
        break;
      /**
       * 上下居中对齐
       */
      case "align-middle" /* ALIGN_MIDDLE */:
        const centerY = enlarge(rectangles).center.y;
        rectangles.forEach((rect) => {
          rect.y = centerY - rect.height / 2;
        });
        break;
      /**
       * 右对齐
       */
      case "align-right" /* ALIGN_RIGHT */:
        const maxRight = Math.max(...rectangles.map((r) => r.right));
        rectangles.forEach((rect) => {
          rect.x = maxRight - rect.width;
        });
        break;
      /**
       * 上对齐
       */
      case "align-top" /* ALIGN_TOP */:
        const minTop = Math.min(...rectangles.map((r) => r.top));
        rectangles.forEach((rect) => {
          rect.y = minTop;
        });
        break;
      /**
       * 水平平均分布
       */
      case "distribute-horizontal" /* DISTRIBUTE_HORIZONTAL */:
        if (rectangles.length <= 2) break;
        const sort = rectangles.slice().sort((r1, r2) => r1.left - r2.left);
        const bounds = enlarge(rectangles);
        const space = rectangles.reduce((s, rect) => s - rect.width, bounds.width) / (rectangles.length - 1);
        sort.reduce((left, rect) => {
          rect.x = left;
          return left + rect.width + space;
        }, bounds.x);
        break;
      /**
       * 垂直平均分布
       */
      case "distribute-vertical" /* DISTRIBUTE_VERTICAL */:
        if (rectangles.length <= 2) break;
        const sort2 = rectangles.slice().sort((r1, r2) => r1.top - r2.top);
        const bounds2 = enlarge(rectangles);
        const space2 = rectangles.reduce((s, rect) => s - rect.height, bounds2.height) / (rectangles.length - 1);
        sort2.reduce((top, rect) => {
          rect.y = top;
          return top + rect.height + space2;
        }, bounds2.y);
        break;
      default:
        break;
    }
    return rectangles;
  }
  Rectangle2.align = align;
  function enlarge(rectangles) {
    const result = Rectangle2.EMPTY.clone();
    if (!rectangles.length) return result;
    const lefts = [];
    const tops = [];
    const rights = [];
    const bottoms = [];
    rectangles.forEach((r) => {
      lefts.push(r.left);
      rights.push(r.right);
      bottoms.push(r.bottom);
      tops.push(r.top);
    });
    const left = Math.min.apply(Math, lefts);
    const right = Math.max.apply(Math, rights);
    const top = Math.min.apply(Math, tops);
    const bottom = Math.max.apply(Math, bottoms);
    result.x = left;
    result.width = right - left;
    result.y = top;
    result.height = bottom - top;
    return result;
  }
  Rectangle2.enlarge = enlarge;
  function intersects(target1, target2, direction) {
    const left1 = target1.left;
    const top1 = target1.top;
    const right1 = target1.right;
    const bottom1 = target1.bottom;
    const left2 = target2.left;
    const top2 = target2.top;
    const right2 = target2.right;
    const bottom2 = target2.bottom;
    if (direction === "horizontal") return right1 > left2 && left1 < right2;
    if (direction === "vertical") return bottom1 > top2 && top1 < bottom2;
    if (right1 > left2 && left1 < right2) {
      if (bottom1 > top2 && top1 < bottom2) {
        return true;
      }
    }
    return false;
  }
  Rectangle2.intersects = intersects;
  function intersectsWithRotation(rect1, rotate1, rect2, rotate2) {
    const obb1 = new OBBRect(rect1.center, rect1.width, rect1.height, rotate1);
    const obb2 = new OBBRect(rect2.center, rect2.width, rect2.height, rotate2);
    const nv = obb1.centerPoint.sub(obb2.centerPoint);
    const axisA1 = obb1.axesX;
    if (obb1.getProjectionRadius(axisA1) + obb2.getProjectionRadius(axisA1) <= Math.abs(nv.dot(axisA1)))
      return false;
    const axisA2 = obb1.axesY;
    if (obb1.getProjectionRadius(axisA2) + obb2.getProjectionRadius(axisA2) <= Math.abs(nv.dot(axisA2)))
      return false;
    const axisB1 = obb2.axesX;
    if (obb1.getProjectionRadius(axisB1) + obb2.getProjectionRadius(axisB1) <= Math.abs(nv.dot(axisB1)))
      return false;
    const axisB2 = obb2.axesY;
    if (obb1.getProjectionRadius(axisB2) + obb2.getProjectionRadius(axisB2) <= Math.abs(nv.dot(axisB2)))
      return false;
    return true;
  }
  Rectangle2.intersectsWithRotation = intersectsWithRotation;
  function isViewportVisible(rect, viewport, rotation = 0, isContains = false) {
    if (isContains) {
      return viewport.containsRectangle(rect);
    }
    if (rotation === 0) return Rectangle2.intersects(rect, viewport);
    return Rectangle2.intersectsWithRotation(rect, rotation, viewport, 0);
  }
  Rectangle2.isViewportVisible = isViewportVisible;
  function setViewportVisible(bounds, viewport, padding = 0) {
    const { left: tLeft, right: tRight, top: tTop, bottom: tBottom, width, height } = bounds;
    const { left: vLeft, right: vRight, top: vTop, bottom: vBottom } = viewport;
    if (tLeft <= vLeft) {
      bounds.x = vLeft + padding;
    } else if (tRight >= vRight) {
      bounds.x = vRight - padding - width;
    }
    if (tTop <= vTop) {
      bounds.y = vTop + padding;
    } else if (tBottom >= vBottom) {
      bounds.y = vBottom - padding - height;
    }
    return bounds;
  }
  Rectangle2.setViewportVisible = setViewportVisible;
  function createRectangleWithTwoPoints(point1, point2) {
    const x = point1.x < point2.x ? point1.x : point2.x;
    const y = point1.y < point2.y ? point1.y : point2.y;
    const width = Math.abs(point1.x - point2.x);
    const height = Math.abs(point1.y - point2.y);
    return new Rectangle2(x, y, width, height);
  }
  Rectangle2.createRectangleWithTwoPoints = createRectangleWithTwoPoints;
})(Rectangle || (Rectangle = {}));
var OBBRect = class {
  /**
   * @param rotation in radian
   */
  constructor(centerPoint, width, height, rotation) {
    this.width = width;
    this.height = height;
    this.centerPoint = new Vector2(centerPoint.x, centerPoint.y);
    this.axesX = new Vector2(Math.cos(rotation), Math.sin(rotation));
    this.axesY = new Vector2(-1 * this.axesX.y, this.axesX.x);
  }
  /**
   * 计算投影半径
   */
  getProjectionRadius(axis) {
    return this.width / 2 * Math.abs(axis.dot(this.axesX)) + this.height / 2 * Math.abs(axis.dot(this.axesY));
  }
};

// src/math/shapes/Circle.ts
var Circle = class _Circle {
  /**
   * @param x Circle center x
   * @param y Circle center y
   */
  constructor(x = 0, y = 0, radius = 0) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     */
    this.type = 2 /* CIRC */;
  }
  /**
   * Creates a clone of this Circle instance
   *
   * @return a copy of the Circle
   */
  clone() {
    return new _Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   *
   * @return Whether the (x, y) coordinates are within this Circle
   */
  contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   *
   * @return the framing rectangle
   */
  getBounds() {
    return new Rectangle(
      this.x - this.radius,
      this.y - this.radius,
      this.radius * 2,
      this.radius * 2
    );
  }
};

// src/math/Matrix.ts
var Matrix = class _Matrix {
  /**
   * @param [a] x scale
   * @param [b] x skew
   * @param [c] y skew
   * @param [d] y scale
   * @param [tx] x translation
   * @param [ty] y translation
   */
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    this.array = null;
  }
  /**
   * A default (identity) matrix
   */
  static get IDENTITY() {
    return new _Matrix();
  }
  /**
   * A temp matrix
   */
  static get TEMP_MATRIX() {
    return new _Matrix();
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * @param array The array that the matrix will be populated from.
   */
  fromArray(array) {
    if (array.length < 6) return this;
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
    return this;
  }
  /**
   * sets the matrix properties
   *
   * @param a Matrix component
   * @param b Matrix component
   * @param c Matrix component
   * @param d Matrix component
   * @param tx Matrix component
   * @param ty Matrix component
   */
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * @param transpose Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] If provided the array will be assigned to out
   * @return the newly created array which contains the matrix
   */
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   *
   * @param pos The origin
   * @param [newPos] The point that the new position is assigned to (allowed to be same as input)
   * @return The new point, transformed through this matrix
   */
  apply(pos, newPos) {
    newPos = newPos || { x: 0, y: 0 };
    const { x, y } = pos;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   *
   * @param pos The origin
   * @param [newPos] The point that the new position is assigned to (allowed to be same as input)
   * @return The new point, inverse-transformed through this matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || { x: 0, y: 0 };
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const { x } = pos;
    const { y } = pos;
    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  /**
   * Translates the matrix on the x and y.
   *
   * @param x How much to translate x by
   * @param y How much to translate y by
   */
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  /**
   * Applies a scale transformation to the matrix.
   *
   * @param x The amount to scale horizontally
   * @param y The amount to scale vertically
   */
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * @param angle The angle in radians.
   */
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  /**
   * 矩阵乘法，当前矩阵 * matrix
   * Appends the given Matrix to this Matrix.
   */
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  /**
   * Sets the matrix based on all the available properties
   *
   * @param x Position on the x axis
   * @param y Position on the y axis
   * @param pivotX Pivot on the x axis
   * @param pivotY Pivot on the y axis
   * @param scaleX Scale on the x axis
   * @param scaleY Scale on the y axis
   * @param rotation Rotation in radians
   * @param skewX Skew on the x axis
   * @param skewY Skew on the y axis
   */
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  /**
   * 矩阵乘法，matrix * 当前矩阵
   * Prepends the given Matrix to this Matrix.
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   *
   * @param transform The transform to apply the properties to.
   * @return The transform with the newly applied properties
   */
  decompose(transform) {
    const { a } = this;
    const { b } = this;
    const { c } = this;
    const { d } = this;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = 0;
      transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx;
    transform.position.y = this.ty;
    return transform;
  }
  /**
   * Inverts this matrix
   */
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   */
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  /**
   * 未做旋转的矩阵
   */
  isSimple() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   *
   * @return A copy of this matrix.
   */
  clone() {
    const matrix = new _Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   *
   * @return The matrix given in parameter with its values updated.
   */
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   */
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
};

// src/math/ObservablePoint.ts
var ObservablePoint = class _ObservablePoint {
  /**
   * @param {Function} cb - callback when changed
   * @param {object} scope - owner of callback
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(cb, scope, x = 0, y = 0) {
    this._x = x;
    this._y = y;
    this.cb = cb;
    this.scope = scope;
  }
  /**
   * The position of the displayObject on the x axis relative to the local coordinates of the parent.
   */
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  /**
   * The position of the displayObject on the x axis relative to the local coordinates of the parent.
   */
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
  /**
   * Creates a clone of this point.
   * The callback and scope params can be overidden otherwise they will default
   * to the clone object's values.
   *
   * @override
   * @param {Function} [cb=null] - callback when changed
   * @param {object} [scope=null] - owner of callback
   * @return {ObservablePoint} a copy of the point
   */
  clone(cb = this.cb, scope = this.scope) {
    return new _ObservablePoint(cb, scope, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   * If y is omitted, both x and y will be set to x.
   *
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns {this} Returns itself.
   */
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this.cb.call(this.scope);
    }
    return this;
  }
  /**
   * Copies x and y from the given point
   *
   * @param {IPoint} p - The point to copy from.
   * @returns {this} Returns itself.
   */
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  /**
   * Copies x and y into the given point
   *
   * @param {IPoint} p - The point to copy.
   * @returns {IPoint} Given point with values updated
   */
  copyTo(p) {
    p.x = this._x;
    p.y = this._y;
    return p;
  }
  /**
   * Returns true if the given point is equal to this point
   *
   * @param {IPoint} p - The point to check
   * @returns {boolean} Whether the given point equal to this point
   */
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
};

// src/math/Transform.ts
var _Transform = class _Transform {
  constructor() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  /**
   * Called when a value changes.
   *
   * @protected
   */
  onChange() {
    this._localID++;
  }
  /**
   * Called when the skew or the rotation changes.
   *
   * @protected
   */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  /**
   * Updates the local transformation matrix.
   */
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  /**
   * Updates the local and the world transformation matrices.
   *
   * @param {PIXI.Transform} parentTransform - The parent transform
   */
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   *
   * @param {PIXI.Matrix} matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  /**
   * The rotation of the object in radians.
   *
   * @member {number}
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
/**
 * A default (identity) transform
 *
 * @static
 * @constant
 * @member {PIXI.Transform}
 */
_Transform.IDENTITY = new _Transform();
var Transform = _Transform;

// src/math/wrap.ts
function wrap(value, min, max) {
  const range = max - min;
  return min + ((value - min) % range + range) % range;
}

// src/math/angle.ts
var Angle;
((Angle2) => {
  function wrap2(angle) {
    return wrap(angle, -Math.PI, Math.PI);
  }
  Angle2.wrap = wrap2;
  function wrapDegrees(angle) {
    return wrap(angle, -180, 180);
  }
  Angle2.wrapDegrees = wrapDegrees;
  function betweenPoints(point1, point2, originPoint = { x: 0, y: 0 }) {
    const p1 = {
      x: point1.x - originPoint.x,
      y: point1.y - originPoint.y
    };
    const p2 = {
      x: point2.x - originPoint.x,
      y: point2.y - originPoint.y
    };
    return Math.atan2(p1.x * p2.y - p1.y * p2.x, p1.x * p2.x + p1.y * p2.y);
  }
  Angle2.betweenPoints = betweenPoints;
})(Angle || (Angle = {}));

// src/objects.ts
var { keys } = Object;
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    const objectToFreeze = stack.shift();
    Object.freeze(objectToFreeze);
    for (const key in objectToFreeze) {
      if (_hasOwnProperty.call(objectToFreeze, key)) {
        const prop = objectToFreeze[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function notEmpty(arg) {
  return arg !== void 0 && arg !== null;
}
function isEmpty(arg) {
  return keys(arg).length === 0 && arg.constructor === Object;
}
var each = (obj, fn) => keys(obj).forEach((key) => fn(obj[key], key));
var values = (obj) => Object.values ? Object.values(obj) : keys(obj).map((k) => obj[k]);
var filter = (obj, fn, dest) => keys(obj).reduce(
  (output, key) => fn(obj[key], key) ? Object.assign(output, { [key]: obj[key] }) : output,
  dest || {}
);
var pick = (obj, fields, dest) => filter(obj, (n, k) => fields.indexOf(k) !== -1, dest);
var omit = (obj, fields, dest) => filter(obj, (n, k) => fields.indexOf(k) === -1, dest);
var reduce = (obj, fn, res = {}) => keys(obj).reduce((r, k) => fn(r, obj[k], k), res);
var mapValues = (obj, fn) => reduce(obj, (res, value, key) => Object.assign(res, { [key]: fn(value, key) }));
var mapKeys = (obj, fn) => reduce(obj, (res, value, key) => Object.assign(res, { [fn(value, key)]: value }));
function getByKey(target, key) {
  if (typeof target !== "object" || !key) return void 0;
  return key.split(".").reduce((v, k) => {
    if (typeof v !== "object") return void 0;
    return v[k];
  }, target);
}
function setByKey(target, key, newValue, autoCreateObject = true, clone = false) {
  if (typeof target !== "object" || !key) return target;
  if (clone) {
    target = { ...target };
  }
  const originTarget = target;
  const targetKeys = key.split(".");
  while (targetKeys.length > 0) {
    key = targetKeys.shift();
    if (targetKeys.length === 0) {
      target[key] = newValue;
      return originTarget;
    }
    if (typeof target[key] !== "object") {
      if (!autoCreateObject) return originTarget;
      target[key] = {};
    }
    if (clone) {
      if (Array.isArray(target[key])) {
        target[key] = target[key].slice();
      } else {
        target[key] = { ...target[key] };
      }
    }
    target = target[key];
  }
  return originTarget;
}
var NOOP = () => {
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}

// src/types.ts
function isObject(v) {
  return typeof v === "object" && v !== null;
}
function isString(v) {
  return typeof v === "string" || v instanceof String;
}
function isFunction(v) {
  return typeof v === "function";
}
var toString = Object.prototype.toString;
function getTag(v) {
  if (v == null) {
    return v === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return toString.call(v);
}
function isNumber(v) {
  return typeof v === "number" || isObject(v) && getTag(v) === "[object Number]";
}

// src/event.ts
var DisposableNULL = Object.freeze({ dispose: NOOP });
var Event;
((Event2) => {
  Event2.None = () => DisposableNULL;
})(Event || (Event = {}));
var _Emitter = class _Emitter {
  constructor() {
    this._disposed = false;
  }
  get event() {
    if (!this._event) {
      this._event = (listener, thisArgs) => {
        if (this._disposed) {
          return DisposableNULL;
        }
        if (!this._listeners) {
          this._listeners = [];
        }
        const finalListener = thisArgs ? listener.bind(thisArgs) : listener;
        if (this._listeners.length >= _Emitter.LEAK_WARNING_THRESHHOLD) {
          console.warn(`[Emitter] Listeners length >= ${_Emitter.LEAK_WARNING_THRESHHOLD}`);
        }
        this._listeners.push(finalListener);
        const eventDisposable = {
          dispose: () => {
            eventDisposable.dispose = NOOP;
            if (!this._disposed) {
              const index = this._listeners.indexOf(finalListener);
              if (index !== -1) {
                this._listeners.splice(index, 1);
              }
            }
          }
        };
        return eventDisposable;
      };
    }
    return this._event;
  }
  fire(event) {
    if (this._listeners) {
      this._listeners.forEach((listener) => listener(event));
    }
  }
  get disposed() {
    return this._disposed;
  }
  dispose() {
    if (this._listeners) {
      this._listeners = void 0;
    }
    this._disposed = true;
  }
};
_Emitter.LEAK_WARNING_THRESHHOLD = 175;
var Emitter = _Emitter;

// src/disposable.ts
var Disposable;
((Disposable2) => {
  function is(thing) {
    return typeof thing === "object" && thing !== null && typeof thing.dispose === "function";
  }
  Disposable2.is = is;
  function create(func) {
    return {
      dispose: func
    };
  }
  Disposable2.create = create;
  Disposable2.NULL = Object.freeze(create(() => {
  }));
})(Disposable || (Disposable = {}));
var DisposableImpl = class {
  constructor() {
    this.toDispose = new DisposableCollection();
  }
  dispose() {
    this.toDispose.dispose();
  }
  get disposed() {
    return this.toDispose.disposed;
  }
  get onDispose() {
    return this.toDispose.onDispose;
  }
};
var DisposableCollection = class {
  constructor(...toDispose) {
    this.disposables = [];
    this.onDisposeEmitter = new Emitter();
    this._disposed = false;
    toDispose.forEach((d) => this.push(d));
  }
  get onDispose() {
    return this.onDisposeEmitter.event;
  }
  get disposed() {
    return this._disposed;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    this._disposed = true;
    this.disposables.slice().reverse().forEach((disposable) => {
      try {
        disposable.dispose();
      } catch (e) {
        console.error(e);
      }
    });
    this.onDisposeEmitter.fire(void 0);
    this.onDisposeEmitter.dispose();
  }
  push(disposable) {
    if (this.disposed) return Disposable.NULL;
    const { disposables } = this;
    if (disposables.find((d) => d._origin === disposable)) {
      return Disposable.NULL;
    }
    let disposableWrap;
    const toRemove = Disposable.create(() => {
      const index = disposables.indexOf(disposableWrap);
      if (index !== -1) {
        disposables.splice(index, 1);
      }
    });
    disposableWrap = {
      dispose: () => {
        toRemove.dispose();
        disposable.dispose();
      },
      _origin: disposable
    };
    disposables.push(disposableWrap);
    return toRemove;
  }
  pushAll(disposables) {
    return disposables.map((disposable) => this.push(disposable));
  }
};

// src/cancellation.ts
var shortcutEvent = Object.freeze(function(callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return {
    dispose() {
      clearTimeout(handle);
    }
  };
});
var CancellationToken;
((CancellationToken2) => {
  function isCancellationToken(thing) {
    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
      return true;
    }
    if (thing instanceof MutableToken) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
  }
  CancellationToken2.isCancellationToken = isCancellationToken;
  CancellationToken2.None = Object.freeze({
    isCancellationRequested: false,
    onCancellationRequested: Event.None
  });
  CancellationToken2.Cancelled = Object.freeze({
    isCancellationRequested: true,
    onCancellationRequested: shortcutEvent
  });
})(CancellationToken || (CancellationToken = {}));
var MutableToken = class {
  constructor() {
    this._isCancelled = false;
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(void 0);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }
    if (!this._emitter) {
      this._emitter = new Emitter();
    }
    return this._emitter.event;
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = void 0;
    }
  }
};
var CancellationTokenSource = class {
  get token() {
    if (!this._token) {
      this._token = new MutableToken();
    }
    return this._token;
  }
  cancel() {
    if (!this._token) {
      this._token = CancellationToken.Cancelled;
    } else if (this._token !== CancellationToken.Cancelled) {
      this._token.cancel();
    }
  }
  dispose() {
    this.cancel();
  }
};
var cancelledMessage = "Cancelled";
function cancelled() {
  return new Error(cancelledMessage);
}
function isCancelled(err) {
  return !!err && err.message === cancelledMessage;
}
function checkCancelled(token) {
  if (!!token && token.isCancellationRequested) {
    throw cancelled();
  }
}

// src/promise-util.ts
var PromiseDeferred = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
var Deferred = PromiseDeferred;
function delay(ms, token = CancellationToken.None) {
  const deferred = new PromiseDeferred();
  const handle = setTimeout(() => deferred.resolve(), ms);
  token.onCancellationRequested(() => {
    clearTimeout(handle);
    deferred.reject(cancelled());
  });
  return deferred.promise;
}
async function retry(task, delayTime, retries, shouldRetry) {
  let lastError;
  let result;
  for (let i = 0; i < retries; i++) {
    try {
      result = await task();
      if (shouldRetry && shouldRetry(result)) {
        await delay(delayTime);
        continue;
      }
      return result;
    } catch (error) {
      lastError = error;
      await delay(delayTime);
    }
  }
  if (lastError) {
    throw lastError;
  }
  return result;
}
var PromisePoolOptsDefault = {
  intervalCount: 10,
  // 每批数目
  intervalTime: 0,
  retries: 0,
  retryDelay: 10
};
var PromisePool = class {
  constructor(opts = PromisePoolOptsDefault) {
    this.opts = { ...PromisePoolOptsDefault, ...opts };
  }
  async tryToExec(task, checkIfRetry) {
    if (this.opts.retries === 0) return task();
    return retry(task, this.opts.retryDelay, this.opts.retries, checkIfRetry);
  }
  /**
   * @param tasks 执行任务
   * @param checkIfRetry 判断结果是否需要重试
   */
  async run(tasks, checkIfRetry) {
    if (tasks.length === 0) return [];
    const curTasks = tasks.slice(0, this.opts.intervalCount);
    const promises = curTasks.map((task) => this.tryToExec(task, checkIfRetry));
    const result = await Promise.all(promises);
    const nextTasks = tasks.slice(this.opts.intervalCount);
    if (nextTasks.length === 0) return result;
    if (this.opts.intervalTime !== 0) await delay(this.opts.intervalTime);
    return result.concat(await this.run(nextTasks, checkIfRetry));
  }
};

// src/compare.ts
var Compare;
((Compare2) => {
  function isChanged(oldProps, newProps, depth = 1, partial = true) {
    if (oldProps === newProps) return false;
    if (depth === 0 || typeof oldProps !== "object" || typeof newProps !== "object") {
      return oldProps !== newProps;
    }
    const keys2 = Object.keys(newProps);
    if (!partial) {
      const oldKeys = Object.keys(oldProps);
      if (keys2.length !== oldKeys.length) return true;
    }
    for (let i = 0, len = keys2.length; i < len; i++) {
      const key = keys2[i];
      if (isChanged(oldProps[key], newProps[key], depth - 1, partial)) return true;
    }
    return false;
  }
  Compare2.isChanged = isChanged;
  function isDeepChanged(oldProps, newProps, partial) {
    return isChanged(oldProps, newProps, Infinity, partial);
  }
  Compare2.isDeepChanged = isDeepChanged;
  function isArrayShallowChanged(arr1, arr2) {
    if (arr1.length !== arr2.length) return true;
    for (let i = 0, len = arr1.length; i < len; i++) {
      if (arr1[i] !== arr2[i]) {
        return true;
      }
    }
    return false;
  }
  Compare2.isArrayShallowChanged = isArrayShallowChanged;
})(Compare || (Compare = {}));

// src/cache.ts
var Cache;
((Cache2) => {
  function create(cacheFactory, opts = {}) {
    let cache = [];
    return {
      getFromCache() {
        return cache;
      },
      getMore(count, autoDelete = true) {
        if (count === cache.length) {
        } else if (count > cache.length) {
          let added = count - cache.length;
          while (added > 0) {
            cache.push(cacheFactory());
            added--;
          }
        } else if (autoDelete) {
          const deleteLimit = opts.deleteLimit ?? 0;
          if (cache.length - count > deleteLimit) {
            const deleted = cache.splice(count);
            deleted.forEach((el) => el.dispose && el.dispose());
          }
        }
        return cache.slice(0, count);
      },
      /**
       * 通过 key 去创建缓存
       * @param items
       */
      getMoreByItemKeys(items) {
        const newCache = [];
        const findedMap = /* @__PURE__ */ new Map();
        cache.forEach((item) => {
          const finded = items.find((i) => i.key === item.key);
          if (finded) {
            findedMap.set(item.key, item);
          } else {
            item.dispose?.();
          }
        });
        items.forEach((item) => {
          if (!item.key) throw new Error("getMoreByItemKeys need a key");
          const finded = findedMap.get(item.key);
          if (finded) {
            newCache.push(finded);
          } else {
            newCache.push(cacheFactory(item));
          }
        });
        cache = newCache;
        return cache;
      },
      /**
       * 通过 item 引用取拿缓存数据
       */
      getMoreByItems(items) {
        const newCache = [];
        const findedMap = /* @__PURE__ */ new Map();
        cache.forEach((cacheItem) => {
          const finded = items.find((ref) => ref === cacheItem.key);
          if (finded) {
            findedMap.set(cacheItem.key, cacheItem);
          } else {
            cacheItem.dispose?.();
          }
        });
        items.forEach((item) => {
          const finded = findedMap.get(item);
          if (finded) {
            newCache.push(finded);
          } else {
            newCache.push({
              ...cacheFactory(item),
              key: item
            });
          }
        });
        cache = newCache;
        return cache;
      },
      get() {
        if (cache.length > 0) return cache[0];
        cache.push(cacheFactory());
        return cache[0];
      },
      getFromCacheByKey(key) {
        return cache.find((item) => item.key === key);
      },
      dispose() {
        cache.forEach((item) => item.dispose && item.dispose());
        cache.length = 0;
      },
      clear() {
        this.dispose();
      }
    };
  }
  Cache2.create = create;
  function assign(target, fn) {
    return Object.assign(target, fn);
  }
  Cache2.assign = assign;
  function createShortCache(timeout = 1e3) {
    let cache;
    let timeoutId;
    function updateTimeout() {
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        cache = void 0;
      }, timeout);
    }
    return {
      get(getValue) {
        if (cache) {
          updateTimeout();
          return cache;
        }
        cache = getValue();
        updateTimeout();
        return cache;
      }
    };
  }
  Cache2.createShortCache = createShortCache;
  function createWeakCache() {
    const weakCache = /* @__PURE__ */ new WeakMap();
    return {
      get: (key) => weakCache.get(key),
      save: (key, value) => weakCache.set(key, value),
      isChanged: (key, value) => Compare.isChanged(weakCache.get(key), value)
    };
  }
  Cache2.createWeakCache = createWeakCache;
})(Cache || (Cache = {}));

// src/schema/schema.ts
var SchemaDecoration;
((SchemaDecoration2) => {
  function create(properties, baseDecoration, mixinDefaults) {
    return {
      type: "object",
      properties: {
        ...baseDecoration?.properties,
        ...properties
      },
      mixinDefaults: {
        ...baseDecoration?.mixinDefaults,
        ...mixinDefaults
      }
    };
  }
  SchemaDecoration2.create = create;
})(SchemaDecoration || (SchemaDecoration = {}));
var Schema;
((Schema2) => {
  function createDefault(decoration, mixinDefaults, _key) {
    mixinDefaults = { ...decoration.mixinDefaults, ...mixinDefaults };
    const prefixKey = _key ? `${_key}.` : "";
    if (decoration.properties) {
      return mapValues(decoration.properties, (v, k) => {
        const childKey = prefixKey + k;
        if (mixinDefaults && mixinDefaults[childKey] !== void 0) {
          return mixinDefaults[childKey];
        }
        return createDefault(v, mixinDefaults, childKey);
      });
    }
    return typeof decoration.default === "function" ? decoration.default() : decoration.default;
  }
  Schema2.createDefault = createDefault;
  function isBaseType(decoration) {
    return decoration.type === "string" || decoration.type === "float" || decoration.type === "integer" || decoration.type === "boolean" || decoration.type === "enum" || decoration.type === "color" || decoration.type === "range";
  }
  Schema2.isBaseType = isBaseType;
})(Schema || (Schema = {}));

// src/schema/schema-transform.ts
var SizeSchemaDecoration = {
  label: "\u5927\u5C0F",
  properties: {
    width: { label: "\u5BBD", default: 0, type: "float" },
    height: { label: "\u9AD8", default: 0, type: "float" },
    locked: { label: "\u7B49\u6BD4\u9501", default: false, type: "boolean" }
  },
  type: "object"
};
var OriginSchemaDecoration = {
  label: "\u539F\u70B9",
  description: "\u7528\u4E8E\u8BBE\u7F6E\u65CB\u8F6C\u7684\u4E2D\u5FC3\u4F4D\u7F6E",
  properties: {
    x: { label: "x", default: 0.5, type: "float" },
    y: { label: "y", default: 0.5, type: "float" }
  },
  type: "object"
};
var PositionSchemaDecoration = {
  label: "\u4F4D\u7F6E",
  properties: {
    x: { label: "x", default: 0, type: "float" },
    y: { label: "y", default: 0, type: "float" }
  },
  type: "object"
};
var RotationSchemaDecoration = {
  label: "\u65CB\u8F6C",
  type: "float",
  default: 0
};
var ScaleSchemaDecoration = {
  label: "\u7F29\u653E",
  properties: {
    x: { label: "x", default: 1, type: "float" },
    y: { label: "y", default: 1, type: "float" }
  },
  type: "object"
};
var SkewSchemaDecoration = {
  label: "\u503E\u659C",
  properties: {
    x: { label: "x", default: 0, type: "float" },
    y: { label: "y", default: 0, type: "float" }
  },
  type: "object"
};
var TransformSchemaDecoration = {
  properties: {
    position: PositionSchemaDecoration,
    size: SizeSchemaDecoration,
    origin: OriginSchemaDecoration,
    scale: ScaleSchemaDecoration,
    skew: SkewSchemaDecoration,
    rotation: RotationSchemaDecoration
  },
  type: "object"
};
var TransformSchema;
((TransformSchema2) => {
  function createDefault() {
    return Schema.createDefault(TransformSchemaDecoration);
  }
  TransformSchema2.createDefault = createDefault;
  function toJSON(obj) {
    return {
      position: { x: obj.position.x, y: obj.position.y },
      size: {
        width: obj.size.width,
        height: obj.size.height,
        locked: obj.size.locked
      },
      origin: { x: obj.origin.x, y: obj.origin.y },
      scale: { x: obj.scale.x, y: obj.scale.y },
      skew: { x: obj.skew.x, y: obj.skew.y },
      rotation: obj.rotation
    };
  }
  TransformSchema2.toJSON = toJSON;
  function getDelta(oldTransform, newTransform) {
    return {
      position: {
        x: newTransform.position.x - oldTransform.position.x,
        y: newTransform.position.y - oldTransform.position.y
      },
      size: {
        width: newTransform.size.width - oldTransform.size.width,
        height: newTransform.size.height - oldTransform.size.height
      },
      origin: {
        x: newTransform.origin.x - oldTransform.origin.x,
        y: newTransform.origin.y - oldTransform.origin.y
      },
      scale: {
        x: newTransform.scale.x - oldTransform.scale.x,
        y: newTransform.scale.y - oldTransform.scale.y
      },
      skew: {
        x: newTransform.skew.x - oldTransform.skew.x,
        y: newTransform.skew.y - oldTransform.skew.y
      },
      rotation: newTransform.rotation - oldTransform.rotation
    };
  }
  TransformSchema2.getDelta = getDelta;
  function mergeDelta(oldTransform, newTransformDelta, toFixedNum) {
    const toFixed = toFixedNum !== void 0 ? (v) => Math.round(v * 100) / 100 : (v) => v;
    return {
      position: {
        x: toFixed(newTransformDelta.position.x + oldTransform.position.x),
        y: toFixed(newTransformDelta.position.y + oldTransform.position.y)
      },
      size: {
        width: toFixed(newTransformDelta.size.width + oldTransform.size.width),
        height: toFixed(newTransformDelta.size.height + oldTransform.size.height),
        locked: oldTransform.size.locked
      },
      origin: {
        x: toFixed(newTransformDelta.origin.x + oldTransform.origin.x),
        y: toFixed(newTransformDelta.origin.y + oldTransform.origin.y)
      },
      scale: {
        x: toFixed(newTransformDelta.scale.x + oldTransform.scale.x),
        y: toFixed(newTransformDelta.scale.y + oldTransform.scale.y)
      },
      skew: {
        x: toFixed(newTransformDelta.skew.x + oldTransform.skew.x),
        y: toFixed(newTransformDelta.skew.y + oldTransform.skew.y)
      },
      rotation: newTransformDelta.rotation + oldTransform.rotation
    };
  }
  TransformSchema2.mergeDelta = mergeDelta;
  function is(obj) {
    return obj && obj.position && obj.size && typeof obj.position.x === "number" && typeof obj.size.width === "number";
  }
  TransformSchema2.is = is;
})(TransformSchema || (TransformSchema = {}));
var SizeSchema;
((SizeSchema2) => {
  function fixSize(currentSize, parentSize) {
    if (currentSize.width <= parentSize.width && currentSize.height <= parentSize.height) return 1;
    const wScale = currentSize.width / parentSize.width;
    const hScale = currentSize.height / parentSize.height;
    const scale = wScale > hScale ? wScale : hScale;
    return 1 / scale;
  }
  SizeSchema2.fixSize = fixSize;
  function coverSize(currentSize, parentSize) {
    const wScale = currentSize.width / parentSize.width;
    const hScale = currentSize.height / parentSize.height;
    const scale = wScale < hScale ? wScale : hScale;
    return 1 / scale;
  }
  SizeSchema2.coverSize = coverSize;
  function empty() {
    return { width: 0, height: 0 };
  }
  SizeSchema2.empty = empty;
})(SizeSchema || (SizeSchema = {}));

// src/schema/schema-base.ts
var PaddingSchema;
((PaddingSchema2) => {
  PaddingSchema2.empty = () => ({ left: 0, right: 0, top: 0, bottom: 0 });
})(PaddingSchema || (PaddingSchema = {}));
var TintSchema;
((TintSchema2) => {
  function isEmpty2(tint) {
    if (!tint) return true;
    return tint.topLeft === void 0 && tint.topRight === void 0 && tint.bottomLeft === void 0 && tint.bottomRight === void 0;
  }
  TintSchema2.isEmpty = isEmpty2;
})(TintSchema || (TintSchema = {}));
var CropSchemaDecoration = {
  label: "\u88C1\u526A",
  properties: {
    width: { label: "\u5BBD", type: "integer" },
    height: { label: "\u9AD8", type: "integer" },
    x: { label: "x", type: "integer" },
    y: { label: "y", type: "integer" }
  },
  type: "object"
};
var FlipSchemaDecoration = {
  label: "\u955C\u50CF\u66FF\u6362",
  properties: {
    x: { label: "\u6C34\u5E73\u955C\u50CF\u66FF\u6362", default: false, type: "boolean" },
    y: { label: "\u5782\u76F4\u955C\u50CF\u66FF\u6362", default: false, type: "boolean" }
  },
  type: "object"
};
var PaddingSchemaDecoration = {
  label: "\u7559\u767D",
  properties: {
    left: { label: "\u5DE6", default: 0, type: "integer" },
    top: { label: "\u4E0A", default: 0, type: "integer" },
    right: { label: "\u53F3", default: 0, type: "integer" },
    bottom: { label: "\u4E0B", default: 0, type: "integer" }
  },
  type: "object"
};
var ShadowSchemaDecoration = {
  label: "\u9634\u5F71",
  properties: {
    offsetX: { label: "X", type: "integer" },
    offsetY: { label: "Y", type: "integer" },
    blur: { label: "\u6A21\u7CCA", type: "integer" },
    color: { label: "\u989C\u8272", type: "color" }
  },
  type: "object"
};
var TintSchemaDecoration = {
  label: "\u989C\u8272",
  properties: {
    topLeft: { label: "\u5DE6\u4E0A", type: "color" },
    topRight: { label: "\u53F3\u4E0A", type: "color" },
    bottomLeft: { label: "\u5DE6\u4E0B", type: "color" },
    bottomRight: { label: "\u53F3\u4E0B", type: "color" }
  },
  type: "object"
};
var OpacitySchemaDecoration = {
  label: "\u900F\u660E\u5EA6",
  type: "float",
  min: 0,
  max: 1,
  default: 1
};

// src/dom-utils.ts
import clx from "clsx";
var toStyleKey = (key) => key.replace(/([A-Z])/, (k) => `-${k.toLowerCase()}`);
var domUtils;
((domUtils2) => {
  function toPixel(num) {
    return `${num}px`;
  }
  domUtils2.toPixel = toPixel;
  function fromPercent(percent) {
    return parseFloat(percent.substring(0, percent.length - 1));
  }
  domUtils2.fromPercent = fromPercent;
  function toPercent(percent) {
    return `${percent}%`;
  }
  domUtils2.toPercent = toPercent;
  function enableEvent(element) {
    element.style.pointerEvents = "all";
  }
  domUtils2.enableEvent = enableEvent;
  function disableEvent(element) {
    element.style.pointerEvents = "none";
  }
  domUtils2.disableEvent = disableEvent;
  function createElement(ele, ...classNames) {
    const element = document.createElement(ele);
    if (classNames.length > 0) {
      element.className = clx(classNames);
    }
    return element;
  }
  domUtils2.createElement = createElement;
  function createDivWithClass(...classNames) {
    return createElement("div", ...classNames);
  }
  domUtils2.createDivWithClass = createDivWithClass;
  function addClass(element, ...classNames) {
    element.className = clx(classNames.concat(element.className.split(" ")));
  }
  domUtils2.addClass = addClass;
  function delClass(element, ...classNames) {
    classNames.forEach((name) => {
      element.classList.remove(name);
    });
    element.className = element.classList.toString();
  }
  domUtils2.delClass = delClass;
  function coverClass(element, ...classNames) {
    element.className = clx(classNames);
  }
  domUtils2.coverClass = coverClass;
  function clearChildren(container) {
    container.innerHTML = "";
  }
  domUtils2.clearChildren = clearChildren;
  function translatePercent(node, x, y) {
    node.style.transform = `translate(${x}%, ${y}%)`;
  }
  domUtils2.translatePercent = translatePercent;
  function translateXPercent(node, x) {
    node.style.transform = `translateX(${x}%)`;
  }
  domUtils2.translateXPercent = translateXPercent;
  function translateYPercent(node, y) {
    node.style.transform = `translateY(${y}%)`;
  }
  domUtils2.translateYPercent = translateYPercent;
  function setStyle(node, styles) {
    const styleStrs = [];
    each(styles, (value, key) => {
      if (value === void 0) return;
      if (typeof value === "number" && key !== "opacity" && key !== "zIndex" && key !== "scale") {
        value = toPixel(value);
      }
      styleStrs.push(`${toStyleKey(key)}:${value}`);
    });
    const oldStyle = node.getAttribute("style");
    const newStyle = styleStrs.join(";");
    if (oldStyle !== newStyle) {
      node.setAttribute("style", newStyle);
    }
  }
  domUtils2.setStyle = setStyle;
  function classNameWithPrefix(prefix) {
    return (key, opts) => clx(
      key.split(/\s+/).map((s) => `${prefix}-${s}`).join(" "),
      opts
    );
  }
  domUtils2.classNameWithPrefix = classNameWithPrefix;
  function addStandardDisposableListener(dom, type, listener, options) {
    dom.addEventListener(type, listener, options);
    return Disposable.create(() => {
      dom.removeEventListener(type, listener);
    });
  }
  domUtils2.addStandardDisposableListener = addStandardDisposableListener;
  function createDOMCache(parent, className, children) {
    return Cache.create(() => {
      const dom = typeof className === "string" ? domUtils2.createDivWithClass(className) : className();
      if (children) {
        dom.innerHTML = children;
      }
      parent.appendChild(dom);
      return Object.assign(dom, {
        // key: item ? item.key : undefined,
        dispose: () => {
          const { parentNode } = dom;
          if (parentNode) {
            parentNode.removeChild(dom);
          }
        },
        setStyle: (style) => {
          domUtils2.setStyle(dom, style);
        }
      });
    });
  }
  domUtils2.createDOMCache = createDOMCache;
})(domUtils || (domUtils = {}));

// src/id.ts
var _idx = 0;
function generateLocalId() {
  if (_idx === Number.MAX_SAFE_INTEGER) {
    _idx = 0;
  }
  return _idx++;
}
function _setIdx(idx) {
  _idx = idx;
}

// src/array.ts
function iterToArray(iter) {
  const result = [];
  for (const v of iter) {
    result.push(v);
  }
  return result;
}
function arrayToSet(arr) {
  const set = /* @__PURE__ */ new Set();
  for (let i = 0, len = arr.length; i < len; i++) {
    set.add(arr[i]);
  }
  return set;
}
function arrayUnion(arr) {
  const result = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    if (!result.includes(arr[i])) result.push(arr[i]);
  }
  return result;
}

// src/inversify-utils.ts
function bindContributions(bind, target, contribs) {
  bind(target).toSelf().inSingletonScope();
  contribs.forEach((contrib) => bind(contrib).toService(target));
}

// src/request-with-memo.ts
var RequestCache = /* @__PURE__ */ new Map();
var CACHE_TIME = 1e4;
function clearRequestCache() {
  RequestCache.clear();
}
function requestWithMemo(req, cacheTime = CACHE_TIME, createCacheKey) {
  return (...args) => {
    const cacheKey = createCacheKey ? createCacheKey(...args) : req;
    if (RequestCache.has(cacheKey)) {
      return Promise.resolve(RequestCache.get(cacheKey));
    }
    const result = req(...args);
    const time = setTimeout(() => RequestCache.delete(cacheKey), cacheTime);
    const withErrorResult = result.catch((e) => {
      RequestCache.delete(cacheKey);
      clearTimeout(time);
      throw e;
    });
    RequestCache.set(cacheKey, withErrorResult);
    return withErrorResult;
  };
}

// src/compose.ts
function composeAsync(...fns) {
  return async (data, ...others) => {
    let index = 0;
    while (fns[index]) {
      data = await fns[index](data, ...others);
      index += 1;
    }
    return data;
  };
}
function compose(...fns) {
  return (data, ...others) => {
    let index = 0;
    while (fns[index]) {
      data = fns[index](data, ...others);
      index += 1;
    }
    return data;
  };
}

// src/contribution-provider.ts
var ContributionProvider = Symbol("ContributionProvider");
var ContainerContributionProviderImpl = class {
  constructor(container, identifier) {
    this.container = container;
    this.identifier = identifier;
  }
  forEach(fn) {
    this.getContributions().forEach(fn);
  }
  getContributions() {
    if (!this.services) {
      const currentServices = [];
      let { container } = this;
      if (container.isBound(this.identifier)) {
        try {
          currentServices.push(...container.getAll(this.identifier));
        } catch (error) {
          console.error(error);
        }
      }
      this.services = currentServices;
    }
    return this.services;
  }
};
function bindContributionProvider(bind, id) {
  bind(ContributionProvider).toDynamicValue((ctx) => new ContainerContributionProviderImpl(ctx.container, id)).inSingletonScope().whenTargetNamed(id);
}

// src/add-event-listener.ts
function addEventListener(element, type, listener, useCapture) {
  element.addEventListener(type, listener, useCapture);
  return Disposable.create(() => element.removeEventListener(type, listener, useCapture));
}

// src/logger.ts
var Logger = class {
  isDevEnv() {
    return process.env.NODE_ENV === "development";
  }
  info(...props) {
    if (!this.isDevEnv()) return;
    return console.info(props);
  }
  log(...props) {
    if (!this.isDevEnv()) return;
    return console.log(...props);
  }
  error(...props) {
    return console.error(...props);
  }
  warn(...props) {
    return console.warn(...props);
  }
};
var logger = new Logger();

// src/decoration-style.ts
function createStyleElement(styleId, container = document.head) {
  const style = document.createElement("style");
  style.id = styleId;
  style.type = "text/css";
  style.media = "screen";
  style.appendChild(document.createTextNode(""));
  container.appendChild(style);
  return style;
}
var DecorationStyle = {
  createStyleElement
};

// src/hooks/use-refresh.ts
import { useCallback, useState } from "react";
function useRefresh(defaultValue) {
  const [, update] = useState(defaultValue);
  return useCallback((v) => update(v !== void 0 ? v : {}), []);
}
export {
  Angle,
  Cache,
  CancellationToken,
  CancellationTokenSource,
  Circle,
  Compare,
  ContributionProvider,
  CropSchemaDecoration,
  DEG_TO_RAD,
  DecorationStyle,
  Deferred,
  Disposable,
  DisposableCollection,
  DisposableImpl,
  Emitter,
  Event,
  FlipSchemaDecoration,
  Matrix,
  MutableToken,
  NOOP,
  OBBRect,
  OpacitySchemaDecoration,
  OriginSchemaDecoration,
  PI,
  PI_2,
  PaddingSchema,
  PaddingSchemaDecoration,
  Point,
  PositionSchemaDecoration,
  PromiseDeferred,
  PromisePool,
  RAD_TO_DEG,
  Rectangle,
  RectangleAlignTitle,
  RectangleAlignType,
  RequestCache,
  RotationSchemaDecoration,
  SHAPES,
  ScaleSchemaDecoration,
  Schema,
  SchemaDecoration,
  ShadowSchemaDecoration,
  SizeSchema,
  SizeSchemaDecoration,
  SkewSchemaDecoration,
  TintSchema,
  TintSchemaDecoration,
  Transform,
  TransformSchema,
  TransformSchemaDecoration,
  _setIdx,
  addEventListener,
  arrayToSet,
  arrayUnion,
  bindContributionProvider,
  bindContributions,
  cancelled,
  checkCancelled,
  clearRequestCache,
  compose,
  composeAsync,
  deepFreeze,
  delay,
  domUtils,
  each,
  filter,
  generateLocalId,
  getByKey,
  getTag,
  isCancelled,
  isEmpty,
  isFunction,
  isNumber,
  isObject,
  isPlainObject,
  isString,
  iterToArray,
  logger,
  mapKeys,
  mapValues,
  notEmpty,
  omit,
  pick,
  reduce,
  requestWithMemo,
  retry,
  setByKey,
  useRefresh,
  values
};
//# sourceMappingURL=index.js.map