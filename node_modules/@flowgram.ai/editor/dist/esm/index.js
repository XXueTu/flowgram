var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/index.ts
import "reflect-metadata";
import { FormModelV2 } from "@flowgram.ai/node";
export * from "@flowgram.ai/utils";
export * from "@flowgram.ai/core";
export * from "@flowgram.ai/document";
export * from "@flowgram.ai/renderer";
export * from "@flowgram.ai/variable-plugin";
export * from "@flowgram.ai/shortcuts-plugin";
export * from "@flowgram.ai/node-core-plugin";
export * from "@flowgram.ai/i18n-plugin";
import {
  injectable as injectable4,
  postConstruct,
  named,
  Container,
  ContainerModule,
  AsyncContainerModule,
  inject as inject4,
  multiInject
} from "inversify";
import { FlowNodeFormData, NodeRender } from "@flowgram.ai/form-core";
import {
  Form,
  Field,
  FieldArray,
  useForm,
  useField,
  useCurrentField,
  useCurrentFieldState,
  useFieldValidate,
  useWatch,
  ValidateTrigger
} from "@flowgram.ai/form";
export * from "@flowgram.ai/node";

// src/preset/editor-props.ts
var EditorProps;
((EditorProps3) => {
  EditorProps3.DEFAULT = {
    background: {}
  };
})(EditorProps || (EditorProps = {}));

// src/preset/editor-default-preset.ts
import { FlowRendererContainerModule, FlowRendererRegistry } from "@flowgram.ai/renderer";
import { createReduxDevToolPlugin } from "@flowgram.ai/redux-devtool-plugin";
import { createNodeVariablePlugin } from "@flowgram.ai/node-variable-plugin";
import { createNodeCorePlugin } from "@flowgram.ai/node-core-plugin";
import { createMaterialsPlugin } from "@flowgram.ai/materials-plugin";
import { createI18nPlugin } from "@flowgram.ai/i18n-plugin";
import { createHistoryNodePlugin } from "@flowgram.ai/history-node-plugin";
import { FlowDocumentContainerModule } from "@flowgram.ai/document";
import { createPlaygroundPlugin } from "@flowgram.ai/core";

// src/utils/compose.ts
var compose = (fnList) => (node, data) => {
  const list = fnList.filter(Boolean);
  if (!list.length) {
    return data;
  }
  return list.reduce((acc, fn) => fn(node, acc), data);
};

// src/clients/flow-editor-client-plugins.ts
import { definePluginCreator as definePluginCreator3 } from "@flowgram.ai/core";

// src/clients/node-client/create-node-client-plugins.ts
import { definePluginCreator as definePluginCreator2 } from "@flowgram.ai/core";

// src/clients/node-client/node-focus-service.ts
import { injectable, inject } from "inversify";
import { Playground } from "@flowgram.ai/core";

// src/clients/node-client/highlight/highlight-form-item.ts
import { FlowNodeRenderData } from "@flowgram.ai/document";

// src/clients/node-client/highlight/highlight-style.ts
var HIGHLIGHT_CLASSNAME = "flowide-highlight";
var styleText = `
@keyframes flowide-fade {
  from {
   opacity: 1.0;
  }
  to {
    opacity: 0;
  }
}
@-webkit-keyframes flowide-fade {
  from {
   opacity: 1.0;
  }
  to {
    opacity: 0;
  }
}
.${HIGHLIGHT_CLASSNAME} {
  background-color: rgba(238, 245, 40, 0.5);
  animation: flowide-fade 2s 1 forwards;
  -webkit-animation: flowide-fade 2s 1 forwards;
}
`;
var styleDom;
function createHighlightStyle() {
  if (styleDom) return;
  styleDom = document.createElement("style");
  styleDom.innerHTML = styleText;
  document.head.appendChild(styleDom);
}
function removeHighlightStyle() {
  styleDom?.remove();
  styleDom = void 0;
}

// src/clients/node-client/highlight/constants.ts
var DEFAULT_HIGHLIGHT_PADDING = 0;

// src/clients/node-client/highlight/highlight-form-item.ts
function highlightFormItem(formItem, options) {
  const parent = formItem.formModel.flowNodeEntity.getData(FlowNodeRenderData).node;
  const target = formItem.domRef.current;
  if (!target) {
    return void 0;
  }
  const overlay = document.createElement("div");
  const { padding = DEFAULT_HIGHLIGHT_PADDING, overlayClassName } = options || {};
  overlay.style.position = "absolute";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100%";
  overlay.style.height = "100%";
  overlay.style.zIndex = "9999";
  parent.appendChild(overlay);
  const parentRect = parent.getBoundingClientRect();
  const targetRect = target.getBoundingClientRect();
  overlay.style.top = targetRect.top - parentRect.top - padding + "px";
  overlay.style.left = targetRect.left - parentRect.left - padding + "px";
  overlay.style.width = targetRect.width + padding * 2 + "px";
  overlay.style.height = targetRect.height + padding * 2 + "px";
  overlay.className = overlayClassName || HIGHLIGHT_CLASSNAME;
  setTimeout(() => {
    overlay.remove();
  }, 2e3);
  return overlay;
}

// src/clients/node-client/highlight/use-highlight.ts
import { useRef } from "react";
function useHighlight(props) {
  const ref = useRef(null);
  const { form, path } = props;
  const formItem = form.getFormItemByPath(path);
  if (!formItem) {
    return null;
  }
  formItem.domRef = ref;
  return ref;
}

// src/clients/node-client/node-focus-service.ts
var NodeFocusService = class {
  highlightNodeFormItem(formItem, options) {
    this.previousOverlay = highlightFormItem(formItem, options);
  }
  focusNodeFormItem(formItem, options) {
    const node = formItem.formModel.flowNodeEntity;
    const { canvas = {}, highlight } = options || {};
    if (this.previousOverlay) {
      this.previousOverlay.remove();
      this.previousOverlay = void 0;
    }
    const currentPromise = this.playground.scrollToView({ entities: [node], scrollToCenter: true, ...canvas }).then(() => {
      if (!formItem || !highlight || this.currentPromise !== currentPromise) {
        return;
      }
      this.highlightNodeFormItem(formItem, typeof highlight === "boolean" ? {} : highlight);
    });
    this.currentPromise = currentPromise;
    return this.currentPromise;
  }
};
__decorateClass([
  inject(Playground)
], NodeFocusService.prototype, "playground", 2);
NodeFocusService = __decorateClass([
  injectable()
], NodeFocusService);

// src/clients/node-client/node-client.ts
import { injectable as injectable2, inject as inject2 } from "inversify";
var NodeClient = class {
};
__decorateClass([
  inject2(NodeFocusService)
], NodeClient.prototype, "nodeFocusService", 2);
NodeClient = __decorateClass([
  injectable2()
], NodeClient);

// src/clients/node-client/highlight/create-node-highlight-plugin.ts
import { definePluginCreator } from "@flowgram.ai/core";
var createNodeHighlightPlugin = definePluginCreator({
  onInit() {
    createHighlightStyle();
  },
  onDispose() {
    removeHighlightStyle();
  }
});

// src/clients/node-client/create-node-client-plugins.ts
var createNodeClientPlugin = definePluginCreator2({
  onBind({ bind }) {
    bind(NodeFocusService).toSelf().inSingletonScope();
    bind(NodeClient).toSelf().inSingletonScope();
  }
});
var createNodeClientPlugins = () => [
  createNodeHighlightPlugin({}),
  createNodeClientPlugin({})
];

// src/clients/flow-editor-client.ts
import { injectable as injectable3, inject as inject3 } from "inversify";
import { Playground as Playground2 } from "@flowgram.ai/core";
var FlowEditorClient = class {
  focusNodeFormItem(formItem, options) {
    this.nodeClient.nodeFocusService.focusNodeFormItem(formItem, options);
  }
  focusNode(node, options) {
    this.playground.scrollToView({ entities: [node], ...options });
  }
};
__decorateClass([
  inject3(NodeClient)
], FlowEditorClient.prototype, "nodeClient", 2);
__decorateClass([
  inject3(Playground2)
], FlowEditorClient.prototype, "playground", 2);
FlowEditorClient = __decorateClass([
  injectable3()
], FlowEditorClient);

// src/clients/flow-editor-client-plugins.ts
var createFlowEditorClientPlugin = definePluginCreator3({
  onBind({ bind }) {
    bind(FlowEditorClient).toSelf().inSingletonScope();
  }
});
var createFlowEditorClientPlugins = () => [
  ...createNodeClientPlugins(),
  createFlowEditorClientPlugin({})
];

// src/preset/editor-default-preset.ts
function createDefaultPreset(opts, plugins = []) {
  return (ctx) => {
    opts = { ...EditorProps.DEFAULT, ...opts };
    if (opts.i18n) {
      plugins.push(createI18nPlugin(opts.i18n));
    }
    plugins.push(...createFlowEditorClientPlugins());
    if (opts.reduxDevTool?.enable) {
      plugins.push(createReduxDevToolPlugin(opts.reduxDevTool));
    }
    const defaultContainerModules = [
      FlowDocumentContainerModule,
      // 默认文档
      FlowRendererContainerModule
      // 默认渲染
    ];
    plugins.push(createMaterialsPlugin(opts.materials || {}));
    if (opts.nodeEngine && opts.nodeEngine.enable !== false) {
      plugins.push(createNodeCorePlugin({ materials: opts.nodeEngine.materials }));
      if (opts.variableEngine?.enable) {
        plugins.push(createNodeVariablePlugin({}));
      }
      if (opts.history?.enable) {
        plugins.push(createHistoryNodePlugin({}));
      }
    }
    plugins.push(
      createPlaygroundPlugin({
        onInit: (ctx2) => {
          if (opts.nodeRegistries) {
            ctx2.document.registerFlowNodes(...opts.nodeRegistries);
          }
          if (opts.constants) {
            ctx2.document.options.constants = opts.constants;
          }
          if (opts.formatNodeLines) {
            ctx2.document.options.formatNodeLines = compose([
              ctx2.document.options.formatNodeLines,
              opts.formatNodeLines
            ]);
          }
          if (opts.formatNodeLabels) {
            ctx2.document.options.formatNodeLabels = compose([
              ctx2.document.options.formatNodeLabels,
              opts.formatNodeLabels
            ]);
          }
          if (opts.getNodeDefaultRegistry) {
            ctx2.document.options.getNodeDefaultRegistry = opts.getNodeDefaultRegistry;
          }
          ctx2.get(FlowRendererRegistry).init();
        },
        onReady(ctx2) {
          if (opts.initialData) {
            ctx2.document.fromJSON(opts.initialData);
          }
          if (opts.readonly) {
            ctx2.playground.config.readonly = opts.readonly;
          }
          ctx2.document.load().then(() => {
            if (opts.onLoad) opts.onLoad(ctx2);
          });
        },
        onDispose(ctx2) {
          ctx2.document.dispose();
        },
        containerModules: defaultContainerModules
      })
    );
    return plugins;
  };
}

// src/components/editor-provider.tsx
import React, { useMemo, useCallback } from "react";
import { FlowDocument } from "@flowgram.ai/document";
import {
  PlaygroundReactProvider,
  createPluginContextDefault,
  SelectionService
} from "@flowgram.ai/core";
var EditorProvider = (props) => {
  const { children, ...others } = props;
  const preset = useMemo(() => createDefaultPreset(others), []);
  const customPluginContext = useCallback(
    (container) => ({
      ...createPluginContextDefault(container),
      get document() {
        return container.get(FlowDocument);
      },
      get selection() {
        return container.get(SelectionService);
      }
    }),
    []
  );
  return /* @__PURE__ */ React.createElement(PlaygroundReactProvider, { plugins: preset, customPluginContext }, children);
};

// src/components/editor-renderer.tsx
import { PlaygroundReactRenderer } from "@flowgram.ai/core";

// src/components/editor.tsx
import React2 from "react";
var Editor = (props) => {
  const { children, ...otherProps } = props;
  return /* @__PURE__ */ React2.createElement(EditorProvider, { ...otherProps }, /* @__PURE__ */ React2.createElement(PlaygroundReactRenderer, null, children));
};

// src/hooks/use-flow-editor.ts
import { useService } from "@flowgram.ai/core";
function useFlowEditor() {
  return useService(FlowEditorClient);
}

// src/index.ts
export * from "@flowgram.ai/node-variable-plugin";
import { createPlaygroundReactPreset } from "@flowgram.ai/playground-react";
export {
  AsyncContainerModule,
  Container,
  ContainerModule,
  Editor,
  EditorProps,
  EditorProvider,
  PlaygroundReactRenderer as EditorRenderer,
  Field,
  FieldArray,
  FlowEditorClient,
  FlowNodeFormData,
  Form,
  FormModelV2 as FormModel,
  NodeClient,
  NodeFocusService,
  NodeRender,
  ValidateTrigger,
  createDefaultPreset,
  createFlowEditorClientPlugin,
  createFlowEditorClientPlugins,
  createPlaygroundReactPreset,
  highlightFormItem,
  inject4 as inject,
  injectable4 as injectable,
  multiInject,
  named,
  postConstruct,
  useCurrentField,
  useCurrentFieldState,
  useField,
  useFieldValidate,
  useFlowEditor,
  useForm,
  useHighlight,
  useWatch
};
//# sourceMappingURL=index.js.map