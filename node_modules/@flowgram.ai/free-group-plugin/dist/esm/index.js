var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/create-free-group-plugin.tsx
import { ShortcutsRegistry } from "@flowgram.ai/shortcuts-plugin";
import { FlowRendererRegistry } from "@flowgram.ai/renderer";
import { WorkflowDocument as WorkflowDocument2 } from "@flowgram.ai/free-layout-core";
import { FlowGroupService as FlowGroupService2, FlowNodeBaseType as FlowNodeBaseType5 } from "@flowgram.ai/document";
import { definePluginCreator } from "@flowgram.ai/core";

// src/workflow-group-service.ts
import { injectable, inject } from "inversify";
import { DisposableCollection } from "@flowgram.ai/utils";
import {
  WorkflowDocument,
  WorkflowOperationBaseService,
  nanoid
} from "@flowgram.ai/free-layout-core";
import { HistoryService } from "@flowgram.ai/free-history-plugin";
import {
  NodeIntoContainerService,
  NodeIntoContainerType
} from "@flowgram.ai/free-container-plugin";
import { FlowGroupService, FlowNodeBaseType as FlowNodeBaseType2 } from "@flowgram.ai/document";
import { TransformData } from "@flowgram.ai/core";

// src/utils.ts
import { FlowNodeBaseType } from "@flowgram.ai/document";
var WorkflowGroupUtils;
((WorkflowGroupUtils2) => {
  const isNodeInGroup = (node) => {
    if (node?.parent?.flowNodeType === FlowNodeBaseType.GROUP) {
      return true;
    }
    return false;
  };
  const isGroupNode = (group) => group.flowNodeType === FlowNodeBaseType.GROUP;
  WorkflowGroupUtils2.validate = (nodes) => {
    if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
      return false;
    }
    const isGroupRelatedNode = nodes.some((node) => isGroupNode(node));
    if (isGroupRelatedNode) return false;
    const hasGroup = nodes.some((node) => node && isNodeInGroup(node));
    if (hasGroup) return false;
    const parent = nodes[0].parent;
    const isSameParent = nodes.every((node) => node.parent === parent);
    if (!isSameParent) return false;
    return true;
  };
})(WorkflowGroupUtils || (WorkflowGroupUtils = {}));

// src/workflow-group-service.ts
var WorkflowGroupService = class extends FlowGroupService {
  constructor() {
    super(...arguments);
    this.toDispose = new DisposableCollection();
  }
  ready() {
    this.toDispose.push(this.listenContainer());
  }
  dispose() {
    this.toDispose.dispose();
  }
  /** 创建分组节点 */
  createGroup(nodes) {
    if (!WorkflowGroupUtils.validate(nodes)) {
      return;
    }
    const parent = nodes[0].parent ?? this.document.root;
    const groupId = `group_${nanoid(5)}`;
    const groupJSON = {
      type: FlowNodeBaseType2.GROUP,
      id: groupId,
      meta: {
        position: {
          x: 0,
          y: 0
        }
      },
      data: {}
    };
    this.historyService.startTransaction();
    this.document.createWorkflowNodeByType(
      FlowNodeBaseType2.GROUP,
      {
        x: 0,
        y: 0
      },
      groupJSON,
      parent.id
    );
    nodes.forEach((node) => {
      this.freeOperationService.moveNode(node, {
        parent: groupId
      });
    });
    this.historyService.endTransaction();
  }
  /** 取消分组 */
  ungroup(groupNode) {
    const groupBlocks = groupNode.blocks.slice();
    if (!groupNode.parent) {
      return;
    }
    const groupPosition = groupNode.transform.position;
    this.historyService.startTransaction();
    groupBlocks.forEach((node) => {
      this.freeOperationService.moveNode(node, {
        parent: groupNode.parent?.id
      });
    });
    groupNode.dispose();
    groupBlocks.forEach((node) => {
      const transform = node.getData(TransformData);
      const position = {
        x: transform.position.x + groupPosition.x,
        y: transform.position.y + groupPosition.y
      };
      this.freeOperationService.updateNodePosition(node, position);
    });
    this.historyService.endTransaction();
  }
  listenContainer() {
    return this.nodeIntoContainerService.on((e) => {
      if (e.type !== NodeIntoContainerType.Out || e.sourceContainer?.flowNodeType !== FlowNodeBaseType2.GROUP) {
        return;
      }
      if (e.sourceContainer?.blocks.length === 0) {
        e.sourceContainer.dispose();
      }
    });
  }
};
__decorateClass([
  inject(WorkflowDocument)
], WorkflowGroupService.prototype, "document", 2);
__decorateClass([
  inject(WorkflowOperationBaseService)
], WorkflowGroupService.prototype, "freeOperationService", 2);
__decorateClass([
  inject(HistoryService)
], WorkflowGroupService.prototype, "historyService", 2);
__decorateClass([
  inject(NodeIntoContainerService)
], WorkflowGroupService.prototype, "nodeIntoContainerService", 2);
WorkflowGroupService = __decorateClass([
  injectable()
], WorkflowGroupService);

// src/shortcuts/group.ts
import { WorkflowSelectService } from "@flowgram.ai/free-layout-core";

// src/constant.ts
var WorkflowGroupCommand = /* @__PURE__ */ ((WorkflowGroupCommand2) => {
  WorkflowGroupCommand2["Group"] = "group";
  WorkflowGroupCommand2["Ungroup"] = "ungroup";
  return WorkflowGroupCommand2;
})(WorkflowGroupCommand || {});

// src/shortcuts/group.ts
var GroupShortcut = class {
  constructor(context) {
    this.commandId = "group" /* Group */;
    this.commandDetail = {
      label: "Group"
    };
    this.shortcuts = ["meta g", "ctrl g"];
    this.selectService = context.get(WorkflowSelectService);
    this.groupService = context.get(WorkflowGroupService);
    this.execute = this.execute.bind(this);
  }
  async execute() {
    this.groupService.createGroup(this.selectService.selectedNodes);
    this.selectService.clear();
  }
};

// src/shortcuts/ungroup.ts
import { WorkflowSelectService as WorkflowSelectService2 } from "@flowgram.ai/free-layout-core";
import { FlowNodeBaseType as FlowNodeBaseType3 } from "@flowgram.ai/document";
var UngroupShortcut = class {
  constructor(context) {
    this.commandId = "ungroup" /* Ungroup */;
    this.commandDetail = {
      label: "Ungroup"
    };
    this.shortcuts = ["meta shift g", "ctrl shift g"];
    this.selectService = context.get(WorkflowSelectService2);
    this.groupService = context.get(WorkflowGroupService);
    this.execute = this.execute.bind(this);
  }
  async execute(_groupNode) {
    const groupNode = _groupNode || this.selectService.activatedNode;
    if (!groupNode || groupNode.flowNodeType !== FlowNodeBaseType3.GROUP) {
      return;
    }
    this.groupService.ungroup(groupNode);
    this.selectService.clear();
  }
};

// src/group-node.tsx
import { FlowNodeBaseType as FlowNodeBaseType4, FlowNodeTransformData } from "@flowgram.ai/document";
var GroupNodeRegistry = {
  type: FlowNodeBaseType4.GROUP,
  meta: {
    renderKey: FlowNodeBaseType4.GROUP,
    defaultPorts: [],
    isContainer: true,
    disableSideBar: true,
    size: {
      width: 560,
      height: 400
    },
    padding: () => ({
      top: 80,
      bottom: 40,
      left: 65,
      right: 65
    }),
    selectable(node, mousePos) {
      if (!mousePos) {
        return true;
      }
      const transform = node.getData(FlowNodeTransformData);
      return !transform.bounds.contains(mousePos.x, mousePos.y);
    },
    expandable: false
  },
  formMeta: {
    render: () => /* @__PURE__ */ React.createElement(React.Fragment, null)
  }
};

// src/create-free-group-plugin.tsx
var createFreeGroupPlugin = definePluginCreator(
  {
    onBind({ bind, rebind }) {
      bind(WorkflowGroupService).toSelf().inSingletonScope();
      rebind(FlowGroupService2).toService(WorkflowGroupService);
    },
    onInit(ctx, { groupNodeRender, disableGroupShortcuts = false, disableGroupNodeRegister = false }) {
      if (groupNodeRender) {
        const renderRegistry = ctx.get(FlowRendererRegistry);
        renderRegistry.registerReactComponent(FlowNodeBaseType5.GROUP, groupNodeRender);
      }
      if (!disableGroupShortcuts) {
        const shortcutsRegistry = ctx.get(ShortcutsRegistry);
        shortcutsRegistry.addHandlers(new GroupShortcut(ctx), new UngroupShortcut(ctx));
      }
      if (!disableGroupNodeRegister) {
        const document = ctx.get(WorkflowDocument2);
        document.registerFlowNodes(GroupNodeRegistry);
      }
    },
    onReady(ctx) {
      const groupService = ctx.get(WorkflowGroupService);
      groupService.ready();
    },
    onDispose(ctx) {
      const groupService = ctx.get(WorkflowGroupService);
      groupService.dispose();
    }
  }
);
export {
  WorkflowGroupCommand,
  WorkflowGroupService,
  createFreeGroupPlugin
};
//# sourceMappingURL=index.js.map