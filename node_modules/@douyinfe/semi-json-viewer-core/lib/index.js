// src/common/dom.ts
function elt(tag, className, style) {
  const el = document.createElement(tag);
  el.className = className;
  if (style) {
    setStyles(el, style);
  }
  return el;
}
function setStyles(element, styles) {
  for (const [key, value] of Object.entries(styles)) {
    element.style[key] = value;
  }
}
function getLineElement(node) {
  return node.parentElement?.closest('[data-line-element="true"]') || null;
}

// src/tokens/tokenize.ts
import * as json from "jsonc-parser";
function createTokenizationSupport(supportComments) {
  return {
    getInitialState: () => new JSONState(null, null, false, null),
    tokenize: (line, state) => tokenize(supportComments, line, state)
  };
}
var TOKEN_DELIM_OBJECT = "semi-json-viewer-delimiter-bracket";
var TOKEN_DELIM_ARRAY = "semi-json-viewer-delimiter-array";
var TOKEN_DELIM_COLON = "semi-json-viewer-delimiter-colon";
var TOKEN_DELIM_COMMA = "semi-json-viewer-delimiter-comma";
var TOKEN_VALUE_BOOLEAN = "semi-json-viewer-keyword";
var TOKEN_VALUE_NULL = "semi-json-viewer-keyword";
var TOKEN_VALUE_STRING = "semi-json-viewer-string-value";
var TOKEN_VALUE_NUMBER = "semi-json-viewer-number";
var TOKEN_PROPERTY_NAME = "semi-json-viewer-string-key";
var TOKEN_COMMENT_BLOCK = "semi-json-viewer-comment-block";
var TOKEN_COMMENT_LINE = "semi-json-viewer-comment-line";
var ParentsStack = class _ParentsStack {
  constructor(parent, type, depth) {
    this.parent = parent;
    this.type = type;
    this.depth = depth;
  }
  static pop(parents) {
    if (parents) {
      return parents.parent;
    }
    return null;
  }
  static push(parents, type) {
    return new _ParentsStack(parents, type, parents ? parents.depth + 1 : 0);
  }
  static equals(a, b) {
    if (!a && !b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    while (a && b) {
      if (a.type !== b.type || a.depth !== b.depth) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    }
    return a === null && b === null;
  }
};
var JSONState = class _JSONState {
  constructor(state, scanError, lastWasColon, parents) {
    this._state = state;
    this.scanError = scanError;
    this.lastWasColon = lastWasColon;
    this.parents = parents;
  }
  clone() {
    return new _JSONState(this._state, this.scanError, this.lastWasColon, this.parents);
  }
  equals(other) {
    if (other === this) {
      return true;
    }
    if (!other || !(other instanceof _JSONState)) {
      return false;
    }
    return this.scanError === other.scanError && this.lastWasColon === other.lastWasColon && ParentsStack.equals(this.parents, other.parents);
  }
  getStateData() {
    return this._state;
  }
  setStateData(state) {
    this._state = state;
  }
};
function tokenize(comments, line, state, offsetDelta = 0) {
  let numberOfInsertedCharacters = 0;
  let adjustOffset = false;
  switch (state.scanError) {
    case 2 /* UnexpectedEndOfString */:
      line = '"' + line;
      numberOfInsertedCharacters = 1;
      break;
    case 1 /* UnexpectedEndOfComment */:
      line = "/*" + line;
      numberOfInsertedCharacters = 2;
      break;
  }
  const scanner = json.createScanner(line);
  let lastWasColon = state.lastWasColon;
  let parents = state.parents;
  const ret = {
    tokens: [],
    endState: state.clone()
  };
  while (true) {
    let offset = offsetDelta + scanner.getPosition();
    let type = "";
    const kind = scanner.scan();
    if (kind === 17 /* EOF */) {
      break;
    }
    if (offset === offsetDelta + scanner.getPosition()) {
      throw new Error("Scanner did not advance, next 3 characters are: " + line.substr(scanner.getPosition(), 3));
    }
    if (adjustOffset) {
      offset -= numberOfInsertedCharacters;
    }
    adjustOffset = numberOfInsertedCharacters > 0;
    switch (kind) {
      case 1 /* OpenBraceToken */:
        parents = ParentsStack.push(parents, 0 /* Object */);
        type = `${TOKEN_DELIM_OBJECT}-${parents ? parents.depth % 3 : 0}`;
        lastWasColon = false;
        break;
      case 2 /* CloseBraceToken */:
        type = `${TOKEN_DELIM_OBJECT}-${parents ? parents.depth % 3 : 0}`;
        parents = ParentsStack.pop(parents);
        lastWasColon = false;
        break;
      case 3 /* OpenBracketToken */:
        parents = ParentsStack.push(parents, 1 /* Array */);
        type = `${TOKEN_DELIM_ARRAY}-${parents ? parents.depth % 3 : 0}`;
        lastWasColon = false;
        break;
      case 4 /* CloseBracketToken */:
        type = `${TOKEN_DELIM_ARRAY}-${parents ? parents.depth % 3 : 0}`;
        parents = ParentsStack.pop(parents);
        lastWasColon = false;
        break;
      case 6 /* ColonToken */:
        type = TOKEN_DELIM_COLON;
        lastWasColon = true;
        break;
      case 5 /* CommaToken */:
        type = TOKEN_DELIM_COMMA;
        lastWasColon = false;
        break;
      case 8 /* TrueKeyword */:
      case 9 /* FalseKeyword */:
        type = TOKEN_VALUE_BOOLEAN;
        lastWasColon = false;
        break;
      case 7 /* NullKeyword */:
        type = TOKEN_VALUE_NULL;
        lastWasColon = false;
        break;
      case 10 /* StringLiteral */:
        const currentParent = parents ? parents.type : 0 /* Object */;
        const inArray = currentParent === 1 /* Array */;
        type = lastWasColon || inArray ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;
        lastWasColon = false;
        break;
      case 11 /* NumericLiteral */:
        type = TOKEN_VALUE_NUMBER;
        lastWasColon = false;
        break;
    }
    if (comments) {
      switch (kind) {
        case 12 /* LineCommentTrivia */:
          type = TOKEN_COMMENT_LINE;
          break;
        case 13 /* BlockCommentTrivia */:
          type = TOKEN_COMMENT_BLOCK;
          break;
      }
    }
    ret.endState = new JSONState(
      state.getStateData(),
      scanner.getTokenError(),
      lastWasColon,
      parents
    );
    ret.tokens.push({
      startIndex: offset,
      scopes: type
    });
  }
  return ret;
}

// src/common/nameSpace.ts
var currentNameSpaceId = "default";
function setCurrentNameSpaceId(id) {
  currentNameSpaceId = id;
}
function getCurrentNameSpaceId() {
  return currentNameSpaceId;
}

// src/common/emitter.ts
var emitterMap = /* @__PURE__ */ new Map();
var Emitter = class {
  constructor() {
    this.listeners = {};
  }
  on(event, listener) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]?.push(listener);
  }
  off(event, listener) {
    if (!this.listeners[event]) return;
    this.listeners[event] = this.listeners[event]?.filter((l) => l !== listener);
  }
  dispose() {
    this.listeners = {};
  }
  removeAllListeners() {
    this.listeners = {};
  }
  emit(event, data) {
    if (!this.listeners[event]) return;
    for (const listener of this.listeners[event]) {
      listener(data);
    }
  }
};
var getEmitter = () => {
  const currentNameSpaceId2 = getCurrentNameSpaceId();
  if (!currentNameSpaceId2) {
    throw new Error("currentNameSpaceId is not set");
  }
  let emitter = emitterMap.get(currentNameSpaceId2);
  if (!emitter) {
    emitter = new Emitter();
    emitterMap.set(currentNameSpaceId2, emitter);
  }
  return emitter;
};
var disposeEmitter = (id) => {
  const emitter = emitterMap.get(id);
  if (emitter) {
    emitter.dispose();
    emitterMap.delete(id);
  }
};

// src/model/selectionModel.ts
var SelectionModel = class {
  constructor(row, col, view, jsonModel) {
    this.isSelectedAll = false;
    this._row = row;
    this._col = col;
    this._view = view;
    this.startRow = row;
    this.startCol = col;
    this.endRow = row;
    this.endCol = col;
    this.isCollapsed = true;
    this._jsonModel = jsonModel;
  }
  updateSelection(row, col) {
    this._row = row;
    this._col = col;
  }
  getSelection() {
    return {
      row: this._row,
      col: this._col
    };
  }
  getPosition() {
    return {
      lineNumber: this._row,
      column: this._col
    };
  }
  updateFromSelection() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;
    const range = selection.getRangeAt(0);
    this.isCollapsed = range.collapsed;
    const startContainer = range.startContainer;
    const endContainer = range.endContainer;
    let { row: row1, col: col1 } = this.convertRangeToModelPosition(startContainer, selection, true);
    let { row: row2, col: col2 } = this.convertRangeToModelPosition(endContainer, selection, false);
    if (row1 > row2) {
      [row1, row2] = [row2, row1];
      [col1, col2] = [col2, col1];
    } else if (row1 === row2 && col1 > col2) {
      [col1, col2] = [col2, col1];
    }
    this._row = row1;
    this._col = col1;
    this.startRow = row1;
    this.startCol = col1;
    this.endRow = row2;
    this.endCol = col2;
    this._jsonModel.lastChangeBufferPos = {
      lineNumber: this._row,
      column: this._col
    };
  }
  toViewPosition() {
    const selection = window.getSelection();
    if (!selection) return;
    const range = new Range();
    if (this.isSelectedAll) {
      range.setStartBefore(this._view.scrollDom.firstChild);
      range.setEndAfter(this._view.scrollDom.lastChild);
      selection.removeAllRanges();
      selection.addRange(range);
      return;
    }
    const row = this._jsonModel.lastChangeBufferPos.lineNumber;
    const col = this._jsonModel.lastChangeBufferPos.column - 1;
    const lineElement = this._view.getLineElement(row);
    if (!lineElement) return;
    if (col === 0) {
      range.setStart(lineElement, 0);
      range.setEnd(lineElement, 0);
    } else {
      const walker = document.createTreeWalker(
        lineElement,
        NodeFilter.SHOW_TEXT,
        null
      );
      let node = walker.nextNode();
      let currentOffset = 0;
      while (node) {
        const nodeLength = node.length;
        if (currentOffset + nodeLength >= col) {
          range.setStart(node, col - currentOffset);
          range.setEnd(node, col - currentOffset);
          break;
        }
        currentOffset += nodeLength;
        node = walker.nextNode();
      }
    }
    selection.removeAllRanges();
    selection.addRange(range);
  }
  toLastPosition() {
    this.isCollapsed = true;
    this.isSelectedAll = false;
    const lineCount = this._jsonModel.getLineCount();
    const lineLength = this._jsonModel.getLineLength(lineCount);
    this._row = lineCount;
    this._col = lineLength + 1;
    this.startRow = lineCount;
    this.startCol = lineLength + 1;
    this.endRow = lineCount;
    this.endCol = lineLength + 1;
    this._jsonModel.lastChangeBufferPos = {
      lineNumber: lineCount,
      column: lineLength + 1
    };
    this.toViewPosition();
  }
  convertRangeToModelPosition(node, selection, isStart) {
    let row = 1;
    let col = 0;
    if (!node) return { row, col };
    let lineElement;
    if (node instanceof HTMLElement) {
      lineElement = node.closest(".semi-json-viewer-view-line");
    } else {
      lineElement = getLineElement(node);
      if (!lineElement) return { row, col };
      const walker = document.createTreeWalker(
        lineElement,
        NodeFilter.SHOW_TEXT,
        null
      );
      let currentNode = walker.nextNode();
      let totalOffset = 0;
      while (currentNode) {
        if (currentNode === node) {
          totalOffset += isStart ? selection.anchorOffset : selection.focusOffset;
          break;
        }
        if (currentNode.parentNode === node.parentNode) {
          if (currentNode === node) {
            totalOffset += isStart ? selection.anchorOffset : selection.focusOffset;
            break;
          }
        }
        totalOffset += currentNode.length;
        currentNode = walker.nextNode();
      }
      col = totalOffset;
    }
    row = lineElement.lineNumber || 1;
    return { row, col: col + 1 };
  }
  savePreviousSelection() {
    this.preStartRow = this.startRow;
    this.preStartCol = this.startCol;
    this.preEndRow = this.endRow;
    this.preEndCol = this.endCol;
  }
  restorePreviousSelection() {
    this.startRow = this.preStartRow;
    this.startCol = this.preStartCol;
    this.endRow = this.preEndRow;
    this.endCol = this.preEndCol;
    this._jsonModel.lastChangeBufferPos = {
      lineNumber: this.startRow,
      column: this.startCol
    };
  }
};

// src/worker/jsonWorkerManager.ts
var workerManagerMap = /* @__PURE__ */ new Map();
var JsonWorkerManager = class {
  constructor() {
    const workerRaw = decodeURIComponent(`(()%3D%3E%7Bfunction%20%24(r%2Ce%3D!1)%7Blet%20t%3Dr.length%2Cn%3D0%2Ci%3D%22%22%2Cs%3D0%2Co%3D16%2Ca%3D0%2Cl%3D0%2Cf%3D0%2Cu%3D0%2Cc%3D0%3Bfunction%20d(N%2C_)%7Blet%20g%3D0%2Ch%3D0%3Bfor(%3Bg%3CN%7C%7C!_%3B)%7Blet%20p%3Dr.charCodeAt(n)%3Bif(p%3E%3D48%26%26p%3C%3D57)h%3Dh*16%2Bp-48%3Belse%20if(p%3E%3D65%26%26p%3C%3D70)h%3Dh*16%2Bp-65%2B10%3Belse%20if(p%3E%3D97%26%26p%3C%3D102)h%3Dh*16%2Bp-97%2B10%3Belse%20break%3Bn%2B%2B%2Cg%2B%2B%7Dreturn%20g%3CN%26%26(h%3D-1)%2Ch%7Dfunction%20b(N)%7Bn%3DN%2Ci%3D%22%22%2Cs%3D0%2Co%3D16%2Cc%3D0%7Dfunction%20k()%7Blet%20N%3Dn%3Bif(r.charCodeAt(n)%3D%3D%3D48)n%2B%2B%3Belse%20for(n%2B%2B%3Bn%3Cr.length%26%26U(r.charCodeAt(n))%3B)n%2B%2B%3Bif(n%3Cr.length%26%26r.charCodeAt(n)%3D%3D%3D46)if(n%2B%2B%2Cn%3Cr.length%26%26U(r.charCodeAt(n)))for(n%2B%2B%3Bn%3Cr.length%26%26U(r.charCodeAt(n))%3B)n%2B%2B%3Belse%20return%20c%3D3%2Cr.substring(N%2Cn)%3Blet%20_%3Dn%3Bif(n%3Cr.length%26%26(r.charCodeAt(n)%3D%3D%3D69%7C%7Cr.charCodeAt(n)%3D%3D%3D101))if(n%2B%2B%2C(n%3Cr.length%26%26r.charCodeAt(n)%3D%3D%3D43%7C%7Cr.charCodeAt(n)%3D%3D%3D45)%26%26n%2B%2B%2Cn%3Cr.length%26%26U(r.charCodeAt(n)))%7Bfor(n%2B%2B%3Bn%3Cr.length%26%26U(r.charCodeAt(n))%3B)n%2B%2B%3B_%3Dn%7Delse%20c%3D3%3Breturn%20r.substring(N%2C_)%7Dfunction%20L()%7Blet%20N%3D%22%22%2C_%3Dn%3Bfor(%3B%3B)%7Bif(n%3E%3Dt)%7BN%2B%3Dr.substring(_%2Cn)%2Cc%3D2%3Bbreak%7Dlet%20g%3Dr.charCodeAt(n)%3Bif(g%3D%3D%3D34)%7BN%2B%3Dr.substring(_%2Cn)%2Cn%2B%2B%3Bbreak%7Dif(g%3D%3D%3D92)%7Bif(N%2B%3Dr.substring(_%2Cn)%2Cn%2B%2B%2Cn%3E%3Dt)%7Bc%3D2%3Bbreak%7Dswitch(r.charCodeAt(n%2B%2B))%7Bcase%2034%3AN%2B%3D'%22'%3Bbreak%3Bcase%2092%3AN%2B%3D%22%5C%5C%22%3Bbreak%3Bcase%2047%3AN%2B%3D%22%2F%22%3Bbreak%3Bcase%2098%3AN%2B%3D%22%5Cb%22%3Bbreak%3Bcase%20102%3AN%2B%3D%22%5Cf%22%3Bbreak%3Bcase%20110%3AN%2B%3D%60%0A%60%3Bbreak%3Bcase%20114%3AN%2B%3D%22%5Cr%22%3Bbreak%3Bcase%20116%3AN%2B%3D%22%09%22%3Bbreak%3Bcase%20117%3Alet%20p%3Dd(4%2C!0)%3Bp%3E%3D0%3FN%2B%3DString.fromCharCode(p)%3Ac%3D4%3Bbreak%3Bdefault%3Ac%3D5%7D_%3Dn%3Bcontinue%7Dif(g%3E%3D0%26%26g%3C%3D31)if(q(g))%7BN%2B%3Dr.substring(_%2Cn)%2Cc%3D2%3Bbreak%7Delse%20c%3D6%3Bn%2B%2B%7Dreturn%20N%7Dfunction%20S()%7Bif(i%3D%22%22%2Cc%3D0%2Cs%3Dn%2Cl%3Da%2Cu%3Df%2Cn%3E%3Dt)return%20s%3Dt%2Co%3D17%3Blet%20N%3Dr.charCodeAt(n)%3Bif(Le(N))%7Bdo%20n%2B%2B%2Ci%2B%3DString.fromCharCode(N)%2CN%3Dr.charCodeAt(n)%3Bwhile(Le(N))%3Breturn%20o%3D15%7Dif(q(N))return%20n%2B%2B%2Ci%2B%3DString.fromCharCode(N)%2CN%3D%3D%3D13%26%26r.charCodeAt(n)%3D%3D%3D10%26%26(n%2B%2B%2Ci%2B%3D%60%0A%60)%2Ca%2B%2B%2Cf%3Dn%2Co%3D14%3Bswitch(N)%7Bcase%20123%3Areturn%20n%2B%2B%2Co%3D1%3Bcase%20125%3Areturn%20n%2B%2B%2Co%3D2%3Bcase%2091%3Areturn%20n%2B%2B%2Co%3D3%3Bcase%2093%3Areturn%20n%2B%2B%2Co%3D4%3Bcase%2058%3Areturn%20n%2B%2B%2Co%3D6%3Bcase%2044%3Areturn%20n%2B%2B%2Co%3D5%3Bcase%2034%3Areturn%20n%2B%2B%2Ci%3DL()%2Co%3D10%3Bcase%2047%3Alet%20_%3Dn-1%3Bif(r.charCodeAt(n%2B1)%3D%3D%3D47)%7Bfor(n%2B%3D2%3Bn%3Ct%26%26!q(r.charCodeAt(n))%3B)n%2B%2B%3Breturn%20i%3Dr.substring(_%2Cn)%2Co%3D12%7Dif(r.charCodeAt(n%2B1)%3D%3D%3D42)%7Bn%2B%3D2%3Blet%20g%3Dt-1%2Ch%3D!1%3Bfor(%3Bn%3Cg%3B)%7Blet%20p%3Dr.charCodeAt(n)%3Bif(p%3D%3D%3D42%26%26r.charCodeAt(n%2B1)%3D%3D%3D47)%7Bn%2B%3D2%2Ch%3D!0%3Bbreak%7Dn%2B%2B%2Cq(p)%26%26(p%3D%3D%3D13%26%26r.charCodeAt(n)%3D%3D%3D10%26%26n%2B%2B%2Ca%2B%2B%2Cf%3Dn)%7Dreturn%20h%7C%7C(n%2B%2B%2Cc%3D1)%2Ci%3Dr.substring(_%2Cn)%2Co%3D13%7Dreturn%20i%2B%3DString.fromCharCode(N)%2Cn%2B%2B%2Co%3D16%3Bcase%2045%3Aif(i%2B%3DString.fromCharCode(N)%2Cn%2B%2B%2Cn%3D%3D%3Dt%7C%7C!U(r.charCodeAt(n)))return%20o%3D16%3Bcase%2048%3Acase%2049%3Acase%2050%3Acase%2051%3Acase%2052%3Acase%2053%3Acase%2054%3Acase%2055%3Acase%2056%3Acase%2057%3Areturn%20i%2B%3Dk()%2Co%3D11%3Bdefault%3Afor(%3Bn%3Ct%26%26w(N)%3B)n%2B%2B%2CN%3Dr.charCodeAt(n)%3Bif(s!%3D%3Dn)%7Bswitch(i%3Dr.substring(s%2Cn)%2Ci)%7Bcase%22true%22%3Areturn%20o%3D8%3Bcase%22false%22%3Areturn%20o%3D9%3Bcase%22null%22%3Areturn%20o%3D7%7Dreturn%20o%3D16%7Dreturn%20i%2B%3DString.fromCharCode(N)%2Cn%2B%2B%2Co%3D16%7D%7Dfunction%20w(N)%7Bif(Le(N)%7C%7Cq(N))return!1%3Bswitch(N)%7Bcase%20125%3Acase%2093%3Acase%20123%3Acase%2091%3Acase%2034%3Acase%2058%3Acase%2044%3Acase%2047%3Areturn!1%7Dreturn!0%7Dfunction%20I()%7Blet%20N%3Bdo%20N%3DS()%3Bwhile(N%3E%3D12%26%26N%3C%3D15)%3Breturn%20N%7Dreturn%7BsetPosition%3Ab%2CgetPosition%3A()%3D%3En%2Cscan%3Ae%3FI%3AS%2CgetToken%3A()%3D%3Eo%2CgetTokenValue%3A()%3D%3Ei%2CgetTokenOffset%3A()%3D%3Es%2CgetTokenLength%3A()%3D%3En-s%2CgetTokenStartLine%3A()%3D%3El%2CgetTokenStartCharacter%3A()%3D%3Es-u%2CgetTokenError%3A()%3D%3Ec%7D%7Dfunction%20Le(r)%7Breturn%20r%3D%3D%3D32%7C%7Cr%3D%3D%3D9%7Dfunction%20q(r)%7Breturn%20r%3D%3D%3D10%7C%7Cr%3D%3D%3D13%7Dfunction%20U(r)%7Breturn%20r%3E%3D48%26%26r%3C%3D57%7Dvar%20Qe%3B(function(r)%7Br%5Br.lineFeed%3D10%5D%3D%22lineFeed%22%2Cr%5Br.carriageReturn%3D13%5D%3D%22carriageReturn%22%2Cr%5Br.space%3D32%5D%3D%22space%22%2Cr%5Br._0%3D48%5D%3D%22_0%22%2Cr%5Br._1%3D49%5D%3D%22_1%22%2Cr%5Br._2%3D50%5D%3D%22_2%22%2Cr%5Br._3%3D51%5D%3D%22_3%22%2Cr%5Br._4%3D52%5D%3D%22_4%22%2Cr%5Br._5%3D53%5D%3D%22_5%22%2Cr%5Br._6%3D54%5D%3D%22_6%22%2Cr%5Br._7%3D55%5D%3D%22_7%22%2Cr%5Br._8%3D56%5D%3D%22_8%22%2Cr%5Br._9%3D57%5D%3D%22_9%22%2Cr%5Br.a%3D97%5D%3D%22a%22%2Cr%5Br.b%3D98%5D%3D%22b%22%2Cr%5Br.c%3D99%5D%3D%22c%22%2Cr%5Br.d%3D100%5D%3D%22d%22%2Cr%5Br.e%3D101%5D%3D%22e%22%2Cr%5Br.f%3D102%5D%3D%22f%22%2Cr%5Br.g%3D103%5D%3D%22g%22%2Cr%5Br.h%3D104%5D%3D%22h%22%2Cr%5Br.i%3D105%5D%3D%22i%22%2Cr%5Br.j%3D106%5D%3D%22j%22%2Cr%5Br.k%3D107%5D%3D%22k%22%2Cr%5Br.l%3D108%5D%3D%22l%22%2Cr%5Br.m%3D109%5D%3D%22m%22%2Cr%5Br.n%3D110%5D%3D%22n%22%2Cr%5Br.o%3D111%5D%3D%22o%22%2Cr%5Br.p%3D112%5D%3D%22p%22%2Cr%5Br.q%3D113%5D%3D%22q%22%2Cr%5Br.r%3D114%5D%3D%22r%22%2Cr%5Br.s%3D115%5D%3D%22s%22%2Cr%5Br.t%3D116%5D%3D%22t%22%2Cr%5Br.u%3D117%5D%3D%22u%22%2Cr%5Br.v%3D118%5D%3D%22v%22%2Cr%5Br.w%3D119%5D%3D%22w%22%2Cr%5Br.x%3D120%5D%3D%22x%22%2Cr%5Br.y%3D121%5D%3D%22y%22%2Cr%5Br.z%3D122%5D%3D%22z%22%2Cr%5Br.A%3D65%5D%3D%22A%22%2Cr%5Br.B%3D66%5D%3D%22B%22%2Cr%5Br.C%3D67%5D%3D%22C%22%2Cr%5Br.D%3D68%5D%3D%22D%22%2Cr%5Br.E%3D69%5D%3D%22E%22%2Cr%5Br.F%3D70%5D%3D%22F%22%2Cr%5Br.G%3D71%5D%3D%22G%22%2Cr%5Br.H%3D72%5D%3D%22H%22%2Cr%5Br.I%3D73%5D%3D%22I%22%2Cr%5Br.J%3D74%5D%3D%22J%22%2Cr%5Br.K%3D75%5D%3D%22K%22%2Cr%5Br.L%3D76%5D%3D%22L%22%2Cr%5Br.M%3D77%5D%3D%22M%22%2Cr%5Br.N%3D78%5D%3D%22N%22%2Cr%5Br.O%3D79%5D%3D%22O%22%2Cr%5Br.P%3D80%5D%3D%22P%22%2Cr%5Br.Q%3D81%5D%3D%22Q%22%2Cr%5Br.R%3D82%5D%3D%22R%22%2Cr%5Br.S%3D83%5D%3D%22S%22%2Cr%5Br.T%3D84%5D%3D%22T%22%2Cr%5Br.U%3D85%5D%3D%22U%22%2Cr%5Br.V%3D86%5D%3D%22V%22%2Cr%5Br.W%3D87%5D%3D%22W%22%2Cr%5Br.X%3D88%5D%3D%22X%22%2Cr%5Br.Y%3D89%5D%3D%22Y%22%2Cr%5Br.Z%3D90%5D%3D%22Z%22%2Cr%5Br.asterisk%3D42%5D%3D%22asterisk%22%2Cr%5Br.backslash%3D92%5D%3D%22backslash%22%2Cr%5Br.closeBrace%3D125%5D%3D%22closeBrace%22%2Cr%5Br.closeBracket%3D93%5D%3D%22closeBracket%22%2Cr%5Br.colon%3D58%5D%3D%22colon%22%2Cr%5Br.comma%3D44%5D%3D%22comma%22%2Cr%5Br.dot%3D46%5D%3D%22dot%22%2Cr%5Br.doubleQuote%3D34%5D%3D%22doubleQuote%22%2Cr%5Br.minus%3D45%5D%3D%22minus%22%2Cr%5Br.openBrace%3D123%5D%3D%22openBrace%22%2Cr%5Br.openBracket%3D91%5D%3D%22openBracket%22%2Cr%5Br.plus%3D43%5D%3D%22plus%22%2Cr%5Br.slash%3D47%5D%3D%22slash%22%2Cr%5Br.formFeed%3D12%5D%3D%22formFeed%22%2Cr%5Br.tab%3D9%5D%3D%22tab%22%7D)(Qe%7C%7C(Qe%3D%7B%7D))%3Bvar%20O%3Dnew%20Array(20).fill(0).map((r%2Ce)%3D%3E%22%20%22.repeat(e))%2CJ%3D200%2CSe%3D%7B%22%20%22%3A%7B%22%5Cn%22%3Anew%20Array(J).fill(0).map((r%2Ce)%3D%3E%60%0A%60%2B%22%20%22.repeat(e))%2C%22%5Cr%22%3Anew%20Array(J).fill(0).map((r%2Ce)%3D%3E%22%5Cr%22%2B%22%20%22.repeat(e))%2C%22%5Cr%5Cn%22%3Anew%20Array(J).fill(0).map((r%2Ce)%3D%3E%60%5Cr%0A%60%2B%22%20%22.repeat(e))%7D%2C%22%09%22%3A%7B%22%5Cn%22%3Anew%20Array(J).fill(0).map((r%2Ce)%3D%3E%60%0A%60%2B%22%09%22.repeat(e))%2C%22%5Cr%22%3Anew%20Array(J).fill(0).map((r%2Ce)%3D%3E%22%5Cr%22%2B%22%09%22.repeat(e))%2C%22%5Cr%5Cn%22%3Anew%20Array(J).fill(0).map((r%2Ce)%3D%3E%60%5Cr%0A%60%2B%22%09%22.repeat(e))%7D%7D%2CYe%3D%5B%60%0A%60%2C%22%5Cr%22%2C%60%5Cr%0A%60%5D%3Bfunction%20we(r%2Ce%2Ct)%7Blet%20n%2Ci%2Cs%2Co%2Ca%3Bif(e)%7Bfor(o%3De.offset%2Ca%3Do%2Be.length%2Cs%3Do%3Bs%3E0%26%26!ye(r%2Cs-1)%3B)s--%3Blet%20g%3Da%3Bfor(%3Bg%3Cr.length%26%26!ye(r%2Cg)%3B)g%2B%2B%3Bi%3Dr.substring(s%2Cg)%2Cn%3Dkt(i%2Ct)%7Delse%20i%3Dr%2Cn%3D0%2Cs%3D0%2Co%3D0%2Ca%3Dr.length%3Blet%20l%3DLt(t%2Cr)%2Cf%3DYe.includes(l)%2Cu%3D0%2Cc%3D0%2Cd%3Bt.insertSpaces%3Fd%3DO%5Bt.tabSize%7C%7C4%5D%3F%3Fz(O%5B1%5D%2Ct.tabSize%7C%7C4)%3Ad%3D%22%09%22%3Blet%20b%3Dd%3D%3D%3D%22%09%22%3F%22%09%22%3A%22%20%22%2Ck%3D%24(i%2C!1)%2CL%3D!1%3Bfunction%20S()%7Bif(u%3E1)return%20z(l%2Cu)%2Bz(d%2Cn%2Bc)%3Blet%20g%3Dd.length*(n%2Bc)%3Breturn!f%7C%7Cg%3ESe%5Bb%5D%5Bl%5D.length%3Fl%2Bz(d%2Cn%2Bc)%3Ag%3C%3D0%3Fl%3ASe%5Bb%5D%5Bl%5D%5Bg%5D%7Dfunction%20w()%7Blet%20g%3Dk.scan()%3Bfor(u%3D0%3Bg%3D%3D%3D15%7C%7Cg%3D%3D%3D14%3B)g%3D%3D%3D14%26%26t.keepLines%3Fu%2B%3D1%3Ag%3D%3D%3D14%26%26(u%3D1)%2Cg%3Dk.scan()%3Breturn%20L%3Dg%3D%3D%3D16%7C%7Ck.getTokenError()!%3D%3D0%2Cg%7Dlet%20I%3D%5B%5D%3Bfunction%20N(g%2Ch%2Cp)%7B!L%26%26(!e%7C%7Ch%3Ca%26%26p%3Eo)%26%26r.substring(h%2Cp)!%3D%3Dg%26%26I.push(%7Boffset%3Ah%2Clength%3Ap-h%2Ccontent%3Ag%7D)%7Dlet%20_%3Dw()%3Bif(t.keepLines%26%26u%3E0%26%26N(z(l%2Cu)%2C0%2C0)%2C_!%3D%3D17)%7Blet%20g%3Dk.getTokenOffset()%2Bs%2Ch%3Dd.length*n%3C20%26%26t.insertSpaces%3FO%5Bd.length*n%5D%3Az(d%2Cn)%3BN(h%2Cs%2Cg)%7Dfor(%3B_!%3D%3D17%3B)%7Blet%20g%3Dk.getTokenOffset()%2Bk.getTokenLength()%2Bs%2Ch%3Dw()%2Cp%3D%22%22%2Cy%3D!1%3Bfor(%3Bu%3D%3D%3D0%26%26(h%3D%3D%3D12%7C%7Ch%3D%3D%3D13)%3B)%7Blet%20D%3Dk.getTokenOffset()%2Bs%3BN(O%5B1%5D%2Cg%2CD)%2Cg%3Dk.getTokenOffset()%2Bk.getTokenLength()%2Bs%2Cy%3Dh%3D%3D%3D12%2Cp%3Dy%3FS()%3A%22%22%2Ch%3Dw()%7Dif(h%3D%3D%3D2)_!%3D%3D1%26%26c--%2Ct.keepLines%26%26u%3E0%7C%7C!t.keepLines%26%26_!%3D%3D1%3Fp%3DS()%3At.keepLines%26%26(p%3DO%5B1%5D)%3Belse%20if(h%3D%3D%3D4)_!%3D%3D3%26%26c--%2Ct.keepLines%26%26u%3E0%7C%7C!t.keepLines%26%26_!%3D%3D3%3Fp%3DS()%3At.keepLines%26%26(p%3DO%5B1%5D)%3Belse%7Bswitch(_)%7Bcase%203%3Acase%201%3Ac%2B%2B%2Ct.keepLines%26%26u%3E0%7C%7C!t.keepLines%3Fp%3DS()%3Ap%3DO%5B1%5D%3Bbreak%3Bcase%205%3At.keepLines%26%26u%3E0%7C%7C!t.keepLines%3Fp%3DS()%3Ap%3DO%5B1%5D%3Bbreak%3Bcase%2012%3Ap%3DS()%3Bbreak%3Bcase%2013%3Au%3E0%3Fp%3DS()%3Ay%7C%7C(p%3DO%5B1%5D)%3Bbreak%3Bcase%206%3At.keepLines%26%26u%3E0%3Fp%3DS()%3Ay%7C%7C(p%3DO%5B1%5D)%3Bbreak%3Bcase%2010%3At.keepLines%26%26u%3E0%3Fp%3DS()%3Ah%3D%3D%3D6%26%26!y%26%26(p%3D%22%22)%3Bbreak%3Bcase%207%3Acase%208%3Acase%209%3Acase%2011%3Acase%202%3Acase%204%3At.keepLines%26%26u%3E0%3Fp%3DS()%3A(h%3D%3D%3D12%7C%7Ch%3D%3D%3D13)%26%26!y%3Fp%3DO%5B1%5D%3Ah!%3D%3D5%26%26h!%3D%3D17%26%26(L%3D!0)%3Bbreak%3Bcase%2016%3AL%3D!0%3Bbreak%7Du%3E0%26%26(h%3D%3D%3D12%7C%7Ch%3D%3D%3D13)%26%26(p%3DS())%7Dh%3D%3D%3D17%26%26(t.keepLines%26%26u%3E0%3Fp%3DS()%3Ap%3Dt.insertFinalNewline%3Fl%3A%22%22)%3Blet%20x%3Dk.getTokenOffset()%2Bs%3BN(p%2Cg%2Cx)%2C_%3Dh%7Dreturn%20I%7Dfunction%20z(r%2Ce)%7Blet%20t%3D%22%22%3Bfor(let%20n%3D0%3Bn%3Ce%3Bn%2B%2B)t%2B%3Dr%3Breturn%20t%7Dfunction%20kt(r%2Ce)%7Blet%20t%3D0%2Cn%3D0%2Ci%3De.tabSize%7C%7C4%3Bfor(%3Bt%3Cr.length%3B)%7Blet%20s%3Dr.charAt(t)%3Bif(s%3D%3D%3DO%5B1%5D)n%2B%2B%3Belse%20if(s%3D%3D%3D%22%09%22)n%2B%3Di%3Belse%20break%3Bt%2B%2B%7Dreturn%20Math.floor(n%2Fi)%7Dfunction%20Lt(r%2Ce)%7Bfor(let%20t%3D0%3Bt%3Ce.length%3Bt%2B%2B)%7Blet%20n%3De.charAt(t)%3Bif(n%3D%3D%3D%22%5Cr%22)return%20t%2B1%3Ce.length%26%26e.charAt(t%2B1)%3D%3D%3D%60%0A%60%3F%60%5Cr%0A%60%3A%22%5Cr%22%3Bif(n%3D%3D%3D%60%0A%60)return%60%0A%60%7Dreturn%20r%26%26r.eol%7C%7C%60%0A%60%7Dfunction%20ye(r%2Ce)%7Breturn%60%5Cr%0A%60.indexOf(r.charAt(e))!%3D%3D-1%7Dvar%20et%3B(function(r)%7Br.DEFAULT%3D%7BallowTrailingComma%3A!1%7D%7D)(et%7C%7C(et%3D%7B%7D))%3Bfunction%20yt(r%2Ce%2Ct%3D!1)%7Breturn%20e%3E%3Dr.offset%26%26e%3Cr.offset%2Br.length%7C%7Ct%26%26e%3D%3D%3Dr.offset%2Br.length%7Dfunction%20ve(r%2Ce%2Ct%3D!1)%7Bif(yt(r%2Ce%2Ct))%7Blet%20n%3Dr.children%3Bif(Array.isArray(n))for(let%20i%3D0%3Bi%3Cn.length%26%26n%5Bi%5D.offset%3C%3De%3Bi%2B%2B)%7Blet%20s%3Dve(n%5Bi%5D%2Ce%2Ct)%3Bif(s)return%20s%7Dreturn%20r%7D%7Dvar%20se%3D%24%2CB%3B(function(r)%7Br%5Br.None%3D0%5D%3D%22None%22%2Cr%5Br.UnexpectedEndOfComment%3D1%5D%3D%22UnexpectedEndOfComment%22%2Cr%5Br.UnexpectedEndOfString%3D2%5D%3D%22UnexpectedEndOfString%22%2Cr%5Br.UnexpectedEndOfNumber%3D3%5D%3D%22UnexpectedEndOfNumber%22%2Cr%5Br.InvalidUnicode%3D4%5D%3D%22InvalidUnicode%22%2Cr%5Br.InvalidEscapeCharacter%3D5%5D%3D%22InvalidEscapeCharacter%22%2Cr%5Br.InvalidCharacter%3D6%5D%3D%22InvalidCharacter%22%7D)(B%7C%7C(B%3D%7B%7D))%3Bvar%20T%3B(function(r)%7Br%5Br.OpenBraceToken%3D1%5D%3D%22OpenBraceToken%22%2Cr%5Br.CloseBraceToken%3D2%5D%3D%22CloseBraceToken%22%2Cr%5Br.OpenBracketToken%3D3%5D%3D%22OpenBracketToken%22%2Cr%5Br.CloseBracketToken%3D4%5D%3D%22CloseBracketToken%22%2Cr%5Br.CommaToken%3D5%5D%3D%22CommaToken%22%2Cr%5Br.ColonToken%3D6%5D%3D%22ColonToken%22%2Cr%5Br.NullKeyword%3D7%5D%3D%22NullKeyword%22%2Cr%5Br.TrueKeyword%3D8%5D%3D%22TrueKeyword%22%2Cr%5Br.FalseKeyword%3D9%5D%3D%22FalseKeyword%22%2Cr%5Br.StringLiteral%3D10%5D%3D%22StringLiteral%22%2Cr%5Br.NumericLiteral%3D11%5D%3D%22NumericLiteral%22%2Cr%5Br.LineCommentTrivia%3D12%5D%3D%22LineCommentTrivia%22%2Cr%5Br.BlockCommentTrivia%3D13%5D%3D%22BlockCommentTrivia%22%2Cr%5Br.LineBreakTrivia%3D14%5D%3D%22LineBreakTrivia%22%2Cr%5Br.Trivia%3D15%5D%3D%22Trivia%22%2Cr%5Br.Unknown%3D16%5D%3D%22Unknown%22%2Cr%5Br.EOF%3D17%5D%3D%22EOF%22%7D)(T%7C%7C(T%3D%7B%7D))%3Bvar%20nt%3Dve%3Bvar%20tt%3B(function(r)%7Br%5Br.InvalidSymbol%3D1%5D%3D%22InvalidSymbol%22%2Cr%5Br.InvalidNumberFormat%3D2%5D%3D%22InvalidNumberFormat%22%2Cr%5Br.PropertyNameExpected%3D3%5D%3D%22PropertyNameExpected%22%2Cr%5Br.ValueExpected%3D4%5D%3D%22ValueExpected%22%2Cr%5Br.ColonExpected%3D5%5D%3D%22ColonExpected%22%2Cr%5Br.CommaExpected%3D6%5D%3D%22CommaExpected%22%2Cr%5Br.CloseBraceExpected%3D7%5D%3D%22CloseBraceExpected%22%2Cr%5Br.CloseBracketExpected%3D8%5D%3D%22CloseBracketExpected%22%2Cr%5Br.EndOfFileExpected%3D9%5D%3D%22EndOfFileExpected%22%2Cr%5Br.InvalidCommentToken%3D10%5D%3D%22InvalidCommentToken%22%2Cr%5Br.UnexpectedEndOfComment%3D11%5D%3D%22UnexpectedEndOfComment%22%2Cr%5Br.UnexpectedEndOfString%3D12%5D%3D%22UnexpectedEndOfString%22%2Cr%5Br.UnexpectedEndOfNumber%3D13%5D%3D%22UnexpectedEndOfNumber%22%2Cr%5Br.InvalidUnicode%3D14%5D%3D%22InvalidUnicode%22%2Cr%5Br.InvalidEscapeCharacter%3D15%5D%3D%22InvalidEscapeCharacter%22%2Cr%5Br.InvalidCharacter%3D16%5D%3D%22InvalidCharacter%22%7D)(tt%7C%7C(tt%3D%7B%7D))%3Bfunction%20rt(r%2Ce%2Ct)%7Breturn%20we(r%2Ce%2Ct)%7Dvar%20oe%3Dclass%20r%7Bconstructor(e%2Ct%2Cn)%7Bthis.message%3De%2Cthis.code%3Dt%2Cthis.range%3Dn%7Dstatic%20create(e%2Ct%2Cn)%7Breturn%20new%20r(e%2Ct%2Cn)%7D%7D%2Cle%3Dclass%20r%7Bconstructor(e%2Ct)%7Bthis.start%3De%2Cthis.end%3Dt%7Dstatic%20create(e%2Ct)%7Breturn%20new%20r(e%2Ct)%7D%7D%2CBt%3B(x%3D%3E(x.Text%3D1%2Cx.Method%3D2%2Cx.Function%3D3%2Cx.Constructor%3D4%2Cx.Field%3D5%2Cx.Variable%3D6%2Cx.Class%3D7%2Cx.Interface%3D8%2Cx.Module%3D9%2Cx.Property%3D10%2Cx.Unit%3D11%2Cx.Value%3D12%2Cx.Enum%3D13%2Cx.Keyword%3D14%2Cx.Snippet%3D15%2Cx.Color%3D16%2Cx.File%3D17%2Cx.Reference%3D18%2Cx.Folder%3D19%2Cx.EnumMember%3D20%2Cx.Constant%3D21%2Cx.Struct%3D22%2Cx.Event%3D23%2Cx.Operator%3D24%2Cx.TypeParameter%3D25))(Bt%7C%7C%3D%7B%7D)%3Bvar%20Ct%3B(t%3D%3E(t.PlainText%3D1%2Ct.Snippet%3D2))(Ct%7C%7C%3D%7B%7D)%3Bvar%20Et%3B(e%3D%3E%7Bfunction%20r(t%2Cn)%7Breturn%7Brange%3At%2CnewText%3An%7D%7De.replace%3Dr%7D)(Et%7C%7C%3D%7B%7D)%3Bvar%20Mt%3B(e%3D%3E%7Bfunction%20r(t)%7Breturn%7Blabel%3At%7D%7De.create%3Dr%7D)(Mt%7C%7C%3D%7B%7D)%3Bfunction%20it(r)%7Breturn%20typeof%20r%3D%3D%22object%22%26%26r!%3D%3Dnull%26%26!Array.isArray(r)%7Dfunction%20st(r)%7Breturn%20typeof%20r%3D%3D%22number%22%7Dvar%20F%3Dclass%7Bconstructor(e%2Ct%2Cn%3D0)%7Bthis.offset%3Dt%2Cthis.length%3Dn%2Cthis.parent%3De%7Dget%20children()%7Breturn%5B%5D%7DtoString()%7Breturn%22type%3A%20%22%2Bthis.type%2B%22%20(%22%2Bthis.offset%2B%22%2F%22%2Bthis.length%2B%22)%22%2B(this.parent%3F%22%20parent%3A%20%7B%22%2Bthis.parent.toString()%2B%22%7D%22%3A%22%22)%7D%7D%2CIe%3Dclass%20extends%20F%7Bconstructor(t%2Cn)%7Bsuper(t%2Cn)%3Bthis.type%3D%22null%22%3Bthis.value%3Dnull%7D%7D%2Cae%3Dclass%20extends%20F%7Bconstructor(t%2Cn%2Ci)%7Bsuper(t%2Ci)%3Bthis.type%3D%22boolean%22%3Bthis.value%3Dn%7D%7D%2COe%3Dclass%20extends%20F%7Bconstructor(t%2Cn)%7Bsuper(t%2Cn)%3Bthis.type%3D%22array%22%3Bthis.items%3D%5B%5D%7Dget%20children()%7Breturn%20this.items%7D%7D%2CAe%3Dclass%20extends%20F%7Bconstructor(t%2Cn)%7Bsuper(t%2Cn)%3Bthis.type%3D%22number%22%3Bthis.isInteger%3D!0%2Cthis.value%3DNumber.NaN%7D%7D%2CBe%3Dclass%20extends%20F%7Bconstructor(t%2Cn)%7Bsuper(t%2Cn)%3Bthis.type%3D%22object%22%3Bthis.properties%3D%5B%5D%7Dget%20children()%7Breturn%20this.properties%7D%7D%2CX%3Dclass%20extends%20F%7Bconstructor(t%2Cn%2Ci)%7Bsuper(t%2Cn%2Ci)%3Bthis.type%3D%22string%22%3Bthis.value%3D%22%22%7D%7D%2CCe%3Dclass%20extends%20F%7Bconstructor(t%2Cn%2Ci)%7Bsuper(t%2Cn)%3Bthis.type%3D%22property%22%3Bthis.colonOffset%3D-1%2Cthis.keyNode%3Di%7Dget%20children()%7Breturn%20this.valueNode%3F%5Bthis.keyNode%2Cthis.valueNode%5D%3A%5Bthis.keyNode%5D%7D%7D%2CEe%3Dclass%7Bconstructor(e)%7Bthis.root%3De%7DgetNodeFromOffset(e%2Ct%3D!1)%7Bif(this.root)return%20nt(this.root%2Ce%2Ct)%7Dvisit(e)%7Bif(this.root)%7Blet%20t%3Dn%3D%3E%7Blet%20i%3De(n)%2Cs%3Dn.children%3Bif(Array.isArray(s))for(let%20o%3D0%3Bo%3Cs.length%26%26i%3Bo%2B%2B)i%3Dt(s%5Bo%5D)%3Breturn%20i%7D%3Bt(this.root)%7D%7D%7D%3Bfunction%20Me(r)%7Blet%20e%3D%5B%5D%2Ct%3D-1%2Cn%3Dr.getValue()%2Ci%3Dse(n%2C!1)%3Bfunction%20s()%7Bfor(%3B%3B)%7Blet%20_%3Di.scan()%3Bswitch(o()%2C_)%7Bcase%20T.LineBreakTrivia%3Acase%20T.Trivia%3Abreak%3Bdefault%3Areturn%20_%7D%7D%7Dfunction%20o()%7Bswitch(i.getTokenError())%7Bcase%20B.InvalidUnicode%3Areturn%20f(%22Invalid%20unicode%20sequence%20in%20string.%22%2C260)%2C!0%3Bcase%20B.InvalidEscapeCharacter%3Areturn%20f(%22Invalid%20escape%20character%20in%20string.%22%2C261)%2C!0%3Bcase%20B.UnexpectedEndOfNumber%3Areturn%20f(%22Unexpected%20end%20of%20number.%22%2C259)%2C!0%3Bcase%20B.UnexpectedEndOfComment%3Areturn%20f(%22Unexpected%20end%20of%20comment.%22%2C257)%2C!0%3Bcase%20B.UnexpectedEndOfString%3Areturn%20f(%22Unexpected%20end%20of%20string.%22%2C258)%2C!0%3Bcase%20B.InvalidCharacter%3Areturn%20f(%22Invalid%20characters%20in%20string.%20Control%20characters%20must%20be%20escaped.%22%2C262)%2C!0%7Dreturn!1%7Dfunction%20a(_%2Cg%2Ch%2Cp)%7Bif(e.length%3D%3D%3D0%7C%7Ch!%3D%3Dt)%7Blet%20y%3Dle.create(r.positionAt(h)%2Cr.positionAt(p))%3Be.push(oe.create(_%2Cg%2Cy))%2Ct%3Dh%7D%7Dfunction%20l(_%2Cg)%7Breturn%20_.length%3Di.getTokenOffset()%2Bi.getTokenLength()-_.offset%2Cg%26%26s()%2C_%7Dfunction%20f(_%2Cg%2Ch%3Dvoid%200%2Cp%3D%5B%5D%2Cy%3D%5B%5D)%7Blet%20x%3Di.getTokenOffset()%2CD%3Di.getTokenOffset()%2Bi.getTokenLength()%3Bif(x%3D%3D%3DD%26%26x%3E0)%7Bfor(x--%3Bx%3E0%26%26%2F%5Cs%2F.test(n.charAt(x))%3B)x--%3BD%3Dx%2B1%7Dif(a(_%2Cg%2Cx%2CD)%2Ch%26%26l(h%2C!1)%2Cp.length%2By.length%3E0)%7Blet%20ie%3Di.getToken()%3Bfor(%3Bie!%3D%3DT.EOF%3B)%7Bif(p.indexOf(ie)!%3D%3D-1)%7Bs()%3Bbreak%7Delse%20if(y.indexOf(ie)!%3D%3D-1)break%3Bie%3Ds()%7D%7Dreturn%20h%7Dfunction%20u(_)%7Bif(i.getToken()!%3D%3DT.OpenBracketToken)return%3Blet%20g%3Dnew%20Oe(_%2Ci.getTokenOffset())%3Bs()%3Blet%20h%3D!1%3Bfor(%3Bi.getToken()!%3D%3DT.CloseBracketToken%26%26i.getToken()!%3D%3DT.EOF%3B)%7Bif(i.getToken()%3D%3D%3DT.CommaToken)%7Bh%7C%7Cf(%22Value%20expected.%22%2C516)%3Blet%20y%3Di.getTokenOffset()%3Bif(s()%2Ci.getToken()%3D%3D%3DT.CloseBracketToken)%7Bh%26%26a(%22Trailing%20comma%22%2C519%2Cy%2Cy%2B1)%3Bcontinue%7D%7Delse%20if(h)%7Bf(%22Comma%20expected.%22%2C514%2Cvoid%200%2C%5B%5D%2C%5BT.CloseBracketToken%5D)%3Bbreak%7Dlet%20p%3Dw(g)%3Bif(p)g.items.push(p)%3Belse%7Bf(%22Value%20expected.%22%2C516%2Cvoid%200%2C%5B%5D%2C%5BT.CloseBracketToken%5D)%3Bbreak%7Dh%3D!0%7Dreturn%20i.getToken()!%3D%3DT.CloseBracketToken%3Ff(%22Expected%20comma%20or%20closing%20bracket%22%2C518%2Cg)%3Al(g%2C!0)%7Dlet%20c%3Dnew%20X(void%200%2C0%2C0)%3Bfunction%20d(_%2Cg)%7Blet%20h%3Dnew%20Ce(_%2Ci.getTokenOffset()%2Cc)%2Cp%3Dk(h)%3Bif(!p)if(i.getToken()%3D%3D%3DT.Unknown)%7Bf(%22Property%20keys%20must%20be%20doublequoted%22%2C528)%3Blet%20x%3Dnew%20X(h%2Ci.getTokenOffset()%2Ci.getTokenLength())%3Bx.value%3Di.getTokenValue()%2Cp%3Dx%2Cs()%7Delse%20return%3Bif(h.keyNode%3Dp%2Cp.value!%3D%3D%22%2F%2F%22)%7Blet%20x%3Dg%5Bp.value%5D%3Bx%3F(a(%22Duplicate%20object%20key%22%2C520%2Ch.keyNode.offset%2Ch.keyNode.offset%2Bh.keyNode.length)%2Cit(x)%26%26a(%22Duplicate%20object%20key%22%2C520%2Cx.keyNode.offset%2Cx.keyNode.offset%2Bx.keyNode.length)%2Cg%5Bp.value%5D%3D!0)%3Ag%5Bp.value%5D%3Dh%7Dif(i.getToken()%3D%3D%3DT.ColonToken)h.colonOffset%3Di.getTokenOffset()%2Cs()%3Belse%20if(f(%22Colon%20expected%22%2C515)%2Ci.getToken()%3D%3D%3DT.StringLiteral%26%26r.positionAt(p.offset%2Bp.length).lineNumber%3Cr.positionAt(i.getTokenOffset()).lineNumber)return%20h.length%3Dp.length%2Ch%3Blet%20y%3Dw(h)%3Breturn%20y%3F(h.valueNode%3Dy%2Ch.length%3Dy.offset%2By.length-h.offset%2Ch)%3Af(%22Value%20expected%22%2C516%2Ch%2C%5B%5D%2C%5BT.CloseBraceToken%2CT.CommaToken%5D)%7Dfunction%20b(_)%7Bif(i.getToken()!%3D%3DT.OpenBraceToken)return%3Blet%20g%3Dnew%20Be(_%2Ci.getTokenOffset())%2Ch%3DObject.create(null)%3Bs()%3Blet%20p%3D!1%3Bfor(%3Bi.getToken()!%3D%3DT.CloseBraceToken%26%26i.getToken()!%3D%3DT.EOF%3B)%7Bif(i.getToken()%3D%3D%3DT.CommaToken)%7Bp%7C%7Cf(%22Property%20expected%22%2C513)%3Blet%20x%3Di.getTokenOffset()%3Bif(s()%2Ci.getToken()%3D%3D%3DT.CloseBraceToken)%7Bp%26%26a(%22Trailing%20comma%22%2C519%2Cx%2Cx%2B1)%3Bcontinue%7D%7Delse%20p%26%26f(%22Expected%20comma%22%2C514)%3Blet%20y%3Dd(g%2Ch)%3By%3Fg.properties.push(y)%3Af(%22Property%20expected%22%2C513%2Cvoid%200%2C%5B%5D%2C%5BT.CloseBraceToken%2CT.CommaToken%5D)%2Cp%3D!0%7Dreturn%20i.getToken()!%3D%3DT.CloseBraceToken%3Ff(%22Expected%20comma%20or%20closing%20brace%22%2C518%2Cg)%3Al(g%2C!0)%7Dfunction%20k(_)%7Bif(i.getToken()!%3D%3DT.StringLiteral)return%3Blet%20g%3Dnew%20X(_%2Ci.getTokenOffset())%3Breturn%20g.value%3Di.getTokenValue()%2Cl(g%2C!0)%7Dfunction%20L(_)%7Bif(i.getToken()!%3D%3DT.NumericLiteral)return%3Blet%20g%3Dnew%20Ae(_%2Ci.getTokenOffset())%3Bif(i.getTokenError()%3D%3D%3DB.None)%7Blet%20h%3Di.getTokenValue()%3Btry%7Blet%20p%3DJSON.parse(h)%3Bif(!st(p))return%20f(%22Invalid%20number%20format.%22%2C0%2Cg)%3Bg.value%3Dp%7Dcatch%7Breturn%20f(%22Invalid%20number%20format.%22%2C0%2Cg)%7Dg.isInteger%3Dh.indexOf(%22.%22)%3D%3D%3D-1%7Dreturn%20l(g%2C!0)%7Dfunction%20S(_)%7Blet%20g%3Bswitch(i.getToken())%7Bcase%20T.NullKeyword%3Areturn%20l(new%20Ie(_%2Ci.getTokenOffset())%2C!0)%3Bcase%20T.TrueKeyword%3Areturn%20l(new%20ae(_%2C!0%2Ci.getTokenOffset())%2C!0)%3Bcase%20T.FalseKeyword%3Areturn%20l(new%20ae(_%2C!1%2Ci.getTokenOffset())%2C!0)%3Bdefault%3Areturn%7D%7Dfunction%20w(_)%7Breturn%20u(_)%7C%7Cb(_)%7C%7Ck(_)%7C%7CL(_)%7C%7CS(_)%7Dlet%20I%3Breturn%20s()!%3D%3DT.EOF%26%26(I%3Dw(I)%2CI%3Fi.getToken()!%3D%3DT.EOF%26%26f(%22End%20of%20file%20expected.%22%2C0)%3Af(%22Expected%20a%20JSON%20object%2C%20array%20or%20literal%22%2C0))%2C%7Bproblems%3Ae%2Croot%3Anew%20Ee(I)%7D%7Dfunction%20Fe(r)%7Blet%20e%3D%5B%5D%2Ct%3D%5B%5D%2Cn%3D-1%2Ci%3Dse(r.getValue()%2C!1)%2Cs%3Di.scan()%3Bfunction%20o(a)%7Be.push(a)%7Dfor(%3Bs!%3D%3DT.EOF%3B)%7Bswitch(s)%7Bcase%20T.OpenBraceToken%3Acase%20T.OpenBracketToken%3A%7Blet%20l%3D%7BstartLineNumber%3Ar.positionAt(i.getPosition()).lineNumber%2Ctype%3As%3D%3D%3DT.OpenBraceToken%3F%22object%22%3A%22array%22%7D%3Bt.push(l)%3Bbreak%7Dcase%20T.CloseBraceToken%3Acase%20T.CloseBracketToken%3A%7Blet%20a%3Ds%3D%3D%3DT.CloseBraceToken%3F%22object%22%3A%22array%22%3Bif(t.length%3E0%26%26t%5Bt.length-1%5D.type%3D%3D%3Da)%7Blet%20l%3Dt.pop()%2Cf%3Dr.positionAt(i.getTokenOffset()).lineNumber%3Bif(l%26%26f%3El.startLineNumber%2B1%26%26n!%3D%3Dl.startLineNumber)%7Blet%20u%3D%7BstartLineNumber%3Al.startLineNumber%2CendLineNumber%3Af-1%2Ctype%3Al.type%2CisCollapsed%3A!1%2Csource%3A0%7D%3Bo(u)%2Cn%3Dl.startLineNumber%7D%7Dbreak%7D%7Ds%3Di.scan()%7Dreturn%20e%7Dfunction%20ot(r%2Ce)%7Breturn%20rt(r.getValue()%2Cvoid%200%2Ce)%7Dfunction%20lt(r)%7Blet%7Broot%3Ae%2Cproblems%3At%7D%3DMe(r)%3Breturn%7Bproblems%3At%2Croot%3Ae%7D%7Dfunction%20at(r)%7Breturn%20Me(r).root%7Dvar%20P%3Dclass%7Bconstructor(e%2Ct)%7Bthis.lineNumber%3De%2Cthis.column%3Dt%7D%7D%3Bvar%20A%3Dclass%20r%7Bconstructor(e%2Ct%2Cn%2Ci)%7Be%3En%7C%7Ce%3D%3D%3Dn%26%26t%3Ei%3F(this.startLineNumber%3Dn%2Cthis.startColumn%3Di%2Cthis.endLineNumber%3De%2Cthis.endColumn%3Dt)%3A(this.startLineNumber%3De%2Cthis.startColumn%3Dt%2Cthis.endLineNumber%3Dn%2Cthis.endColumn%3Di)%7Dstatic%20create(e%2Ct)%7Breturn%20new%20r(e.lineNumber%2Ce.column%2Ct.lineNumber%2Ct.column)%7Dstatic%20areIntersecting(e%2Ct)%7Breturn!(e.endLineNumber%3Ct.startLineNumber%7C%7Ce.endLineNumber%3D%3D%3Dt.startLineNumber%26%26e.endColumn%3C%3Dt.startColumn%7C%7Ct.endLineNumber%3Ce.startLineNumber%7C%7Ct.endLineNumber%3D%3D%3De.startLineNumber%26%26t.endColumn%3C%3De.startColumn)%7DplusRange(e)%7Breturn%20r.plusRange(this%2Ce)%7Dstatic%20plusRange(e%2Ct)%7Blet%20n%2Ci%2Cs%2Co%3Breturn%20t.startLineNumber%3Ce.startLineNumber%3F(n%3Dt.startLineNumber%2Ci%3Dt.startColumn)%3At.startLineNumber%3D%3D%3De.startLineNumber%3F(n%3Dt.startLineNumber%2Ci%3DMath.min(t.startColumn%2Ce.startColumn))%3A(n%3De.startLineNumber%2Ci%3De.startColumn)%2Ct.endLineNumber%3Ee.endLineNumber%3F(s%3Dt.endLineNumber%2Co%3Dt.endColumn)%3At.endLineNumber%3D%3D%3De.endLineNumber%3F(s%3Dt.endLineNumber%2Co%3DMath.max(t.endColumn%2Ce.endColumn))%3A(s%3De.endLineNumber%2Co%3De.endColumn)%2Cnew%20r(n%2Ci%2Cs%2Co)%7DgetStartPosition()%7Breturn%20r.getStartPosition(this)%7Dstatic%20getStartPosition(e)%7Breturn%20new%20P(e.startLineNumber%2Ce.startColumn)%7D%7D%3Bvar%20V%3Dclass%7Bconstructor(e%2Ct)%7Bthis._findMatchBrand%3Dvoid%200%3Bthis.range%3De%2Cthis.matches%3Dt%7D%7D%2Cfe%3Dclass%7Bconstructor(e%2Ct%2Cn)%7Bthis.regex%3De%2Cthis.wordSeparators%3Dt%2Cthis.simpleSearch%3Dn%7D%7D%3Bvar%20j%3Dclass%7Bconstructor(e%2Ct)%7Bthis.piece%3De%2Cthis.color%3Dt%2Cthis.size_left%3D0%2Cthis.lf_left%3D0%2Cthis.parent%3Dthis%2Cthis.left%3Dthis%2Cthis.right%3Dthis%7Dnext()%7Bif(this.right!%3D%3Dm)return%20ue(this.right)%3Blet%20e%3Dthis%3Bfor(%3Be.parent!%3D%3Dm%26%26e.parent.left!%3D%3De%3B)e%3De.parent%3Breturn%20e.parent%3D%3D%3Dm%3Fm%3Ae.parent%7Dprev()%7Bif(this.left!%3D%3Dm)return%20Re(this.left)%3Blet%20e%3Dthis%3Bfor(%3Be.parent!%3D%3Dm%26%26e.parent.right!%3D%3De%3B)e%3De.parent%3Breturn%20e.parent%3D%3D%3Dm%3Fm%3Ae.parent%7Ddetach()%7Bthis.parent%3Dnull%2Cthis.left%3Dnull%2Cthis.right%3Dnull%7D%7D%3Bvar%20m%3Dnew%20j(null%2C0)%3Bm.parent%3Dm%3Bm.left%3Dm%3Bm.right%3Dm%3Bm.color%3D0%3Bfunction%20ue(r)%7Bfor(%3Br.left!%3D%3Dm%3B)r%3Dr.left%3Breturn%20r%7Dfunction%20Re(r)%7Bfor(%3Br.right!%3D%3Dm%3B)r%3Dr.right%3Breturn%20r%7Dfunction%20Ve(r)%7Breturn%20r%3D%3D%3Dm%3F0%3Ar.size_left%2Br.piece.length%2BVe(r.right)%7Dfunction%20We(r)%7Breturn%20r%3D%3D%3Dm%3F0%3Ar.lf_left%2Br.piece.lineFeedCnt%2BWe(r.right)%7Dfunction%20Pe()%7Bm.parent%3Dm%7Dfunction%20G(r%2Ce)%7Blet%20t%3De.right%3Bt.size_left%2B%3De.size_left%2B(e.piece%3Fe.piece.length%3A0)%2Ct.lf_left%2B%3De.lf_left%2B(e.piece%3Fe.piece.lineFeedCnt%3A0)%2Ce.right%3Dt.left%2Ct.left!%3D%3Dm%26%26(t.left.parent%3De)%2Ct.parent%3De.parent%2Ce.parent%3D%3D%3Dm%3Fr.root%3Dt%3Ae.parent.left%3D%3D%3De%3Fe.parent.left%3Dt%3Ae.parent.right%3Dt%2Ct.left%3De%2Ce.parent%3Dt%7Dfunction%20Z(r%2Ce)%7Blet%20t%3De.left%3Be.left%3Dt.right%2Ct.right!%3D%3Dm%26%26(t.right.parent%3De)%2Ct.parent%3De.parent%2Ce.size_left-%3Dt.size_left%2B(t.piece%3Ft.piece.length%3A0)%2Ce.lf_left-%3Dt.lf_left%2B(t.piece%3Ft.piece.lineFeedCnt%3A0)%2Ce.parent%3D%3D%3Dm%3Fr.root%3Dt%3Ae%3D%3D%3De.parent.right%3Fe.parent.right%3Dt%3Ae.parent.left%3Dt%2Ct.right%3De%2Ce.parent%3Dt%7Dfunction%20Q(r%2Ce)%7Blet%20t%2Cn%3Bif(e.left%3D%3D%3Dm%3F(n%3De%2Ct%3Dn.right)%3Ae.right%3D%3D%3Dm%3F(n%3De%2Ct%3Dn.left)%3A(n%3Due(e.right)%2Ct%3Dn.right)%2Cn%3D%3D%3Dr.root)%7Br.root%3Dt%2Ct.color%3D0%2Ce.detach()%2CPe()%2Cr.root.parent%3Dm%3Breturn%7Dlet%20i%3Dn.color%3D%3D%3D1%3Bif(n%3D%3D%3Dn.parent.left%3Fn.parent.left%3Dt%3An.parent.right%3Dt%2Cn%3D%3D%3De%3F(t.parent%3Dn.parent%2CH(r%2Ct))%3A(n.parent%3D%3D%3De%3Ft.parent%3Dn%3At.parent%3Dn.parent%2CH(r%2Ct)%2Cn.left%3De.left%2Cn.right%3De.right%2Cn.parent%3De.parent%2Cn.color%3De.color%2Ce%3D%3D%3Dr.root%3Fr.root%3Dn%3Ae%3D%3D%3De.parent.left%3Fe.parent.left%3Dn%3Ae.parent.right%3Dn%2Cn.left!%3D%3Dm%26%26(n.left.parent%3Dn)%2Cn.right!%3D%3Dm%26%26(n.right.parent%3Dn)%2Cn.size_left%3De.size_left%2Cn.lf_left%3De.lf_left%2CH(r%2Cn))%2Ce.detach()%2Ct.parent.left%3D%3D%3Dt)%7Blet%20o%3DVe(t)%2Ca%3DWe(t)%3Bif(o!%3D%3Dt.parent.size_left%7C%7Ca!%3D%3Dt.parent.lf_left)%7Blet%20l%3Do-t.parent.size_left%2Cf%3Da-t.parent.lf_left%3Bt.parent.size_left%3Do%2Ct.parent.lf_left%3Da%2CC(r%2Ct.parent%2Cl%2Cf)%7D%7Dif(H(r%2Ct.parent)%2Ci)%7BPe()%3Breturn%7Dlet%20s%3Bfor(%3Bt!%3D%3Dr.root%26%26t.color%3D%3D%3D0%3B)t%3D%3D%3Dt.parent.left%3F(s%3Dt.parent.right%2Cs.color%3D%3D%3D1%26%26(s.color%3D0%2Ct.parent.color%3D1%2CG(r%2Ct.parent)%2Cs%3Dt.parent.right)%2Cs.left.color%3D%3D%3D0%26%26s.right.color%3D%3D%3D0%3F(s.color%3D1%2Ct%3Dt.parent)%3A(s.right.color%3D%3D%3D0%26%26(s.left.color%3D0%2Cs.color%3D1%2CZ(r%2Cs)%2Cs%3Dt.parent.right)%2Cs.color%3Dt.parent.color%2Ct.parent.color%3D0%2Cs.right.color%3D0%2CG(r%2Ct.parent)%2Ct%3Dr.root))%3A(s%3Dt.parent.left%2Cs.color%3D%3D%3D1%26%26(s.color%3D0%2Ct.parent.color%3D1%2CZ(r%2Ct.parent)%2Cs%3Dt.parent.left)%2Cs.left.color%3D%3D%3D0%26%26s.right.color%3D%3D%3D0%3F(s.color%3D1%2Ct%3Dt.parent)%3A(s.left.color%3D%3D%3D0%26%26(s.right.color%3D0%2Cs.color%3D1%2CG(r%2Cs)%2Cs%3Dt.parent.left)%2Cs.color%3Dt.parent.color%2Ct.parent.color%3D0%2Cs.left.color%3D0%2CZ(r%2Ct.parent)%2Ct%3Dr.root))%3Bt.color%3D0%2CPe()%7Dfunction%20Ue(r%2Ce)%7Bfor(H(r%2Ce)%3Be!%3D%3Dr.root%26%26e.parent.color%3D%3D%3D1%3B)if(e.parent%3D%3D%3De.parent.parent.left)%7Blet%20t%3De.parent.parent.right%3Bt.color%3D%3D%3D1%3F(e.parent.color%3D0%2Ct.color%3D0%2Ce.parent.parent.color%3D1%2Ce%3De.parent.parent)%3A(e%3D%3D%3De.parent.right%26%26(e%3De.parent%2CG(r%2Ce))%2Ce.parent.color%3D0%2Ce.parent.parent.color%3D1%2CZ(r%2Ce.parent.parent))%7Delse%7Blet%20t%3De.parent.parent.left%3Bt.color%3D%3D%3D1%3F(e.parent.color%3D0%2Ct.color%3D0%2Ce.parent.parent.color%3D1%2Ce%3De.parent.parent)%3A(e%3D%3D%3De.parent.left%26%26(e%3De.parent%2CZ(r%2Ce))%2Ce.parent.color%3D0%2Ce.parent.parent.color%3D1%2CG(r%2Ce.parent.parent))%7Dr.root.color%3D0%7Dfunction%20C(r%2Ce%2Ct%2Cn)%7Bfor(%3Be!%3D%3Dr.root%26%26e!%3D%3Dm%3B)e.parent.left%3D%3D%3De%26%26(e.parent.size_left%2B%3Dt%2Ce.parent.lf_left%2B%3Dn)%2Ce%3De.parent%7Dfunction%20H(r%2Ce)%7Blet%20t%3D0%2Cn%3D0%3Bif(e!%3D%3Dr.root)%7Bfor(%3Be!%3D%3Dr.root%26%26e%3D%3D%3De.parent.right%3B)e%3De.parent%3Bif(e!%3D%3Dr.root)for(e%3De.parent%2Ct%3DVe(e.left)-e.size_left%2Cn%3DWe(e.left)-e.lf_left%2Ce.size_left%2B%3Dt%2Ce.lf_left%2B%3Dn%3Be!%3D%3Dr.root%26%26(t!%3D%3D0%7C%7Cn!%3D%3D0)%3B)e.parent.left%3D%3D%3De%26%26(e.parent.size_left%2B%3Dt%2Ce.parent.lf_left%2B%3Dn)%2Ce%3De.parent%7D%7Dvar%20ft%2CJe%3Dclass%7Bconstructor()%7Bthis%5Bft%5D%3D%22LinkedMap%22%3Bthis._map%3Dnew%20Map%2Cthis._head%3Dvoid%200%2Cthis._tail%3Dvoid%200%2Cthis._size%3D0%2Cthis._state%3D0%7Dclear()%7Bthis._map.clear()%2Cthis._head%3Dvoid%200%2Cthis._tail%3Dvoid%200%2Cthis._size%3D0%2Cthis._state%2B%2B%7DisEmpty()%7Breturn!this._head%26%26!this._tail%7Dget%20size()%7Breturn%20this._size%7Dget%20first()%7Breturn%20this._head%3F.value%7Dget%20last()%7Breturn%20this._tail%3F.value%7Dhas(e)%7Breturn%20this._map.has(e)%7Dget(e%2Ct%3D0)%7Blet%20n%3Dthis._map.get(e)%3Bif(n)return%20t!%3D%3D0%26%26this.touch(n%2Ct)%2Cn.value%7Dset(e%2Ct%2Cn%3D0)%7Blet%20i%3Dthis._map.get(e)%3Bif(i)i.value%3Dt%2Cn!%3D%3D0%26%26this.touch(i%2Cn)%3Belse%7Bswitch(i%3D%7Bkey%3Ae%2Cvalue%3At%2Cnext%3Avoid%200%2Cprevious%3Avoid%200%7D%2Cn)%7Bcase%200%3Athis.addItemLast(i)%3Bbreak%3Bcase%201%3Athis.addItemFirst(i)%3Bbreak%3Bcase%202%3Athis.addItemLast(i)%3Bbreak%3Bdefault%3Athis.addItemLast(i)%3Bbreak%7Dthis._map.set(e%2Ci)%2Cthis._size%2B%2B%7Dreturn%20this%7Ddelete(e)%7Breturn!!this.remove(e)%7Dremove(e)%7Blet%20t%3Dthis._map.get(e)%3Bif(t)return%20this._map.delete(e)%2Cthis.removeItem(t)%2Cthis._size--%2Ct.value%7Dshift()%7Bif(!this._head%26%26!this._tail)return%3Bif(!this._head%7C%7C!this._tail)throw%20new%20Error(%22Invalid%20list%22)%3Blet%20e%3Dthis._head%3Breturn%20this._map.delete(e.key)%2Cthis.removeItem(e)%2Cthis._size--%2Ce.value%7DforEach(e%2Ct)%7Blet%20n%3Dthis._state%2Ci%3Dthis._head%3Bfor(%3Bi%3B)%7Bif(t%3Fe.bind(t)(i.value%2Ci.key%2Cthis)%3Ae(i.value%2Ci.key%2Cthis)%2Cthis._state!%3D%3Dn)throw%20new%20Error(%22LinkedMap%20got%20modified%20during%20iteration.%22)%3Bi%3Di.next%7D%7Dkeys()%7Blet%20e%3Dthis%2Ct%3Dthis._state%2Cn%3Dthis._head%2Ci%3D%7B%5BSymbol.iterator%5D()%7Breturn%20i%7D%2Cnext()%7Bif(e._state!%3D%3Dt)throw%20new%20Error(%22LinkedMap%20got%20modified%20during%20iteration.%22)%3Bif(n)%7Blet%20s%3D%7Bvalue%3An.key%2Cdone%3A!1%7D%3Breturn%20n%3Dn.next%2Cs%7Delse%20return%7Bvalue%3Avoid%200%2Cdone%3A!0%7D%7D%7D%3Breturn%20i%7Dvalues()%7Blet%20e%3Dthis%2Ct%3Dthis._state%2Cn%3Dthis._head%2Ci%3D%7B%5BSymbol.iterator%5D()%7Breturn%20i%7D%2Cnext()%7Bif(e._state!%3D%3Dt)throw%20new%20Error(%22LinkedMap%20got%20modified%20during%20iteration.%22)%3Bif(n)%7Blet%20s%3D%7Bvalue%3An.value%2Cdone%3A!1%7D%3Breturn%20n%3Dn.next%2Cs%7Delse%20return%7Bvalue%3Avoid%200%2Cdone%3A!0%7D%7D%7D%3Breturn%20i%7Dentries()%7Blet%20e%3Dthis%2Ct%3Dthis._state%2Cn%3Dthis._head%2Ci%3D%7B%5BSymbol.iterator%5D()%7Breturn%20i%7D%2Cnext()%7Bif(e._state!%3D%3Dt)throw%20new%20Error(%22LinkedMap%20got%20modified%20during%20iteration.%22)%3Bif(n)%7Blet%20s%3D%7Bvalue%3A%5Bn.key%2Cn.value%5D%2Cdone%3A!1%7D%3Breturn%20n%3Dn.next%2Cs%7Delse%20return%7Bvalue%3Avoid%200%2Cdone%3A!0%7D%7D%7D%3Breturn%20i%7D%5B(ft%3DSymbol.toStringTag%2CSymbol.iterator)%5D()%7Breturn%20this.entries()%7DtrimOld(e)%7Bif(e%3E%3Dthis.size)return%3Bif(e%3D%3D%3D0)%7Bthis.clear()%3Breturn%7Dlet%20t%3Dthis._head%2Cn%3Dthis.size%3Bfor(%3Bt%26%26n%3Ee%3B)this._map.delete(t.key)%2Ct%3Dt.next%2Cn--%3Bthis._head%3Dt%2Cthis._size%3Dn%2Ct%26%26(t.previous%3Dvoid%200)%2Cthis._state%2B%2B%7DtrimNew(e)%7Bif(e%3E%3Dthis.size)return%3Bif(e%3D%3D%3D0)%7Bthis.clear()%3Breturn%7Dlet%20t%3Dthis._tail%2Cn%3Dthis.size%3Bfor(%3Bt%26%26n%3Ee%3B)this._map.delete(t.key)%2Ct%3Dt.previous%2Cn--%3Bthis._tail%3Dt%2Cthis._size%3Dn%2Ct%26%26(t.next%3Dvoid%200)%2Cthis._state%2B%2B%7DaddItemFirst(e)%7Bif(!this._head%26%26!this._tail)this._tail%3De%3Belse%20if(this._head)e.next%3Dthis._head%2Cthis._head.previous%3De%3Belse%20throw%20new%20Error(%22Invalid%20list%22)%3Bthis._head%3De%2Cthis._state%2B%2B%7DaddItemLast(e)%7Bif(!this._head%26%26!this._tail)this._head%3De%3Belse%20if(this._tail)e.previous%3Dthis._tail%2Cthis._tail.next%3De%3Belse%20throw%20new%20Error(%22Invalid%20list%22)%3Bthis._tail%3De%2Cthis._state%2B%2B%7DremoveItem(e)%7Bif(e%3D%3D%3Dthis._head%26%26e%3D%3D%3Dthis._tail)this._head%3Dvoid%200%2Cthis._tail%3Dvoid%200%3Belse%20if(e%3D%3D%3Dthis._head)%7Bif(!e.next)throw%20new%20Error(%22Invalid%20list%22)%3Be.next.previous%3Dvoid%200%2Cthis._head%3De.next%7Delse%20if(e%3D%3D%3Dthis._tail)%7Bif(!e.previous)throw%20new%20Error(%22Invalid%20list%22)%3Be.previous.next%3Dvoid%200%2Cthis._tail%3De.previous%7Delse%7Blet%20t%3De.next%2Cn%3De.previous%3Bif(!t%7C%7C!n)throw%20new%20Error(%22Invalid%20list%22)%3Bt.previous%3Dn%2Cn.next%3Dt%7De.next%3Dvoid%200%2Ce.previous%3Dvoid%200%2Cthis._state%2B%2B%7Dtouch(e%2Ct)%7Bif(!this._head%7C%7C!this._tail)throw%20new%20Error(%22Invalid%20list%22)%3Bif(!(t!%3D%3D1%26%26t!%3D%3D2))%7Bif(t%3D%3D%3D1)%7Bif(e%3D%3D%3Dthis._head)return%3Blet%20n%3De.next%2Ci%3De.previous%3Be%3D%3D%3Dthis._tail%3F(i.next%3Dvoid%200%2Cthis._tail%3Di)%3A(n.previous%3Di%2Ci.next%3Dn)%2Ce.previous%3Dvoid%200%2Ce.next%3Dthis._head%2Cthis._head.previous%3De%2Cthis._head%3De%2Cthis._state%2B%2B%7Delse%20if(t%3D%3D%3D2)%7Bif(e%3D%3D%3Dthis._tail)return%3Blet%20n%3De.next%2Ci%3De.previous%3Be%3D%3D%3Dthis._head%3F(n.previous%3Dvoid%200%2Cthis._head%3Dn)%3A(n.previous%3Di%2Ci.next%3Dn)%2Ce.next%3Dvoid%200%2Ce.previous%3Dthis._tail%2Cthis._tail.next%3De%2Cthis._tail%3De%2Cthis._state%2B%2B%7D%7D%7DtoJSON()%7Blet%20e%3D%5B%5D%3Breturn%20this.forEach((t%2Cn)%3D%3E%7Be.push(%5Bn%2Ct%5D)%7D)%2Ce%7DfromJSON(e)%7Bthis.clear()%3Bfor(let%5Bt%2Cn%5Dof%20e)this.set(t%2Cn)%7D%7D%2Cze%3Dclass%20extends%20Je%7Bconstructor(e%2Ct%3D1)%7Bsuper()%2Cthis._limit%3De%2Cthis._ratio%3DMath.min(Math.max(0%2Ct)%2C1)%7Dget%20limit()%7Breturn%20this._limit%7Dset%20limit(e)%7Bthis._limit%3De%2Cthis.checkTrim()%7Dget%20ratio()%7Breturn%20this._ratio%7Dset%20ratio(e)%7Bthis._ratio%3DMath.min(Math.max(0%2Ce)%2C1)%2Cthis.checkTrim()%7Dget(e%2Ct%3D2)%7Breturn%20super.get(e%2Ct)%7Dpeek(e)%7Breturn%20super.get(e%2C0)%7Dset(e%2Ct)%7Breturn%20super.set(e%2Ct%2C2)%2Cthis%7DcheckTrim()%7Bthis.size%3Ethis._limit%26%26this.trim(Math.round(this._limit*this._ratio))%7D%7D%2Cce%3Dclass%20extends%20ze%7Bconstructor(e%2Ct%3D1)%7Bsuper(e%2Ct)%7Dtrim(e)%7Bthis.trimOld(e)%7Dset(e%2Ct)%7Breturn%20super.set(e%2Ct)%2Cthis.checkTrim()%2Cthis%7D%7D%3Bfunction%20je(r)%7Breturn%20r%3C0%3F0%3Ar%3E255%3F255%3Ar%7C0%7Dvar%20de%3Dclass%20r%7Bconstructor(e)%7Blet%20t%3Dje(e)%3Bthis._defaultValue%3Dt%2Cthis._asciiMap%3Dr._createAsciiMap(t)%2Cthis._map%3Dnew%20Map%7Dstatic%20_createAsciiMap(e)%7Blet%20t%3Dnew%20Uint8Array(256)%3Breturn%20t.fill(e)%2Ct%7Dset(e%2Ct)%7Blet%20n%3Dje(t)%3Be%3E%3D0%26%26e%3C256%3Fthis._asciiMap%5Be%5D%3Dn%3Athis._map.set(e%2Cn)%7Dget(e)%7Breturn%20e%3E%3D0%26%26e%3C256%3Fthis._asciiMap%5Be%5D%3Athis._map.get(e)%7C%7Cthis._defaultValue%7Dclear()%7Bthis._asciiMap.fill(this._defaultValue)%2Cthis._map.clear()%7D%7D%3Bvar%20Ke%3Dclass%20extends%20de%7Bconstructor(t%2Cn)%7Bsuper(0)%3Bthis._segmenter%3Dnull%3Bthis._cachedLine%3Dnull%3Bthis._cachedSegments%3D%5B%5D%3Bthis.intlSegmenterLocales%3Dn%2Cthis.intlSegmenterLocales.length%3E0%3Fthis._segmenter%3Dnew%20Intl.Segmenter(this.intlSegmenterLocales%2C%7Bgranularity%3A%22word%22%7D)%3Athis._segmenter%3Dnull%3Bfor(let%20i%3D0%2Cs%3Dt.length%3Bi%3Cs%3Bi%2B%2B)this.set(t.charCodeAt(i)%2C2)%3Bthis.set(32%2C1)%2Cthis.set(9%2C1)%7DfindPrevIntlWordBeforeOrAtOffset(t%2Cn)%7Blet%20i%3Dnull%3Bfor(let%20s%20of%20this._getIntlSegmenterWordsOnLine(t))%7Bif(s.index%3En)break%3Bi%3Ds%7Dreturn%20i%7DfindNextIntlWordAtOrAfterOffset(t%2Cn)%7Bfor(let%20i%20of%20this._getIntlSegmenterWordsOnLine(t))if(!(i.index%3Cn))return%20i%3Breturn%20null%7D_getIntlSegmenterWordsOnLine(t)%7Breturn%20this._segmenter%3Fthis._cachedLine%3D%3D%3Dt%3Fthis._cachedSegments%3A(this._cachedLine%3Dt%2Cthis._cachedSegments%3Dthis._filterWordSegments(this._segmenter.segment(t))%2Cthis._cachedSegments)%3A%5B%5D%7D_filterWordSegments(t)%7Blet%20n%3D%5B%5D%3Bfor(let%20i%20of%20t)this._isWordLike(i)%26%26n.push(i)%3Breturn%20n%7D_isWordLike(t)%7Breturn!!t.isWordLike%7D%7D%2Cut%3Dnew%20ce(10)%3Bfunction%20ct(r%2Ce)%7Blet%20t%3D%60%24%7Br%7D%2F%24%7Be.join(%22%2C%22)%7D%60%2Cn%3Dut.get(t)%3Breturn%20n%7C%7C(n%3Dnew%20Ke(r%2Ce)%2Cut.set(t%2Cn))%2Cn%7Dfunction%20Ft(r)%7Breturn%20r.replace(%2F%5B%5C%5C%5C%7B%5C%7D%5C*%5C%2B%5C%3F%5C%7C%5C%5E%5C%24%5C.%5C%5B%5C%5D%5C(%5C)%5D%2Fg%2C%22%5C%5C%24%26%22)%7Dfunction%20Pt(r)%7Breturn%2055296%3C%3Dr%26%26r%3C%3D56319%7Dfunction%20Rt(r)%7Breturn%2056320%3C%3Dr%26%26r%3C%3D57343%7Dfunction%20Vt(r%2Ce)%7Breturn(r-55296%3C%3C10)%2B(e-56320)%2B65536%7Dfunction%20dt(r%2Ce%2Ct)%7Blet%20n%3Dr.charCodeAt(t)%3Bif(Pt(n)%26%26t%2B1%3Ce)%7Blet%20i%3Dr.charCodeAt(t%2B1)%3Bif(Rt(i))return%20Vt(n%2Ci)%7Dreturn%20n%7Dfunction%20ht(r%2Ce%2Ct%3D%7B%7D)%7Bif(!r)throw%20new%20Error(%22Cannot%20create%20regex%20from%20empty%20string%22)%3Be%7C%7C(r%3DFt(r))%2Ct.wholeWord%26%26(%2F%5CB%2F.test(r.charAt(0))%7C%7C(r%3D%22%5C%5Cb%22%2Br)%2C%2F%5CB%2F.test(r.charAt(r.length-1))%7C%7C(r%3Dr%2B%22%5C%5Cb%22))%3Blet%20n%3D%22%22%3Breturn%20t.global%26%26(n%2B%3D%22g%22)%2Ct.matchCase%7C%7C(n%2B%3D%22i%22)%2Ct.multiline%26%26(n%2B%3D%22m%22)%2Ct.unicode%26%26(n%2B%3D%22u%22)%2Cnew%20RegExp(r%2Cn)%7Dvar%20De%3Dclass%7Bconstructor(e)%7Blet%20t%3D%5B%5D%2Cn%3D0%3Bfor(let%20i%3D0%2Cs%3De.length%3Bi%3Cs%3Bi%2B%2B)e.charCodeAt(i)%3D%3D%3D10%26%26(t%5Bn%2B%2B%5D%3Di)%3Bthis._lineFeedsOffsets%3Dt%7DfindLineFeedCountBeforeOffset(e)%7Blet%20t%3Dthis._lineFeedsOffsets%2Cn%3D0%2Ci%3Dt.length-1%3Bif(i%3D%3D%3D-1%7C%7Ce%3C%3Dt%5B0%5D)return%200%3Bfor(%3Bn%3Ci%3B)%7Blet%20s%3Dn%2B((i-n)%2F2%3E%3E0)%3Bt%5Bs%5D%3E%3De%3Fi%3Ds-1%3At%5Bs%2B1%5D%3E%3De%3F(n%3Ds%2Ci%3Ds)%3An%3Ds%2B1%7Dreturn%20n%2B1%7D%7D%2Che%3Dclass%7Bstatic%20findMatches(e%2Ct%2Cn%2Ci%2Cs)%7Blet%20o%3Dt.parseSearchRequest()%3Breturn%20o%3Fo.regex.multiline%3Fthis._doFindMatchesMultiline(e%2Cn%2Cnew%20K(o.wordSeparators%2Co.regex)%2Ci%2Cs)%3Athis._doFindMatchesLineByLine(e%2Cn%2Co%2Ci%2Cs)%3A%5B%5D%7Dstatic%20_doFindMatchesMultiline(e%2Ct%2Cn%2Ci%2Cs)%7Blet%20o%3Dt.getStartPosition()%2Ca%3De.getOffsetAt(o.lineNumber%2Co.column)%2Cl%3De.getValueInRange(t%2C1)%2Cf%3De.getEOL()%3D%3D%3D%60%5Cr%0A%60%3Fnew%20De(l)%3Anull%2Cu%3D%5B%5D%2Cc%3D0%2Cd%3Bfor(n.reset(0)%3Bd%3Dn.next(l)%3B)if(u%5Bc%2B%2B%5D%3Dee(this._getMultilineMatchRange(e%2Ca%2Cl%2Cf%2Cd.index%2Cd%5B0%5D)%2Cd%2Ci)%2Cc%3E%3Ds)return%20u%3Breturn%20u%7Dstatic%20_getMultilineMatchRange(e%2Ct%2Cn%2Ci%2Cs%2Co)%7Blet%20a%2Cl%3D0%3Bi%3F(l%3Di.findLineFeedCountBeforeOffset(s)%2Ca%3Dt%2Bs%2Bl)%3Aa%3Dt%2Bs%3Blet%20f%3Bif(i)%7Blet%20b%3Di.findLineFeedCountBeforeOffset(s%2Bo.length)-l%3Bf%3Da%2Bo.length%2Bb%7Delse%20f%3Da%2Bo.length%3Blet%20u%3De.positionAt(a)%2Cc%3De.positionAt(f)%3Breturn%20new%20A(u.lineNumber%2Cu.column%2Cc.lineNumber%2Cc.column)%7Dstatic%20_doFindMatchesLineByLine(e%2Ct%2Cn%2Ci%2Cs)%7Blet%20o%3D%5B%5D%2Ca%3D0%3Bif(t.startLineNumber%3D%3D%3Dt.endLineNumber)%7Blet%20f%3De.getLineContent(t.startLineNumber).substring(t.startColumn-1%2Ct.endColumn-1)%3Ba%3Dthis._findMatchesInLine(n%2Cf%2Ct.startLineNumber%2Ct.startColumn-1%2Ca%2Co%2Ci%2Cs)%7Dlet%20l%3De.getLineContent(t.startLineNumber).substring(t.startColumn-1)%3Ba%3Dthis._findMatchesInLine(n%2Cl%2Ct.startLineNumber%2Ct.startColumn-1%2Ca%2Co%2Ci%2Cs)%3Bfor(let%20f%3Dt.startLineNumber%2B1%3Bf%3Ct.endLineNumber%26%26a%3Cs%3Bf%2B%2B)a%3Dthis._findMatchesInLine(n%2Ce.getLineContent(f)%2Cf%2C0%2Ca%2Co%2Ci%2Cs)%3Bif(a%3Cs)%7Blet%20f%3De.getLineContent(t.endLineNumber).substring(0%2Ct.endColumn-1)%3Ba%3Dthis._findMatchesInLine(n%2Cf%2Ct.endLineNumber%2C0%2Ca%2Co%2Ci%2Cs)%7Dreturn%20o%7Dstatic%20_findMatchesInLine(e%2Ct%2Cn%2Ci%2Cs%2Co%2Ca%2Cl)%7Blet%20f%3De.wordSeparators%3Bif(!a%26%26e.simpleSearch)%7Blet%20d%3De.simpleSearch%2Cb%3Dd.length%2Ck%3Dt.length%2CL%3D-b%3Bfor(%3B(L%3Dt.indexOf(d%2CL%2Bb))!%3D%3D-1%3B)if((!f%7C%7Cpe(f%2Ct%2Ck%2CL%2Cb))%26%26(o%5Bs%2B%2B%5D%3Dnew%20V(new%20A(n%2CL%2B1%2Bi%2Cn%2CL%2B1%2Bb%2Bi)%2Cnull)%2Cs%3E%3Dl))return%20s%7Dlet%20u%3Dnew%20K(e.wordSeparators%2Ce.regex)%2Cc%3Bu.reset(0)%3Bdo%20if(c%3Du.next(t)%2Cc%26%26(o%5Bs%2B%2B%5D%3Dee(new%20A(n%2Cc.index%2B1%2Bi%2Cn%2Cc.index%2B1%2Bc%5B0%5D.length%2Bi)%2Cc%2Ca)%2Cs%3E%3Dl))return%20s%3Bwhile(c)%3Breturn%20s%7D%7D%2CY%3Dclass%7Bconstructor(e%2Ct%2Cn%2Ci)%7Bthis.searchString%3De%2Cthis.isRegex%3Dt%2Cthis.matchCase%3Dn%2Cthis.wordSeparators%3Di%7DparseSearchRequest()%7Bif(this.searchString%3D%3D%3D%22%22)return%20null%3Blet%20e%3Bthis.isRegex%3Fe%3DWt(this.searchString)%3Ae%3Dthis.searchString.indexOf(%60%0A%60)%3E%3D0%3Blet%20t%3Dnull%3Btry%7Bt%3Dht(this.searchString%2Cthis.isRegex%2C%7BmatchCase%3Athis.matchCase%2CwholeWord%3A!1%2Cmultiline%3Ae%2Cglobal%3A!0%2Cunicode%3A!0%7D)%7Dcatch%7Breturn%20null%7Dif(!t)return%20null%3Blet%20n%3D!this.isRegex%26%26!e%3Breturn%20n%26%26this.searchString.toLowerCase()!%3D%3Dthis.searchString.toUpperCase()%26%26(n%3Dthis.matchCase)%2Cnew%20fe(t%2Cthis.wordSeparators%3Fct(this.wordSeparators%2C%5B%5D)%3Anull%2Cn%3Fthis.searchString%3Anull)%7D%7D%3Bfunction%20Wt(r)%7Bif(!r%7C%7Cr.length%3D%3D%3D0)return!1%3Bfor(let%20e%3D0%2Ct%3Dr.length%3Be%3Ct%3Be%2B%2B)%7Blet%20n%3Dr.charCodeAt(e)%3Bif(n%3D%3D%3D10)return!0%3Bif(n%3D%3D%3D92)%7Bif(e%2B%2B%2Ce%3E%3Dt)break%3Blet%20i%3Dr.charCodeAt(e)%3Bif(i%3D%3D%3D110%7C%7Ci%3D%3D%3D114%7C%7Ci%3D%3D%3D87)return!0%7D%7Dreturn!1%7Dfunction%20Ut(r%2Ce%2Ct%2Cn%2Ci)%7Bif(n%3D%3D%3D0)return!0%3Blet%20s%3De.charCodeAt(n-1)%3Bif(r.get(s)!%3D%3D0%7C%7Cs%3D%3D%3D13%7C%7Cs%3D%3D%3D10)return!0%3Bif(i%3E0)%7Blet%20o%3De.charCodeAt(n)%3Bif(r.get(o)!%3D%3D0)return!0%7Dreturn!1%7Dfunction%20Jt(r%2Ce%2Ct%2Cn%2Ci)%7Bif(n%2Bi%3D%3D%3Dt)return!0%3Blet%20s%3De.charCodeAt(n%2Bi)%3Bif(r.get(s)!%3D%3D0%7C%7Cs%3D%3D%3D13%7C%7Cs%3D%3D%3D10)return!0%3Bif(i%3E0)%7Blet%20o%3De.charCodeAt(n%2Bi-1)%3Bif(r.get(o)!%3D%3D0)return!0%7Dreturn!1%7Dfunction%20pe(r%2Ce%2Ct%2Cn%2Ci)%7Breturn%20Ut(r%2Ce%2Ct%2Cn%2Ci)%26%26Jt(r%2Ce%2Ct%2Cn%2Ci)%7Dvar%20K%3Dclass%7Bconstructor(e%2Ct)%7Bthis._wordSeparators%3De%2Cthis._searchRegex%3Dt%2Cthis._prevMatchStartIndex%3D-1%2Cthis._prevMatchLength%3D0%7Dreset(e)%7Bthis._searchRegex.lastIndex%3De%2Cthis._prevMatchStartIndex%3D-1%2Cthis._prevMatchLength%3D0%7Dnext(e)%7Blet%20t%3De.length%2Cn%3Bdo%7Bif(this._prevMatchStartIndex%2Bthis._prevMatchLength%3D%3D%3Dt%7C%7C(n%3Dthis._searchRegex.exec(e)%2C!n))return%20null%3Blet%20i%3Dn.index%2Cs%3Dn%5B0%5D.length%3Bif(i%3D%3D%3Dthis._prevMatchStartIndex%26%26s%3D%3D%3Dthis._prevMatchLength)%7Bif(s%3D%3D%3D0)%7Bdt(e%2Ct%2Cthis._searchRegex.lastIndex)%3E65535%3Fthis._searchRegex.lastIndex%2B%3D2%3Athis._searchRegex.lastIndex%2B%3D1%3Bcontinue%7Dreturn%20null%7Dif(this._prevMatchStartIndex%3Di%2Cthis._prevMatchLength%3Ds%2C!this._wordSeparators%7C%7Cpe(this._wordSeparators%2Ce%2Ct%2Ci%2Cs))return%20n%7Dwhile(n)%3Breturn%20null%7D%7D%3Bfunction%20ee(r%2Ce%2Ct)%7Bif(!t)return%20new%20V(r%2Cnull)%3Blet%20n%3D%5B%5D%3Bfor(let%20i%3D0%2Cs%3De.length%3Bi%3Cs%3Bi%2B%2B)n%5Bi%5D%3De%5Bi%5D%3Breturn%20new%20V(r%2Cn)%7Dvar%20R%3D65535%3Bfunction%20pt(r)%7Blet%20e%3Breturn%20r%5Br.length-1%5D%3C65536%3Fe%3Dnew%20Uint16Array(r.length)%3Ae%3Dnew%20Uint32Array(r.length)%2Ce.set(r%2C0)%2Ce%7Dvar%20qe%3Dclass%7Bconstructor(e%2Ct%2Cn%2Ci%2Cs)%7Bthis.lineStarts%3De%3Bthis.cr%3Dt%3Bthis.lf%3Dn%3Bthis.crlf%3Di%3Bthis.isBasicASCII%3Ds%7D%7D%3Bfunction%20E(r%2Ce%3D!0)%7Blet%20t%3D%5B0%5D%2Cn%3D1%3Bfor(let%20i%3D0%2Cs%3Dr.length%3Bi%3Cs%3Bi%2B%2B)%7Blet%20o%3Dr.charCodeAt(i)%3Bo%3D%3D%3D13%3Fi%2B1%3Cs%26%26r.charCodeAt(i%2B1)%3D%3D%3D10%3F(t%5Bn%2B%2B%5D%3Di%2B2%2Ci%2B%2B)%3At%5Bn%2B%2B%5D%3Di%2B1%3Ao%3D%3D%3D10%26%26(t%5Bn%2B%2B%5D%3Di%2B1)%7Dreturn%20e%3Fpt(t)%3At%7Dfunction%20gt(r%2Ce)%7Br.length%3D0%2Cr%5B0%5D%3D0%3Blet%20t%3D1%2Cn%3D0%2Ci%3D0%2Cs%3D0%2Co%3D!0%3Bfor(let%20l%3D0%2Cf%3De.length%3Bl%3Cf%3Bl%2B%2B)%7Blet%20u%3De.charCodeAt(l)%3Bu%3D%3D%3D13%3Fl%2B1%3Cf%26%26e.charCodeAt(l%2B1)%3D%3D%3D10%3F(s%2B%2B%2Cr%5Bt%2B%2B%5D%3Dl%2B2%2Cl%2B%2B)%3A(n%2B%2B%2Cr%5Bt%2B%2B%5D%3Dl%2B1)%3Au%3D%3D%3D10%3F(i%2B%2B%2Cr%5Bt%2B%2B%5D%3Dl%2B1)%3Ao%26%26u!%3D%3D9%26%26(u%3C32%7C%7Cu%3E126)%26%26(o%3D!1)%7Dlet%20a%3Dnew%20qe(pt(r)%2Cn%2Ci%2Cs%2Co)%3Breturn%20r.length%3D0%2Ca%7Dvar%20v%3Dclass%7Bconstructor(e%2Ct%2Cn%2Ci%2Cs)%7Bthis.bufferIndex%3De%2Cthis.start%3Dt%2Cthis.end%3Dn%2Cthis.lineFeedCnt%3Di%2Cthis.length%3Ds%7D%7D%2CM%3Dclass%7Bconstructor(e%2Ct)%7Bthis.buffer%3De%2Cthis.lineStarts%3Dt%7D%7D%2C%24e%3Dclass%7Bconstructor(e%2Ct)%7Bthis._pieces%3D%5B%5D%2Cthis._tree%3De%2Cthis._BOM%3Dt%2Cthis._index%3D0%2Ce.root!%3D%3Dm%26%26e.iterate(e.root%2Cn%3D%3E(n!%3D%3Dm%26%26this._pieces.push(n.piece)%2C!0))%7Dread()%7Breturn%20this._pieces.length%3D%3D%3D0%3Fthis._index%3D%3D%3D0%3F(this._index%2B%2B%2Cthis._BOM)%3Anull%3Athis._index%3Ethis._pieces.length-1%3Fnull%3Athis._index%3D%3D%3D0%3Fthis._BOM%2Bthis._tree.getPieceContent(this._pieces%5Bthis._index%2B%2B%5D)%3Athis._tree.getPieceContent(this._pieces%5Bthis._index%2B%2B%5D)%7D%7D%2CXe%3Dclass%7Bconstructor(e)%7Bthis._limit%3De%2Cthis._cache%3D%5B%5D%7Dget(e)%7Bfor(let%20t%3Dthis._cache.length-1%3Bt%3E%3D0%3Bt--)%7Blet%20n%3Dthis._cache%5Bt%5D%3Bif(n.nodeStartOffset%3C%3De%26%26n.nodeStartOffset%2Bn.node.piece.length%3E%3De)return%20n%7Dreturn%20null%7Dget2(e)%7Bfor(let%20t%3Dthis._cache.length-1%3Bt%3E%3D0%3Bt--)%7Blet%20n%3Dthis._cache%5Bt%5D%3Bif(n.nodeStartLineNumber%26%26n.nodeStartLineNumber%3Ce%26%26n.nodeStartLineNumber%2Bn.node.piece.lineFeedCnt%3E%3De)return%20n%7Dreturn%20null%7Dset(e)%7Bthis._cache.length%3E%3Dthis._limit%26%26this._cache.shift()%2Cthis._cache.push(e)%7Dvalidate(e)%7Blet%20t%3D!1%2Cn%3Dthis._cache%3Bfor(let%20i%3D0%3Bi%3Cn.length%3Bi%2B%2B)%7Blet%20s%3Dn%5Bi%5D%3Bif(s.node.parent%3D%3D%3Dnull%7C%7Cs.nodeStartOffset%3E%3De)%7Bn%5Bi%5D%3Dnull%2Ct%3D!0%3Bcontinue%7D%7Dif(t)%7Blet%20i%3D%5B%5D%3Bfor(let%20s%20of%20n)s!%3D%3Dnull%26%26i.push(s)%3Bthis._cache%3Di%7D%7D%7D%2Cge%3Dclass%7Bconstructor(e%2Ct%2Cn)%7Bthis.create(e%2Ct%2Cn)%7Dcreate(e%2Ct%2Cn)%7Bthis._buffers%3D%5Bnew%20M(%22%22%2C%5B0%5D)%5D%2Cthis._lastChangeBufferPos%3D%7Bline%3A0%2Ccolumn%3A0%7D%2Cthis.root%3Dm%2Cthis._lineCnt%3D1%2Cthis._length%3D0%2Cthis._EOL%3Dt%2Cthis._EOLLength%3Dt.length%2Cthis._EOLNormalized%3Dn%3Blet%20i%3Dnull%3Bfor(let%20s%3D0%2Co%3De.length%3Bs%3Co%3Bs%2B%2B)if(e%5Bs%5D.buffer.length%3E0)%7Be%5Bs%5D.lineStarts%7C%7C(e%5Bs%5D.lineStarts%3DE(e%5Bs%5D.buffer))%3Blet%20a%3Dnew%20v(s%2B1%2C%7Bline%3A0%2Ccolumn%3A0%7D%2C%7Bline%3Ae%5Bs%5D.lineStarts.length-1%2Ccolumn%3Ae%5Bs%5D.buffer.length-e%5Bs%5D.lineStarts%5Be%5Bs%5D.lineStarts.length-1%5D%7D%2Ce%5Bs%5D.lineStarts.length-1%2Ce%5Bs%5D.buffer.length)%3Bthis._buffers.push(e%5Bs%5D)%2Ci%3Dthis.rbInsertRight(i%2Ca)%7Dthis._searchCache%3Dnew%20Xe(1)%2Cthis._lastVisitedLine%3D%7BlineNumber%3A0%2Cvalue%3A%22%22%7D%2Cthis.computeBufferMetadata()%7DnormalizeEOL(e)%7Blet%20t%3DR%2Cn%3Dt-Math.floor(t%2F3)%2Ci%3Dn*2%2Cs%3D%22%22%2Co%3D0%2Ca%3D%5B%5D%3Bif(this.iterate(this.root%2Cl%3D%3E%7Blet%20f%3Dthis.getNodeContent(l)%2Cu%3Df.length%3Bif(o%3C%3Dn%7C%7Co%2Bu%3Ci)return%20s%2B%3Df%2Co%2B%3Du%2C!0%3Blet%20c%3Ds.replace(%2F%5Cr%5Cn%7C%5Cr%7C%5Cn%2Fg%2Ce)%3Breturn%20a.push(new%20M(c%2CE(c)))%2Cs%3Df%2Co%3Du%2C!0%7D)%2Co%3E0)%7Blet%20l%3Ds.replace(%2F%5Cr%5Cn%7C%5Cr%7C%5Cn%2Fg%2Ce)%3Ba.push(new%20M(l%2CE(l)))%7Dthis.create(a%2Ce%2C!0)%7DgetEOL()%7Breturn%20this._EOL%7DsetEOL(e)%7Bthis._EOL%3De%2Cthis._EOLLength%3Dthis._EOL.length%2Cthis.normalizeEOL(e)%7DcreateSnapshot(e)%7Breturn%20new%20%24e(this%2Ce)%7Dequal(e)%7Bif(this.getLength()!%3D%3De.getLength()%7C%7Cthis.getLineCount()!%3D%3De.getLineCount())return!1%3Blet%20t%3D0%3Breturn%20this.iterate(this.root%2Ci%3D%3E%7Bif(i%3D%3D%3Dm)return!0%3Blet%20s%3Dthis.getNodeContent(i)%2Co%3Ds.length%2Ca%3De.nodeAt(t)%2Cl%3De.nodeAt(t%2Bo)%2Cf%3De.getValueInRange2(a%2Cl)%3Breturn%20t%2B%3Do%2Cs%3D%3D%3Df%7D)%7DgetOffsetAt(e%2Ct)%7Blet%20n%3D0%2Ci%3Dthis.root%3Bfor(%3Bi!%3D%3Dm%3B)if(i.left!%3D%3Dm%26%26i.lf_left%2B1%3E%3De)i%3Di.left%3Belse%20if(i.lf_left%2Bi.piece.lineFeedCnt%2B1%3E%3De)%7Bn%2B%3Di.size_left%3Blet%20s%3Dthis.getAccumulatedValue(i%2Ce-i.lf_left-2)%3Breturn%20n%2B%3Ds%2Bt-1%7Delse%20e-%3Di.lf_left%2Bi.piece.lineFeedCnt%2Cn%2B%3Di.size_left%2Bi.piece.length%2Ci%3Di.right%3Breturn%20n%7DgetPositionAt(e)%7Be%3DMath.floor(e)%2Ce%3DMath.max(0%2Ce)%3Blet%20t%3Dthis.root%2Cn%3D0%2Ci%3De%3Bfor(%3Bt!%3D%3Dm%3B)if(t.size_left!%3D%3D0%26%26t.size_left%3E%3De)t%3Dt.left%3Belse%20if(t.size_left%2Bt.piece.length%3E%3De)%7Blet%20s%3Dthis.getIndexOf(t%2Ce-t.size_left)%3Bif(n%2B%3Dt.lf_left%2Bs.index%2Cs.index%3D%3D%3D0)%7Blet%20o%3Dthis.getOffsetAt(n%2B1%2C1)%2Ca%3Di-o%3Breturn%20new%20P(n%2B1%2Ca%2B1)%7Dreturn%20new%20P(n%2B1%2Cs.remainder%2B1)%7Delse%20if(e-%3Dt.size_left%2Bt.piece.length%2Cn%2B%3Dt.lf_left%2Bt.piece.lineFeedCnt%2Ct.right%3D%3D%3Dm)%7Blet%20s%3Dthis.getOffsetAt(n%2B1%2C1)%2Co%3Di-e-s%3Breturn%20new%20P(n%2B1%2Co%2B1)%7Delse%20t%3Dt.right%3Breturn%20new%20P(1%2C1)%7DgetValueInRange(e%2Ct)%7Bif(e.startLineNumber%3D%3D%3De.endLineNumber%26%26e.startColumn%3D%3D%3De.endColumn)return%22%22%3Blet%20n%3Dthis.nodeAt2(e.startLineNumber%2Ce.startColumn)%2Ci%3Dthis.nodeAt2(e.endLineNumber%2Ce.endColumn)%2Cs%3Dthis.getValueInRange2(n%2Ci)%3Breturn%20t%3Ft!%3D%3Dthis._EOL%7C%7C!this._EOLNormalized%3Fs.replace(%2F%5Cr%5Cn%7C%5Cr%7C%5Cn%2Fg%2Ct)%3At%3D%3D%3Dthis.getEOL()%26%26this._EOLNormalized%3Fs%3As.replace(%2F%5Cr%5Cn%7C%5Cr%7C%5Cn%2Fg%2Ct)%3As%7DgetValueInRange2(e%2Ct)%7Bif(e.node%3D%3D%3Dt.node)%7Blet%20a%3De.node%2Cl%3Dthis._buffers%5Ba.piece.bufferIndex%5D.buffer%2Cf%3Dthis.offsetInBuffer(a.piece.bufferIndex%2Ca.piece.start)%3Breturn%20l.substring(f%2Be.remainder%2Cf%2Bt.remainder)%7Dlet%20n%3De.node%2Ci%3Dthis._buffers%5Bn.piece.bufferIndex%5D.buffer%2Cs%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%2Co%3Di.substring(s%2Be.remainder%2Cs%2Bn.piece.length)%3Bfor(n%3Dn.next()%3Bn!%3D%3Dm%3B)%7Blet%20a%3Dthis._buffers%5Bn.piece.bufferIndex%5D.buffer%2Cl%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Bif(n%3D%3D%3Dt.node)%7Bo%2B%3Da.substring(l%2Cl%2Bt.remainder)%3Bbreak%7Delse%20o%2B%3Da.substr(l%2Cn.piece.length)%3Bn%3Dn.next()%7Dreturn%20o%7DgetLinesContent()%7Blet%20e%3D%5B%5D%2Ct%3D0%2Cn%3D%22%22%2Ci%3D!1%3Breturn%20this.iterate(this.root%2Cs%3D%3E%7Bif(s%3D%3D%3Dm)return!0%3Blet%20o%3Ds.piece%2Ca%3Do.length%3Bif(a%3D%3D%3D0)return!0%3Blet%20l%3Dthis._buffers%5Bo.bufferIndex%5D.buffer%2Cf%3Dthis._buffers%5Bo.bufferIndex%5D.lineStarts%2Cu%3Do.start.line%2Cc%3Do.end.line%2Cd%3Df%5Bu%5D%2Bo.start.column%3Bif(i%26%26(l.charCodeAt(d)%3D%3D%3D10%26%26(d%2B%2B%2Ca--)%2Ce%5Bt%2B%2B%5D%3Dn%2Cn%3D%22%22%2Ci%3D!1%2Ca%3D%3D%3D0))return!0%3Bif(u%3D%3D%3Dc)return!this._EOLNormalized%26%26l.charCodeAt(d%2Ba-1)%3D%3D%3D13%3F(i%3D!0%2Cn%2B%3Dl.substr(d%2Ca-1))%3An%2B%3Dl.substr(d%2Ca)%2C!0%3Bn%2B%3Dthis._EOLNormalized%3Fl.substring(d%2CMath.max(d%2Cf%5Bu%2B1%5D-this._EOLLength))%3Al.substring(d%2Cf%5Bu%2B1%5D).replace(%2F(%5Cr%5Cn%7C%5Cr%7C%5Cn)%24%2F%2C%22%22)%2Ce%5Bt%2B%2B%5D%3Dn%3Bfor(let%20b%3Du%2B1%3Bb%3Cc%3Bb%2B%2B)n%3Dthis._EOLNormalized%3Fl.substring(f%5Bb%5D%2Cf%5Bb%2B1%5D-this._EOLLength)%3Al.substring(f%5Bb%5D%2Cf%5Bb%2B1%5D).replace(%2F(%5Cr%5Cn%7C%5Cr%7C%5Cn)%24%2F%2C%22%22)%2Ce%5Bt%2B%2B%5D%3Dn%3Breturn!this._EOLNormalized%26%26l.charCodeAt(f%5Bc%5D%2Bo.end.column-1)%3D%3D%3D13%3F(i%3D!0%2Co.end.column%3D%3D%3D0%3Ft--%3An%3Dl.substr(f%5Bc%5D%2Co.end.column-1))%3An%3Dl.substr(f%5Bc%5D%2Co.end.column)%2C!0%7D)%2Ci%26%26(e%5Bt%2B%2B%5D%3Dn%2Cn%3D%22%22)%2Ce%5Bt%2B%2B%5D%3Dn%2Ce%7DgetLength()%7Breturn%20this._length%7DgetLineCount()%7Breturn%20this._lineCnt%7DgetLineContent(e)%7Breturn%20this._lastVisitedLine.lineNumber%3D%3D%3De%3Fthis._lastVisitedLine.value%3A(this._lastVisitedLine.lineNumber%3De%2Ce%3D%3D%3Dthis._lineCnt%3Fthis._lastVisitedLine.value%3Dthis.getLineRawContent(e)%3Athis._EOLNormalized%3Fthis._lastVisitedLine.value%3Dthis.getLineRawContent(e%2Cthis._EOLLength)%3Athis._lastVisitedLine.value%3Dthis.getLineRawContent(e).replace(%2F(%5Cr%5Cn%7C%5Cr%7C%5Cn)%24%2F%2C%22%22)%2Cthis._lastVisitedLine.value)%7D_getCharCode(e)%7Bif(e.remainder%3D%3D%3De.node.piece.length)%7Blet%20t%3De.node.next()%3Bif(!t)return%200%3Blet%20n%3Dthis._buffers%5Bt.piece.bufferIndex%5D%2Ci%3Dthis.offsetInBuffer(t.piece.bufferIndex%2Ct.piece.start)%3Breturn%20n.buffer.charCodeAt(i)%7Delse%7Blet%20t%3Dthis._buffers%5Be.node.piece.bufferIndex%5D%2Ci%3Dthis.offsetInBuffer(e.node.piece.bufferIndex%2Ce.node.piece.start)%2Be.remainder%3Breturn%20t.buffer.charCodeAt(i)%7D%7DgetLineCharCode(e%2Ct)%7Blet%20n%3Dthis.nodeAt2(e%2Ct%2B1)%3Breturn%20this._getCharCode(n)%7DgetLineLength(e)%7Bif(e%3D%3D%3Dthis.getLineCount())%7Blet%20t%3Dthis.getOffsetAt(e%2C1)%3Breturn%20this.getLength()-t%7Dreturn%20this.getOffsetAt(e%2B1%2C1)-this.getOffsetAt(e%2C1)-this._EOLLength%7DgetCharCode(e)%7Blet%20t%3Dthis.nodeAt(e)%3Breturn%20this._getCharCode(t)%7DgetNearestChunk(e)%7Blet%20t%3Dthis.nodeAt(e)%3Bif(t.remainder%3D%3D%3Dt.node.piece.length)%7Blet%20n%3Dt.node.next()%3Bif(!n%7C%7Cn%3D%3D%3Dm)return%22%22%3Blet%20i%3Dthis._buffers%5Bn.piece.bufferIndex%5D%2Cs%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Breturn%20i.buffer.substring(s%2Cs%2Bn.piece.length)%7Delse%7Blet%20n%3Dthis._buffers%5Bt.node.piece.bufferIndex%5D%2Ci%3Dthis.offsetInBuffer(t.node.piece.bufferIndex%2Ct.node.piece.start)%2Cs%3Di%2Bt.remainder%2Co%3Di%2Bt.node.piece.length%3Breturn%20n.buffer.substring(s%2Co)%7D%7DfindMatchesInNode(e%2Ct%2Cn%2Ci%2Cs%2Co%2Ca%2Cl%2Cf%2Cu%2Cc)%7Blet%20d%3Dthis._buffers%5Be.piece.bufferIndex%5D%2Cb%3Dthis.offsetInBuffer(e.piece.bufferIndex%2Ce.piece.start)%2Ck%3Dthis.offsetInBuffer(e.piece.bufferIndex%2Cs)%2CL%3Dthis.offsetInBuffer(e.piece.bufferIndex%2Co)%2CS%2Cw%3D%7Bline%3A0%2Ccolumn%3A0%7D%2CI%2CN%3Bt._wordSeparators%3F(I%3Dd.buffer.substring(k%2CL)%2CN%3D_%3D%3E_%2Bk%2Ct.reset(0))%3A(I%3Dd.buffer%2CN%3D_%3D%3E_%2Ct.reset(k))%3Bdo%20if(S%3Dt.next(I)%2CS)%7Bif(N(S.index)%3E%3DL)return%20u%3Bthis.positionInBuffer(e%2CN(S.index)-b%2Cw)%3Blet%20_%3Dthis.getLineFeedCnt(e.piece.bufferIndex%2Cs%2Cw)%2Cg%3Dw.line%3D%3D%3Ds.line%3Fw.column-s.column%2Bi%3Aw.column%2B1%2Ch%3Dg%2BS%5B0%5D.length%3Bif(c%5Bu%2B%2B%5D%3Dee(new%20A(n%2B_%2Cg%2Cn%2B_%2Ch)%2CS%2Cl)%2CN(S.index)%2BS%5B0%5D.length%3E%3DL%7C%7Cu%3E%3Df)return%20u%7Dwhile(S)%3Breturn%20u%7DfindMatchesLineByLine(e%2Ct%2Cn%2Ci)%7Blet%20s%3D%5B%5D%2Co%3D0%2Ca%3Dnew%20K(t.wordSeparators%2Ct.regex)%2Cl%3Dthis.nodeAt2(e.startLineNumber%2Ce.startColumn)%3Bif(l%3D%3D%3Dnull)return%5B%5D%3Blet%20f%3Dthis.nodeAt2(e.endLineNumber%2Ce.endColumn)%3Bif(f%3D%3D%3Dnull)return%5B%5D%3Blet%20u%3Dthis.positionInBuffer(l.node%2Cl.remainder)%2Cc%3Dthis.positionInBuffer(f.node%2Cf.remainder)%3Bif(l.node%3D%3D%3Df.node)return%20this.findMatchesInNode(l.node%2Ca%2Ce.startLineNumber%2Ce.startColumn%2Cu%2Cc%2Ct%2Cn%2Ci%2Co%2Cs)%2Cs%3Blet%20d%3De.startLineNumber%2Cb%3Dl.node%3Bfor(%3Bb!%3D%3Df.node%3B)%7Blet%20L%3Dthis.getLineFeedCnt(b.piece.bufferIndex%2Cu%2Cb.piece.end)%3Bif(L%3E%3D1)%7Blet%20w%3Dthis._buffers%5Bb.piece.bufferIndex%5D.lineStarts%2CI%3Dthis.offsetInBuffer(b.piece.bufferIndex%2Cb.piece.start)%2CN%3Dw%5Bu.line%2BL%5D%2C_%3Dd%3D%3D%3De.startLineNumber%3Fe.startColumn%3A1%3Bif(o%3Dthis.findMatchesInNode(b%2Ca%2Cd%2C_%2Cu%2Cthis.positionInBuffer(b%2CN-I)%2Ct%2Cn%2Ci%2Co%2Cs)%2Co%3E%3Di)return%20s%3Bd%2B%3DL%7Dlet%20S%3Dd%3D%3D%3De.startLineNumber%3Fe.startColumn-1%3A0%3Bif(d%3D%3D%3De.endLineNumber)%7Blet%20w%3Dthis.getLineContent(d).substring(S%2Ce.endColumn-1)%3Breturn%20o%3Dthis._findMatchesInLine(t%2Ca%2Cw%2Ce.endLineNumber%2CS%2Co%2Cs%2Cn%2Ci)%2Cs%7Dif(o%3Dthis._findMatchesInLine(t%2Ca%2Cthis.getLineContent(d).substr(S)%2Cd%2CS%2Co%2Cs%2Cn%2Ci)%2Co%3E%3Di)return%20s%3Bd%2B%2B%2Cl%3Dthis.nodeAt2(d%2C1)%2Cb%3Dl.node%2Cu%3Dthis.positionInBuffer(l.node%2Cl.remainder)%7Dif(d%3D%3D%3De.endLineNumber)%7Blet%20L%3Dd%3D%3D%3De.startLineNumber%3Fe.startColumn-1%3A0%2CS%3Dthis.getLineContent(d).substring(L%2Ce.endColumn-1)%3Breturn%20o%3Dthis._findMatchesInLine(t%2Ca%2CS%2Ce.endLineNumber%2CL%2Co%2Cs%2Cn%2Ci)%2Cs%7Dlet%20k%3Dd%3D%3D%3De.startLineNumber%3Fe.startColumn%3A1%3Breturn%20o%3Dthis.findMatchesInNode(f.node%2Ca%2Cd%2Ck%2Cu%2Cc%2Ct%2Cn%2Ci%2Co%2Cs)%2Cs%7D_findMatchesInLine(e%2Ct%2Cn%2Ci%2Cs%2Co%2Ca%2Cl%2Cf)%7Blet%20u%3De.wordSeparators%3Bif(!l%26%26e.simpleSearch)%7Blet%20d%3De.simpleSearch%2Cb%3Dd.length%2Ck%3Dn.length%2CL%3D-b%3Bfor(%3B(L%3Dn.indexOf(d%2CL%2Bb))!%3D%3D-1%3B)if((!u%7C%7Cpe(u%2Cn%2Ck%2CL%2Cb))%26%26(a%5Bo%2B%2B%5D%3Dnew%20V(new%20A(i%2CL%2B1%2Bs%2Ci%2CL%2B1%2Bb%2Bs)%2Cnull)%2Co%3E%3Df))return%20o%3Breturn%20o%7Dlet%20c%3Bt.reset(0)%3Bdo%20if(c%3Dt.next(n)%2Cc%26%26(a%5Bo%2B%2B%5D%3Dee(new%20A(i%2Cc.index%2B1%2Bs%2Ci%2Cc.index%2B1%2Bc%5B0%5D.length%2Bs)%2Cc%2Cl)%2Co%3E%3Df))return%20o%3Bwhile(c)%3Breturn%20o%7Dinsert(e%2Ct%2Cn%3D!1)%7Bif(this._EOLNormalized%3Dthis._EOLNormalized%26%26n%2Cthis._lastVisitedLine.lineNumber%3D0%2Cthis._lastVisitedLine.value%3D%22%22%2Cthis.root!%3D%3Dm)%7Blet%7Bnode%3Ai%2Cremainder%3As%2CnodeStartOffset%3Ao%7D%3Dthis.nodeAt(e)%2Ca%3Di.piece%2Cl%3Da.bufferIndex%2Cf%3Dthis.positionInBuffer(i%2Cs)%3Bif(i.piece.bufferIndex%3D%3D%3D0%26%26a.end.line%3D%3D%3Dthis._lastChangeBufferPos.line%26%26a.end.column%3D%3D%3Dthis._lastChangeBufferPos.column%26%26o%2Ba.length%3D%3D%3De%26%26t.length%3CR)%7Bthis.appendToNode(i%2Ct)%2Cthis.computeBufferMetadata()%3Breturn%7Dif(o%3D%3D%3De)this.insertContentToNodeLeft(t%2Ci)%2Cthis._searchCache.validate(e)%3Belse%20if(o%2Bi.piece.length%3Ee)%7Blet%20u%3D%5B%5D%2Cc%3Dnew%20v(a.bufferIndex%2Cf%2Ca.end%2Cthis.getLineFeedCnt(a.bufferIndex%2Cf%2Ca.end)%2Cthis.offsetInBuffer(l%2Ca.end)-this.offsetInBuffer(l%2Cf))%3Bif(this.shouldCheckCRLF()%26%26this.endWithCR(t)%26%26this.nodeCharCodeAt(i%2Cs)%3D%3D%3D10)%7Blet%20L%3D%7Bline%3Ac.start.line%2B1%2Ccolumn%3A0%7D%3Bc%3Dnew%20v(c.bufferIndex%2CL%2Cc.end%2Cthis.getLineFeedCnt(c.bufferIndex%2CL%2Cc.end)%2Cc.length-1)%2Ct%2B%3D%60%0A%60%7Dif(this.shouldCheckCRLF()%26%26this.startWithLF(t))if(this.nodeCharCodeAt(i%2Cs-1)%3D%3D%3D13)%7Blet%20L%3Dthis.positionInBuffer(i%2Cs-1)%3Bthis.deleteNodeTail(i%2CL)%2Ct%3D%22%5Cr%22%2Bt%2Ci.piece.length%3D%3D%3D0%26%26u.push(i)%7Delse%20this.deleteNodeTail(i%2Cf)%3Belse%20this.deleteNodeTail(i%2Cf)%3Blet%20d%3Dthis.createNewPieces(t)%3Bc.length%3E0%26%26this.rbInsertRight(i%2Cc)%3Blet%20b%3Di%3Bfor(let%20k%3D0%3Bk%3Cd.length%3Bk%2B%2B)b%3Dthis.rbInsertRight(b%2Cd%5Bk%5D)%3Bthis.deleteNodes(u)%7Delse%20this.insertContentToNodeRight(t%2Ci)%7Delse%7Blet%20i%3Dthis.createNewPieces(t)%2Cs%3Dthis.rbInsertLeft(null%2Ci%5B0%5D)%3Bfor(let%20o%3D1%3Bo%3Ci.length%3Bo%2B%2B)s%3Dthis.rbInsertRight(s%2Ci%5Bo%5D)%7Dthis.computeBufferMetadata()%7Ddelete(e%2Ct)%7Bif(this._lastVisitedLine.lineNumber%3D0%2Cthis._lastVisitedLine.value%3D%22%22%2Ct%3C%3D0%7C%7Cthis.root%3D%3D%3Dm)return%3Blet%20n%3Dthis.nodeAt(e)%2Ci%3Dthis.nodeAt(e%2Bt)%2Cs%3Dn.node%2Co%3Di.node%3Bif(s%3D%3D%3Do)%7Blet%20d%3Dthis.positionInBuffer(s%2Cn.remainder)%2Cb%3Dthis.positionInBuffer(s%2Ci.remainder)%3Bif(n.nodeStartOffset%3D%3D%3De)%7Bif(t%3D%3D%3Ds.piece.length)%7Blet%20k%3Ds.next()%3BQ(this%2Cs)%2Cthis.validateCRLFWithPrevNode(k)%2Cthis.computeBufferMetadata()%3Breturn%7Dthis.deleteNodeHead(s%2Cb)%2Cthis._searchCache.validate(e)%2Cthis.validateCRLFWithPrevNode(s)%2Cthis.computeBufferMetadata()%3Breturn%7Dif(n.nodeStartOffset%2Bs.piece.length%3D%3D%3De%2Bt)%7Bthis.deleteNodeTail(s%2Cd)%2Cthis.validateCRLFWithNextNode(s)%2Cthis.computeBufferMetadata()%3Breturn%7Dthis.shrinkNode(s%2Cd%2Cb)%2Cthis.computeBufferMetadata()%3Breturn%7Dlet%20a%3D%5B%5D%2Cl%3Dthis.positionInBuffer(s%2Cn.remainder)%3Bthis.deleteNodeTail(s%2Cl)%2Cthis._searchCache.validate(e)%2Cs.piece.length%3D%3D%3D0%26%26a.push(s)%3Blet%20f%3Dthis.positionInBuffer(o%2Ci.remainder)%3Bthis.deleteNodeHead(o%2Cf)%2Co.piece.length%3D%3D%3D0%26%26a.push(o)%3Blet%20u%3Ds.next()%3Bfor(let%20d%3Du%3Bd!%3D%3Dm%26%26d!%3D%3Do%3Bd%3Dd.next())a.push(d)%3Blet%20c%3Ds.piece.length%3D%3D%3D0%3Fs.prev()%3As%3Bthis.deleteNodes(a)%2Cthis.validateCRLFWithNextNode(c)%2Cthis.computeBufferMetadata()%7DinsertContentToNodeLeft(e%2Ct)%7Blet%20n%3D%5B%5D%3Bif(this.shouldCheckCRLF()%26%26this.endWithCR(e)%26%26this.startWithLF(t))%7Blet%20o%3Dt.piece%2Ca%3D%7Bline%3Ao.start.line%2B1%2Ccolumn%3A0%7D%2Cl%3Dnew%20v(o.bufferIndex%2Ca%2Co.end%2Cthis.getLineFeedCnt(o.bufferIndex%2Ca%2Co.end)%2Co.length-1)%3Bt.piece%3Dl%2Ce%2B%3D%60%0A%60%2CC(this%2Ct%2C-1%2C-1)%2Ct.piece.length%3D%3D%3D0%26%26n.push(t)%7Dlet%20i%3Dthis.createNewPieces(e)%2Cs%3Dthis.rbInsertLeft(t%2Ci%5Bi.length-1%5D)%3Bfor(let%20o%3Di.length-2%3Bo%3E%3D0%3Bo--)s%3Dthis.rbInsertLeft(s%2Ci%5Bo%5D)%3Bthis.validateCRLFWithPrevNode(s)%2Cthis.deleteNodes(n)%7DinsertContentToNodeRight(e%2Ct)%7Bthis.adjustCarriageReturnFromNext(e%2Ct)%26%26(e%2B%3D%60%0A%60)%3Blet%20n%3Dthis.createNewPieces(e)%2Ci%3Dthis.rbInsertRight(t%2Cn%5B0%5D)%2Cs%3Di%3Bfor(let%20o%3D1%3Bo%3Cn.length%3Bo%2B%2B)s%3Dthis.rbInsertRight(s%2Cn%5Bo%5D)%3Bthis.validateCRLFWithPrevNode(i)%7DpositionInBuffer(e%2Ct%2Cn)%7Blet%20i%3De.piece%2Cs%3De.piece.bufferIndex%2Co%3Dthis._buffers%5Bs%5D.lineStarts%2Cl%3Do%5Bi.start.line%5D%2Bi.start.column%2Bt%2Cf%3Di.start.line%2Cu%3Di.end.line%2Cc%3D0%2Cd%3D0%2Cb%3D0%3Bfor(%3Bf%3C%3Du%26%26(c%3Df%2B(u-f)%2F2%7C0%2Cb%3Do%5Bc%5D%2Cc!%3D%3Du)%3B)if(d%3Do%5Bc%2B1%5D%2Cl%3Cb)u%3Dc-1%3Belse%20if(l%3E%3Dd)f%3Dc%2B1%3Belse%20break%3Breturn%20n%3F(n.line%3Dc%2Cn.column%3Dl-b%2Cnull)%3A%7Bline%3Ac%2Ccolumn%3Al-b%7D%7DgetLineFeedCnt(e%2Ct%2Cn)%7Bif(n.column%3D%3D%3D0)return%20n.line-t.line%3Blet%20i%3Dthis._buffers%5Be%5D.lineStarts%3Bif(n.line%3D%3D%3Di.length-1)return%20n.line-t.line%3Blet%20s%3Di%5Bn.line%2B1%5D%2Co%3Di%5Bn.line%5D%2Bn.column%3Bif(s%3Eo%2B1)return%20n.line-t.line%3Blet%20a%3Do-1%3Breturn%20this._buffers%5Be%5D.buffer.charCodeAt(a)%3D%3D%3D13%3Fn.line-t.line%2B1%3An.line-t.line%7DoffsetInBuffer(e%2Ct)%7Breturn%20this._buffers%5Be%5D.lineStarts%5Bt.line%5D%2Bt.column%7DdeleteNodes(e)%7Bfor(let%20t%3D0%3Bt%3Ce.length%3Bt%2B%2B)Q(this%2Ce%5Bt%5D)%7DcreateNewPieces(e)%7Bif(e.length%3ER)%7Blet%20u%3D%5B%5D%3Bfor(%3Be.length%3ER%3B)%7Blet%20d%3De.charCodeAt(R-1)%2Cb%3Bd%3D%3D%3D13%7C%7Cd%3E%3D55296%26%26d%3C%3D56319%3F(b%3De.substring(0%2CR-1)%2Ce%3De.substring(R-1))%3A(b%3De.substring(0%2CR)%2Ce%3De.substring(R))%3Blet%20k%3DE(b)%3Bu.push(new%20v(this._buffers.length%2C%7Bline%3A0%2Ccolumn%3A0%7D%2C%7Bline%3Ak.length-1%2Ccolumn%3Ab.length-k%5Bk.length-1%5D%7D%2Ck.length-1%2Cb.length))%2Cthis._buffers.push(new%20M(b%2Ck))%7Dlet%20c%3DE(e)%3Breturn%20u.push(new%20v(this._buffers.length%2C%7Bline%3A0%2Ccolumn%3A0%7D%2C%7Bline%3Ac.length-1%2Ccolumn%3Ae.length-c%5Bc.length-1%5D%7D%2Cc.length-1%2Ce.length))%2Cthis._buffers.push(new%20M(e%2Cc))%2Cu%7Dlet%20t%3Dthis._buffers%5B0%5D.buffer.length%2Cn%3DE(e%2C!1)%2Ci%3Dthis._lastChangeBufferPos%3Bif(this._buffers%5B0%5D.lineStarts%5Bthis._buffers%5B0%5D.lineStarts.length-1%5D%3D%3D%3Dt%26%26t!%3D%3D0%26%26this.startWithLF(e)%26%26this.endWithCR(this._buffers%5B0%5D.buffer))%7Bthis._lastChangeBufferPos%3D%7Bline%3Athis._lastChangeBufferPos.line%2Ccolumn%3Athis._lastChangeBufferPos.column%2B1%7D%2Ci%3Dthis._lastChangeBufferPos%3Bfor(let%20u%3D0%3Bu%3Cn.length%3Bu%2B%2B)n%5Bu%5D%2B%3Dt%2B1%3Bthis._buffers%5B0%5D.lineStarts%3Dthis._buffers%5B0%5D.lineStarts.concat(n.slice(1))%2Cthis._buffers%5B0%5D.buffer%2B%3D%22_%22%2Be%2Ct%2B%3D1%7Delse%7Bif(t!%3D%3D0)for(let%20u%3D0%3Bu%3Cn.length%3Bu%2B%2B)n%5Bu%5D%2B%3Dt%3Bthis._buffers%5B0%5D.lineStarts%3Dthis._buffers%5B0%5D.lineStarts.concat(n.slice(1))%2Cthis._buffers%5B0%5D.buffer%2B%3De%7Dlet%20s%3Dthis._buffers%5B0%5D.buffer.length%2Co%3Dthis._buffers%5B0%5D.lineStarts.length-1%2Ca%3Ds-this._buffers%5B0%5D.lineStarts%5Bo%5D%2Cl%3D%7Bline%3Ao%2Ccolumn%3Aa%7D%2Cf%3Dnew%20v(0%2Ci%2Cl%2Cthis.getLineFeedCnt(0%2Ci%2Cl)%2Cs-t)%3Breturn%20this._lastChangeBufferPos%3Dl%2C%5Bf%5D%7DgetLinesRawContent()%7Breturn%20this.getContentOfSubTree(this.root)%7DgetLineRawContent(e%2Ct%3D0)%7Blet%20n%3Dthis.root%2Ci%3D%22%22%2Cs%3Dthis._searchCache.get2(e)%3Bif(s)%7Bn%3Ds.node%3Blet%20o%3Dthis.getAccumulatedValue(n%2Ce-s.nodeStartLineNumber-1)%2Ca%3Dthis._buffers%5Bn.piece.bufferIndex%5D.buffer%2Cl%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Bif(s.nodeStartLineNumber%2Bn.piece.lineFeedCnt%3D%3D%3De)i%3Da.substring(l%2Bo%2Cl%2Bn.piece.length)%3Belse%7Blet%20f%3Dthis.getAccumulatedValue(n%2Ce-s.nodeStartLineNumber)%3Breturn%20a.substring(l%2Bo%2Cl%2Bf-t)%7D%7Delse%7Blet%20o%3D0%2Ca%3De%3Bfor(%3Bn!%3D%3Dm%3B)if(n.left!%3D%3Dm%26%26n.lf_left%3E%3De-1)n%3Dn.left%3Belse%20if(n.lf_left%2Bn.piece.lineFeedCnt%3Ee-1)%7Blet%20l%3Dthis.getAccumulatedValue(n%2Ce-n.lf_left-2)%2Cf%3Dthis.getAccumulatedValue(n%2Ce-n.lf_left-1)%2Cu%3Dthis._buffers%5Bn.piece.bufferIndex%5D.buffer%2Cc%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Breturn%20o%2B%3Dn.size_left%2Cthis._searchCache.set(%7Bnode%3An%2CnodeStartOffset%3Ao%2CnodeStartLineNumber%3Aa-(e-1-n.lf_left)%7D)%2Cu.substring(c%2Bl%2Cc%2Bf-t)%7Delse%20if(n.lf_left%2Bn.piece.lineFeedCnt%3D%3D%3De-1)%7Blet%20l%3Dthis.getAccumulatedValue(n%2Ce-n.lf_left-2)%2Cf%3Dthis._buffers%5Bn.piece.bufferIndex%5D.buffer%2Cu%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Bi%3Df.substring(u%2Bl%2Cu%2Bn.piece.length)%3Bbreak%7Delse%20e-%3Dn.lf_left%2Bn.piece.lineFeedCnt%2Co%2B%3Dn.size_left%2Bn.piece.length%2Cn%3Dn.right%7Dfor(n%3Dn.next()%3Bn!%3D%3Dm%3B)%7Blet%20o%3Dthis._buffers%5Bn.piece.bufferIndex%5D.buffer%3Bif(n.piece.lineFeedCnt%3E0)%7Blet%20a%3Dthis.getAccumulatedValue(n%2C0)%2Cl%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Breturn%20i%2B%3Do.substring(l%2Cl%2Ba-t)%2Ci%7Delse%7Blet%20a%3Dthis.offsetInBuffer(n.piece.bufferIndex%2Cn.piece.start)%3Bi%2B%3Do.substr(a%2Cn.piece.length)%7Dn%3Dn.next()%7Dreturn%20i%7DcomputeBufferMetadata()%7Blet%20e%3Dthis.root%2Ct%3D1%2Cn%3D0%3Bfor(%3Be!%3D%3Dm%3B)t%2B%3De.lf_left%2Be.piece.lineFeedCnt%2Cn%2B%3De.size_left%2Be.piece.length%2Ce%3De.right%3Bthis._lineCnt%3Dt%2Cthis._length%3Dn%2Cthis._searchCache.validate(this._length)%7DgetIndexOf(e%2Ct)%7Blet%20n%3De.piece%2Ci%3Dthis.positionInBuffer(e%2Ct)%2Cs%3Di.line-n.start.line%3Bif(this.offsetInBuffer(n.bufferIndex%2Cn.end)-this.offsetInBuffer(n.bufferIndex%2Cn.start)%3D%3D%3Dt)%7Blet%20o%3Dthis.getLineFeedCnt(e.piece.bufferIndex%2Cn.start%2Ci)%3Bif(o!%3D%3Ds)return%7Bindex%3Ao%2Cremainder%3A0%7D%7Dreturn%7Bindex%3As%2Cremainder%3Ai.column%7D%7DgetAccumulatedValue(e%2Ct)%7Bif(t%3C0)return%200%3Blet%20n%3De.piece%2Ci%3Dthis._buffers%5Bn.bufferIndex%5D.lineStarts%2Cs%3Dn.start.line%2Bt%2B1%3Breturn%20s%3En.end.line%3Fi%5Bn.end.line%5D%2Bn.end.column-i%5Bn.start.line%5D-n.start.column%3Ai%5Bs%5D-i%5Bn.start.line%5D-n.start.column%7DdeleteNodeTail(e%2Ct)%7Blet%20n%3De.piece%2Ci%3Dn.lineFeedCnt%2Cs%3Dthis.offsetInBuffer(n.bufferIndex%2Cn.end)%2Co%3Dt%2Ca%3Dthis.offsetInBuffer(n.bufferIndex%2Co)%2Cl%3Dthis.getLineFeedCnt(n.bufferIndex%2Cn.start%2Co)%2Cf%3Dl-i%2Cu%3Da-s%2Cc%3Dn.length%2Bu%3Be.piece%3Dnew%20v(n.bufferIndex%2Cn.start%2Co%2Cl%2Cc)%2CC(this%2Ce%2Cu%2Cf)%7DdeleteNodeHead(e%2Ct)%7Blet%20n%3De.piece%2Ci%3Dn.lineFeedCnt%2Cs%3Dthis.offsetInBuffer(n.bufferIndex%2Cn.start)%2Co%3Dt%2Ca%3Dthis.getLineFeedCnt(n.bufferIndex%2Co%2Cn.end)%2Cl%3Dthis.offsetInBuffer(n.bufferIndex%2Co)%2Cf%3Da-i%2Cu%3Ds-l%2Cc%3Dn.length%2Bu%3Be.piece%3Dnew%20v(n.bufferIndex%2Co%2Cn.end%2Ca%2Cc)%2CC(this%2Ce%2Cu%2Cf)%7DshrinkNode(e%2Ct%2Cn)%7Blet%20i%3De.piece%2Cs%3Di.start%2Co%3Di.end%2Ca%3Di.length%2Cl%3Di.lineFeedCnt%2Cf%3Dt%2Cu%3Dthis.getLineFeedCnt(i.bufferIndex%2Ci.start%2Cf)%2Cc%3Dthis.offsetInBuffer(i.bufferIndex%2Ct)-this.offsetInBuffer(i.bufferIndex%2Cs)%3Be.piece%3Dnew%20v(i.bufferIndex%2Ci.start%2Cf%2Cu%2Cc)%2CC(this%2Ce%2Cc-a%2Cu-l)%3Blet%20d%3Dnew%20v(i.bufferIndex%2Cn%2Co%2Cthis.getLineFeedCnt(i.bufferIndex%2Cn%2Co)%2Cthis.offsetInBuffer(i.bufferIndex%2Co)-this.offsetInBuffer(i.bufferIndex%2Cn))%2Cb%3Dthis.rbInsertRight(e%2Cd)%3Bthis.validateCRLFWithPrevNode(b)%7DappendToNode(e%2Ct)%7Bthis.adjustCarriageReturnFromNext(t%2Ce)%26%26(t%2B%3D%60%0A%60)%3Blet%20n%3Dthis.shouldCheckCRLF()%26%26this.startWithLF(t)%26%26this.endWithCR(e)%2Ci%3Dthis._buffers%5B0%5D.buffer.length%3Bthis._buffers%5B0%5D.buffer%2B%3Dt%3Blet%20s%3DE(t%2C!1)%3Bfor(let%20b%3D0%3Bb%3Cs.length%3Bb%2B%2B)s%5Bb%5D%2B%3Di%3Bif(n)%7Blet%20b%3Dthis._buffers%5B0%5D.lineStarts%5Bthis._buffers%5B0%5D.lineStarts.length-2%5D%3Bthis._buffers%5B0%5D.lineStarts.pop()%2Cthis._lastChangeBufferPos%3D%7Bline%3Athis._lastChangeBufferPos.line-1%2Ccolumn%3Ai-b%7D%7Dthis._buffers%5B0%5D.lineStarts%3Dthis._buffers%5B0%5D.lineStarts.concat(s.slice(1))%3Blet%20o%3Dthis._buffers%5B0%5D.lineStarts.length-1%2Ca%3Dthis._buffers%5B0%5D.buffer.length-this._buffers%5B0%5D.lineStarts%5Bo%5D%2Cl%3D%7Bline%3Ao%2Ccolumn%3Aa%7D%2Cf%3De.piece.length%2Bt.length%2Cu%3De.piece.lineFeedCnt%2Cc%3Dthis.getLineFeedCnt(0%2Ce.piece.start%2Cl)%2Cd%3Dc-u%3Be.piece%3Dnew%20v(e.piece.bufferIndex%2Ce.piece.start%2Cl%2Cc%2Cf)%2Cthis._lastChangeBufferPos%3Dl%2CC(this%2Ce%2Ct.length%2Cd)%7DnodeAt(e)%7Blet%20t%3Dthis.root%2Cn%3Dthis._searchCache.get(e)%3Bif(n)return%7Bnode%3An.node%2CnodeStartOffset%3An.nodeStartOffset%2Cremainder%3Ae-n.nodeStartOffset%7D%3Blet%20i%3D0%3Bfor(%3Bt!%3D%3Dm%3B)if(t.size_left%3Ee)t%3Dt.left%3Belse%20if(t.size_left%2Bt.piece.length%3E%3De)%7Bi%2B%3Dt.size_left%3Blet%20s%3D%7Bnode%3At%2Cremainder%3Ae-t.size_left%2CnodeStartOffset%3Ai%7D%3Breturn%20this._searchCache.set(s)%2Cs%7Delse%20e-%3Dt.size_left%2Bt.piece.length%2Ci%2B%3Dt.size_left%2Bt.piece.length%2Ct%3Dt.right%3Breturn%20null%7DnodeAt2(e%2Ct)%7Blet%20n%3Dthis.root%2Ci%3D0%3Bfor(%3Bn!%3D%3Dm%3B)if(n.left!%3D%3Dm%26%26n.lf_left%3E%3De-1)n%3Dn.left%3Belse%20if(n.lf_left%2Bn.piece.lineFeedCnt%3Ee-1)%7Blet%20s%3Dthis.getAccumulatedValue(n%2Ce-n.lf_left-2)%2Co%3Dthis.getAccumulatedValue(n%2Ce-n.lf_left-1)%3Breturn%20i%2B%3Dn.size_left%2C%7Bnode%3An%2Cremainder%3AMath.min(s%2Bt-1%2Co)%2CnodeStartOffset%3Ai%7D%7Delse%20if(n.lf_left%2Bn.piece.lineFeedCnt%3D%3D%3De-1)%7Blet%20s%3Dthis.getAccumulatedValue(n%2Ce-n.lf_left-2)%3Bif(s%2Bt-1%3C%3Dn.piece.length)return%7Bnode%3An%2Cremainder%3As%2Bt-1%2CnodeStartOffset%3Ai%7D%3Bt-%3Dn.piece.length-s%3Bbreak%7Delse%20e-%3Dn.lf_left%2Bn.piece.lineFeedCnt%2Ci%2B%3Dn.size_left%2Bn.piece.length%2Cn%3Dn.right%3Bfor(n%3Dn.next()%3Bn!%3D%3Dm%3B)%7Bif(n.piece.lineFeedCnt%3E0)%7Blet%20s%3Dthis.getAccumulatedValue(n%2C0)%2Co%3Dthis.offsetOfNode(n)%3Breturn%7Bnode%3An%2Cremainder%3AMath.min(t-1%2Cs)%2CnodeStartOffset%3Ao%7D%7Delse%20if(n.piece.length%3E%3Dt-1)%7Blet%20s%3Dthis.offsetOfNode(n)%3Breturn%7Bnode%3An%2Cremainder%3At-1%2CnodeStartOffset%3As%7D%7Delse%20t-%3Dn.piece.length%3Bn%3Dn.next()%7Dreturn%20null%7DnodeCharCodeAt(e%2Ct)%7Bif(e.piece.lineFeedCnt%3C1)return-1%3Blet%20n%3Dthis._buffers%5Be.piece.bufferIndex%5D%2Ci%3Dthis.offsetInBuffer(e.piece.bufferIndex%2Ce.piece.start)%2Bt%3Breturn%20n.buffer.charCodeAt(i)%7DoffsetOfNode(e)%7Bif(!e)return%200%3Blet%20t%3De.size_left%3Bfor(%3Be!%3D%3Dthis.root%3B)e.parent.right%3D%3D%3De%26%26(t%2B%3De.parent.size_left%2Be.parent.piece.length)%2Ce%3De.parent%3Breturn%20t%7DshouldCheckCRLF()%7Breturn!(this._EOLNormalized%26%26this._EOL%3D%3D%3D%60%0A%60)%7DstartWithLF(e)%7Bif(typeof%20e%3D%3D%22string%22)return%20e.charCodeAt(0)%3D%3D%3D10%3Bif(e%3D%3D%3Dm%7C%7Ce.piece.lineFeedCnt%3D%3D%3D0)return!1%3Blet%20t%3De.piece%2Cn%3Dthis._buffers%5Bt.bufferIndex%5D.lineStarts%2Ci%3Dt.start.line%2Cs%3Dn%5Bi%5D%2Bt.start.column%3Breturn%20i%3D%3D%3Dn.length-1%7C%7Cn%5Bi%2B1%5D%3Es%2B1%3F!1%3Athis._buffers%5Bt.bufferIndex%5D.buffer.charCodeAt(s)%3D%3D%3D10%7DendWithCR(e)%7Breturn%20typeof%20e%3D%3D%22string%22%3Fe.charCodeAt(e.length-1)%3D%3D%3D13%3Ae%3D%3D%3Dm%7C%7Ce.piece.lineFeedCnt%3D%3D%3D0%3F!1%3Athis.nodeCharCodeAt(e%2Ce.piece.length-1)%3D%3D%3D13%7DvalidateCRLFWithPrevNode(e)%7Bif(this.shouldCheckCRLF()%26%26this.startWithLF(e))%7Blet%20t%3De.prev()%3Bthis.endWithCR(t)%26%26this.fixCRLF(t%2Ce)%7D%7DvalidateCRLFWithNextNode(e)%7Bif(this.shouldCheckCRLF()%26%26this.endWithCR(e))%7Blet%20t%3De.next()%3Bthis.startWithLF(t)%26%26this.fixCRLF(e%2Ct)%7D%7DfixCRLF(e%2Ct)%7Blet%20n%3D%5B%5D%2Ci%3Dthis._buffers%5Be.piece.bufferIndex%5D.lineStarts%2Cs%3Be.piece.end.column%3D%3D%3D0%3Fs%3D%7Bline%3Ae.piece.end.line-1%2Ccolumn%3Ai%5Be.piece.end.line%5D-i%5Be.piece.end.line-1%5D-1%7D%3As%3D%7Bline%3Ae.piece.end.line%2Ccolumn%3Ae.piece.end.column-1%7D%3Blet%20o%3De.piece.length-1%2Ca%3De.piece.lineFeedCnt-1%3Be.piece%3Dnew%20v(e.piece.bufferIndex%2Ce.piece.start%2Cs%2Ca%2Co)%2CC(this%2Ce%2C-1%2C-1)%2Ce.piece.length%3D%3D%3D0%26%26n.push(e)%3Blet%20l%3D%7Bline%3At.piece.start.line%2B1%2Ccolumn%3A0%7D%2Cf%3Dt.piece.length-1%2Cu%3Dthis.getLineFeedCnt(t.piece.bufferIndex%2Cl%2Ct.piece.end)%3Bt.piece%3Dnew%20v(t.piece.bufferIndex%2Cl%2Ct.piece.end%2Cu%2Cf)%2CC(this%2Ct%2C-1%2C-1)%2Ct.piece.length%3D%3D%3D0%26%26n.push(t)%3Blet%20c%3Dthis.createNewPieces(%60%5Cr%0A%60)%3Bthis.rbInsertRight(e%2Cc%5B0%5D)%3Bfor(let%20d%3D0%3Bd%3Cn.length%3Bd%2B%2B)Q(this%2Cn%5Bd%5D)%7DadjustCarriageReturnFromNext(e%2Ct)%7Bif(this.shouldCheckCRLF()%26%26this.endWithCR(e))%7Blet%20n%3Dt.next()%3Bif(this.startWithLF(n))%7Bif(e%2B%3D%60%0A%60%2Cn.piece.length%3D%3D%3D1)Q(this%2Cn)%3Belse%7Blet%20i%3Dn.piece%2Cs%3D%7Bline%3Ai.start.line%2B1%2Ccolumn%3A0%7D%2Co%3Di.length-1%2Ca%3Dthis.getLineFeedCnt(i.bufferIndex%2Cs%2Ci.end)%3Bn.piece%3Dnew%20v(i.bufferIndex%2Cs%2Ci.end%2Ca%2Co)%2CC(this%2Cn%2C-1%2C-1)%7Dreturn!0%7D%7Dreturn!1%7Diterate(e%2Ct)%7Bif(e%3D%3D%3Dm)return%20t(m)%3Blet%20n%3Dthis.iterate(e.left%2Ct)%3Breturn%20n%26%26t(e)%26%26this.iterate(e.right%2Ct)%7DgetNodeContent(e)%7Bif(e%3D%3D%3Dm)return%22%22%3Blet%20t%3Dthis._buffers%5Be.piece.bufferIndex%5D%2Cn%3De.piece%2Ci%3Dthis.offsetInBuffer(n.bufferIndex%2Cn.start)%2Cs%3Dthis.offsetInBuffer(n.bufferIndex%2Cn.end)%3Breturn%20t.buffer.substring(i%2Cs)%7DgetPieceContent(e)%7Blet%20t%3Dthis._buffers%5Be.bufferIndex%5D%2Cn%3Dthis.offsetInBuffer(e.bufferIndex%2Ce.start)%2Ci%3Dthis.offsetInBuffer(e.bufferIndex%2Ce.end)%3Breturn%20t.buffer.substring(n%2Ci)%7DrbInsertRight(e%2Ct)%7Blet%20n%3Dnew%20j(t%2C1)%3Bif(n.left%3Dm%2Cn.right%3Dm%2Cn.parent%3Dm%2Cn.size_left%3D0%2Cn.lf_left%3D0%2Cthis.root%3D%3D%3Dm)this.root%3Dn%2Cn.color%3D0%3Belse%20if(e.right%3D%3D%3Dm)e.right%3Dn%2Cn.parent%3De%3Belse%7Blet%20s%3Due(e.right)%3Bs.left%3Dn%2Cn.parent%3Ds%7Dreturn%20Ue(this%2Cn)%2Cn%7DrbInsertLeft(e%2Ct)%7Blet%20n%3Dnew%20j(t%2C1)%3Bif(n.left%3Dm%2Cn.right%3Dm%2Cn.parent%3Dm%2Cn.size_left%3D0%2Cn.lf_left%3D0%2Cthis.root%3D%3D%3Dm)this.root%3Dn%2Cn.color%3D0%3Belse%20if(e.left%3D%3D%3Dm)e.left%3Dn%2Cn.parent%3De%3Belse%7Blet%20i%3DRe(e.left)%3Bi.right%3Dn%2Cn.parent%3Di%7Dreturn%20Ue(this%2Cn)%2Cn%7DgetContentOfSubTree(e)%7Blet%20t%3D%22%22%3Breturn%20this.iterate(e%2Cn%3D%3E(t%2B%3Dthis.getNodeContent(n)%2C!0))%2Ct%7D%7D%3Bvar%20zt%3DString.fromCharCode(65279)%3Bfunction%20jt(r)%7Breturn!!(r%26%26r.length%3E0%26%26r.charCodeAt(0)%3D%3D%3D65279)%7Dvar%20He%3Dclass%7Bconstructor(e%2Ct%2Cn%2Ci%2Cs%2Co)%7Bthis._chunks%3De%3Bthis._bom%3Dt%3Bthis._cr%3Dn%3Bthis._lf%3Di%3Bthis._crlf%3Ds%3Bthis._normalizeEOL%3Do%7D_getEOL(e)%7Blet%20t%3Dthis._cr%2Bthis._lf%2Bthis._crlf%2Cn%3Dthis._cr%2Bthis._crlf%3Breturn%20t%3D%3D%3D0%3Fe%3D%3D%3D1%3F%60%0A%60%3A%60%5Cr%0A%60%3An%3Et%2F2%3F%60%5Cr%0A%60%3A%60%0A%60%7Dcreate(e)%7Blet%20t%3Dthis._getEOL(e)%2Cn%3Dthis._chunks%3Bif(this._normalizeEOL%26%26(t%3D%3D%3D%60%5Cr%0A%60%26%26(this._cr%3E0%7C%7Cthis._lf%3E0)%7C%7Ct%3D%3D%3D%60%0A%60%26%26(this._cr%3E0%7C%7Cthis._crlf%3E0)))for(let%20i%3D0%2Cs%3Dn.length%3Bi%3Cs%3Bi%2B%2B)%7Blet%20o%3Dn%5Bi%5D.buffer.replace(%2F%5Cr%5Cn%7C%5Cr%7C%5Cn%2Fg%2Ct)%2Ca%3DE(o)%3Bn%5Bi%5D%3Dnew%20M(o%2Ca)%7Dreturn%20new%20ge(n%2Ct%2Cthis._normalizeEOL)%7DgetFirstLineText(e)%7Breturn%20this._chunks%5B0%5D.buffer.substr(0%2C100).split(%2F%5Cr%5Cn%7C%5Cr%7C%5Cn%2F)%5B0%5D%7D%7D%2Cte%3Dclass%7Bconstructor()%7Bthis.chunks%3D%5B%5D%2Cthis.BOM%3D%22%22%2Cthis._hasPreviousChar%3D!1%2Cthis._previousChar%3D0%2Cthis._tmpLineStarts%3D%5B%5D%2Cthis.cr%3D0%2Cthis.lf%3D0%2Cthis.crlf%3D0%7DacceptChunk(e)%7Bif(e.length%3D%3D%3D0)return%3Bthis.chunks.length%3D%3D%3D0%26%26jt(e)%26%26(this.BOM%3Dzt%2Ce%3De.substr(1))%3Blet%20t%3De.charCodeAt(e.length-1)%3Bt%3D%3D%3D13%7C%7Ct%3E%3D55296%26%26t%3C%3D56319%3F(this._acceptChunk1(e.substr(0%2Ce.length-1)%2C!1)%2Cthis._hasPreviousChar%3D!0%2Cthis._previousChar%3Dt)%3A(this._acceptChunk1(e%2C!1)%2Cthis._hasPreviousChar%3D!1%2Cthis._previousChar%3Dt)%7D_acceptChunk1(e%2Ct)%7B!t%26%26e.length%3D%3D%3D0%7C%7C(this._hasPreviousChar%3Fthis._acceptChunk2(String.fromCharCode(this._previousChar)%2Be)%3Athis._acceptChunk2(e))%7D_acceptChunk2(e)%7Blet%20t%3Dgt(this._tmpLineStarts%2Ce)%3Bthis.chunks.push(new%20M(e%2Ct.lineStarts))%2Cthis.cr%2B%3Dt.cr%2Cthis.lf%2B%3Dt.lf%2Cthis.crlf%2B%3Dt.crlf%7Dfinish(e%3D!0)%7Breturn%20this._finish()%2Cnew%20He(this.chunks%2Cthis.BOM%2Cthis.cr%2Cthis.lf%2Cthis.crlf%2Ce)%7D_finish()%7Bif(this.chunks.length%3D%3D%3D0%26%26this._acceptChunk1(%22%22%2C!0)%2Cthis._hasPreviousChar)%7Bthis._hasPreviousChar%3D!1%3Blet%20e%3Dthis.chunks%5Bthis.chunks.length-1%5D%3Be.buffer%2B%3DString.fromCharCode(this._previousChar)%3Blet%20t%3DE(e.buffer)%3Be.lineStarts%3Dt%2Cthis._previousChar%3D%3D%3D13%26%26this.cr%2B%2B%7D%7D%7D%3Bvar%20Kt%3D%22default%22%3Bfunction%20me()%7Breturn%20Kt%7Dvar%20mt%3Dnew%20Map%2CGe%3Dclass%7Bconstructor()%7Bthis.listeners%3D%7B%7D%7Don(e%2Ct)%7Bthis.listeners%5Be%5D%7C%7C(this.listeners%5Be%5D%3D%5B%5D)%2Cthis.listeners%5Be%5D%3F.push(t)%7Doff(e%2Ct)%7Bthis.listeners%5Be%5D%26%26(this.listeners%5Be%5D%3Dthis.listeners%5Be%5D%3F.filter(n%3D%3En!%3D%3Dt))%7Ddispose()%7Bthis.listeners%3D%7B%7D%7DremoveAllListeners()%7Bthis.listeners%3D%7B%7D%7Demit(e%2Ct)%7Bif(this.listeners%5Be%5D)for(let%20n%20of%20this.listeners%5Be%5D)n(t)%7D%7D%2Cbt%3D()%3D%3E%7Blet%20r%3Dme()%3Bif(!r)throw%20new%20Error(%22currentNameSpaceId%20is%20not%20set%22)%3Blet%20e%3Dmt.get(r)%3Breturn%20e%7C%7C(e%3Dnew%20Ge%2Cmt.set(r%2Ce))%2Ce%7D%3Bvar%20_t%3Dnew%20Map%2CZe%3Dclass%7Bconstructor()%7Blet%20e%3DdecodeURIComponent(%22%25WORKER_RAW%25%22)%2Ct%3Dnew%20Blob(%5Be%5D%2C%7Btype%3A%22application%2Fjavascript%22%7D)%2Cn%3DURL.createObjectURL(t)%3Bthis._worker%3Dnew%20Worker(n)%2Cthis._callbacks%3Dnew%20Map%2Cthis._worker.onmessage%3Dthis._handleWorkerMessage.bind(this)%7Dasync%20init(e)%7Bawait%20this._sendRequest(%22init%22%2C%7Bvalue%3Ae%7D)%7DupdateModel(e)%7Breturn%20this._sendRequest(%22updateModel%22%2C%7Bop%3Ae%7D)%7Dundo()%7Breturn%20this._sendRequest(%22undo%22%2C%7B%7D)%7Dredo()%7Breturn%20this._sendRequest(%22redo%22%2C%7B%7D)%7DformatJson(e)%7Breturn%20this._sendRequest(%22format%22%2C%7Boptions%3Ae%7D)%7DfoldRange()%7Breturn%20this._sendRequest(%22foldRange%22%2C%7B%7D)%7Dvalidate()%7Breturn%20this._sendRequest(%22validate%22%2C%7B%7D)%7D_sendRequest(e%2Ct)%7Breturn%20new%20Promise((n%2Ci)%3D%3E%7Blet%20s%3DDate.now()%2BMath.random()%3Bthis._callbacks.set(s%2Cn)%2Cthis._worker.postMessage(%7BmessageId%3As%2Cmethod%3Ae%2Cparams%3At%7D)%7D)%7D_handleWorkerMessage(e)%7Blet%7BmessageId%3At%2Cresult%3An%2Cerror%3Ai%7D%3De.data%2Cs%3Dthis._callbacks.get(t)%3Bs%26%26(s(i%3Fnew%20Error(i)%3An)%2Cthis._callbacks.delete(t))%7Ddispose()%7Bthis._worker.terminate()%2Cthis._callbacks.clear()%7D%7D%3Bfunction%20Nt()%7Blet%20r%3Dme()%3Bif(!r)throw%20new%20Error(%22No%20active%20worker%20ID%20set%22)%3Blet%20e%3D_t.get(r)%3Breturn%20e%7C%7C(e%3Dnew%20Ze%2C_t.set(r%2Ce))%2Ce%7Dvar%20Dt%3Dtypeof%20self%3D%3D%22object%22%26%26self.constructor%26%26self.constructor.name%3D%3D%3D%22DedicatedWorkerGlobalScope%22%3Bfunction%20ne()%7Breturn%20Dt%7Dvar%20re%3Dclass%7Bconstructor(e%2Ct)%7Bthis.model%3De%3Bthis.operation%3Dt%3Bthis.oldPos%3D%7B...e.lastChangeBufferPos%7D%2Cthis.model.updateLastChangeBufferPos(t)%2Cthis.newPos%3D%7B...e.lastChangeBufferPos%7D%7DupdateBufferPos(e)%7Bthis.model.lastChangeBufferPos%3D%7B...e%3Fthis.oldPos%3Athis.newPos%7D%7D%7D%2Cbe%3Dclass%20extends%20re%7Bexecute()%7Bthis.model.pieceTree.insert(this.operation.rangeOffset%2Cthis.operation.newText)%2Cthis.updateBufferPos(!1)%7Dundo()%7Bthis.model.pieceTree.delete(this.operation.rangeOffset%2Cthis.operation.newText.length)%2Cthis.updateBufferPos(!0)%7D%7D%2C_e%3Dclass%20extends%20re%7Bexecute()%7Bthis.model.pieceTree.delete(this.operation.rangeOffset%2Cthis.operation.rangeLength)%2Cthis.updateBufferPos(!1)%7Dundo()%7Bthis.model.pieceTree.insert(this.operation.rangeOffset%2Cthis.operation.oldText)%2Cthis.updateBufferPos(!0)%7D%7D%2CNe%3Dclass%20extends%20re%7Bexecute()%7Bthis.model.pieceTree.delete(this.operation.rangeOffset%2Cthis.operation.oldText.length)%2Cthis.model.pieceTree.insert(this.operation.rangeOffset%2Cthis.operation.newText)%2Cthis.updateBufferPos(!1)%7Dundo()%7Bthis.model.pieceTree.delete(this.operation.rangeOffset%2Cthis.operation.newText.length)%2Cthis.model.pieceTree.insert(this.operation.rangeOffset%2Cthis.operation.oldText)%2Cthis.updateBufferPos(!0)%7D%7D%2Cxe%3Dclass%7Bconstructor(e%2Ct)%7Bthis.model%3De%3Bthis.operation%3Dt%3Bthis.oldPos%3D%7B...e.lastChangeBufferPos%7D%2Cthis.newPos%3D%7B...e.lastChangeBufferPos%7D%7Dexecute()%7Bfor(let%20e%3D0%3Be%3Cthis.operation.length%3Be%2B%2B)%7Blet%20t%3Dthis.operation%5Be%5D%3Bswitch(t.type)%7Bcase%22insert%22%3Athis.model.pieceTree.insert(t.rangeOffset%2Ct.newText)%3Bbreak%3Bcase%22delete%22%3Athis.model.pieceTree.delete(t.rangeOffset%2Ct.rangeLength)%3Bbreak%3Bcase%22replace%22%3Athis.model.pieceTree.delete(t.rangeOffset%2Ct.oldText.length)%2Cthis.model.pieceTree.insert(t.rangeOffset%2Ct.newText)%3Bbreak%7D%7Dthis.model.lastChangeBufferPos%3D%7B...this.newPos%7D%7Dundo()%7Bfor(let%20e%3Dthis.operation.length-1%3Be%3E%3D0%3Be--)%7Blet%20t%3Dthis.operation%5Be%5D%3Bt.newText%26%26t.oldText%3F(this.model.pieceTree.delete(t.rangeOffset%2Ct.newText.length)%2Cthis.model.pieceTree.insert(t.rangeOffset%2Ct.oldText))%3At.newText%3Fthis.model.pieceTree.delete(t.rangeOffset%2Ct.newText.length)%3Athis.model.pieceTree.insert(t.rangeOffset%2Ct.oldText)%7Dthis.model.lastChangeBufferPos%3D%7B...this.oldPos%7D%7D%7D%3Bvar%20Te%3Dclass%7Bconstructor(e%2Ct%3D!0)%7Bthis._undoStack%3D%5B%5D%3Bthis._redoStack%3D%5B%5D%3Bthis.MAX_STACK_SIZE%3D20%3Bthis.lastChangeBufferPos%3D%7BlineNumber%3A1%2Ccolumn%3A1%7D%3Bthis._jsonWorkerManager%3Dnull%3Bthis.emitter%3Dnull%3Bthis._normalizeEOL%3Dt%2Cthis._pieceTree%3Dthis.createTextBuffer(e)%2Cne()%7C%7C(this._jsonWorkerManager%3DNt()%2Cthis.emitter%3Dbt())%7Dget%20pieceTree()%7Breturn%20this._pieceTree%7DcreateTextBufferFactory(e)%7Blet%20t%3Dnew%20te%3Breturn%20t.acceptChunk(e)%2Ct.finish(this._normalizeEOL)%7DcreateTextBuffer(e)%7Breturn%20this.createTextBufferFactory(e).create(1)%7DgetLineCount()%7Breturn%20this._pieceTree.getLineCount()%7DgetLineContent(e)%7Breturn%20this._pieceTree.getLineContent(e)%7DgetLineLength(e)%7Breturn%20this._pieceTree.getLineLength(e)%7DgetOffsetAt(e%2Ct)%7Breturn%20this._pieceTree.getOffsetAt(e%2Ct)%7DpositionAt(e)%7Breturn%20e%3DMath.min(this._pieceTree.getLength()%2CMath.max(0%2Ce))%2Cthis._pieceTree.getPositionAt(e)%7D_createCommand(e)%7Bif(Array.isArray(e))return%20new%20xe(this%2Ce)%3Bswitch(e.type)%7Bcase%22insert%22%3Areturn%20new%20be(this%2Ce)%3Bcase%22delete%22%3Areturn%20new%20_e(this%2Ce)%3Bcase%22replace%22%3Areturn%20new%20Ne(this%2Ce)%3Bdefault%3Athrow%20new%20Error(%22Unknown%20operation%20type%22)%7D%7DapplyOperation(e)%7Bthis._redoStack%3D%5B%5D%3Blet%20t%3Dthis._createCommand(e)%3Bthis.pushUndoStack(t)%2Ct.execute()%2Cne()%7C%7Cthis.emitter%3F.emit(%22contentChanged%22%2Ce)%2Cthis._jsonWorkerManager%26%26this._jsonWorkerManager.updateModel(e).then(n%3D%3Ethis._jsonWorkerManager%3F.validate()).then(n%3D%3E%7Bthis.emitter%3F.emit(%22problemsChanged%22%2C%7Bproblems%3An.problems%2Croot%3An.root%7D)%7D)%7DupdateLastChangeBufferPos(e)%7Bif(e.keepPosition)%7Bthis.lastChangeBufferPos%3De.keepPosition%3Breturn%7Dswitch(e.type)%7Bcase%22insert%22%3Athis.lastChangeBufferPos.column%2B%3De.newText.length%3Bbreak%3Bcase%22delete%22%3Aif(this.lastChangeBufferPos.column%3D%3D%3D1)this.lastChangeBufferPos.lineNumber-%3D1%2Cthis.lastChangeBufferPos.column%3Dthis.getLineLength(this.lastChangeBufferPos.lineNumber)%2B1%3Belse%7Blet%20i%3De.range.startColumn%2Cs%3De.rangeLength%3D%3D%3D1%3Fi-1%3Ai%3Bthis.lastChangeBufferPos.column%3Ds%7Dbreak%3Bcase%22replace%22%3Alet%20t%3De.range.startLineNumber%2Cn%3De.range.startColumn%2Be.newText.length%3Bthis.lastChangeBufferPos.lineNumber%3Dt%2Cthis.lastChangeBufferPos.column%3Dn%3Bbreak%7D%7DpushUndoStack(e)%7Bthis._undoStack.push(e)%2Cthis._undoStack.length%3Ethis.MAX_STACK_SIZE%26%26this._undoStack.shift()%7DpushRedoStack(e)%7Bthis._redoStack.push(e)%2Cthis._redoStack.length%3Ethis.MAX_STACK_SIZE%26%26this._redoStack.shift()%7DcanUndo()%7Breturn%20this._undoStack.length%3E0%7DcanRedo()%7Breturn%20this._redoStack.length%3E0%7Dundo()%7Bif(!this.canUndo())return%3Blet%20e%3Dthis._undoStack.pop()%3Be.undo()%2Cthis._redoStack.push(e)%2Cne()%7C%7Cthis.emitter%3F.emit(%22contentChanged%22%2Ce.operation)%2Cthis._jsonWorkerManager%26%26this._jsonWorkerManager.undo().then(t%3D%3Ethis._jsonWorkerManager%3F.validate()).then(t%3D%3E%7Bthis.emitter%3F.emit(%22problemsChanged%22%2C%7Bproblems%3At.problems%2Croot%3At.root%7D)%7D)%7Dredo()%7Bif(!this.canRedo())return%3Blet%20e%3Dthis._redoStack.pop()%3Be.execute()%2Cthis._undoStack.push(e)%2Cne()%7C%7Cthis.emitter%3F.emit(%22contentChanged%22%2Ce.operation)%2Cthis._jsonWorkerManager%26%26this._jsonWorkerManager.redo().then(t%3D%3Ethis._jsonWorkerManager%3F.validate()).then(t%3D%3E%7Bthis.emitter%3F.emit(%22problemsChanged%22%2C%7Bproblems%3At.problems%2Croot%3At.root%7D)%7D)%7DgetValue()%7Breturn%20this._pieceTree.getValueInRange(%7BstartLineNumber%3A1%2CstartColumn%3A1%2CendLineNumber%3Athis._pieceTree.getLineCount()%2CendColumn%3Athis._pieceTree.getLineContent(this._pieceTree.getLineCount()).length%2B1%7D)%7DsetValue(e)%7Blet%20t%3Dnew%20te%3Bt.acceptChunk(e)%2Cthis._pieceTree%3Dt.finish(this._normalizeEOL).create(1)%7DgetEOL()%7Breturn%20this._pieceTree.getEOL()%7D_getEndOfLine(e)%7Bswitch(e)%7Bcase%201%3Areturn%60%0A%60%3Bcase%202%3Areturn%60%5Cr%0A%60%3Bcase%200%3Areturn%20this.getEOL()%3Bdefault%3Athrow%20new%20Error(%22Unknown%20EOL%20preference%22)%7D%7DgetValueInRange(e%2Ct%3D0)%7Breturn%20this._pieceTree.getValueInRange(e%2Cthis._getEndOfLine(t))%7DgetFullModelRange()%7Blet%20e%3Dthis.getLineCount()%3Breturn%20new%20A(1%2C1%2Ce%2Cthis.getLineLength(e)%2B1)%7DfindMatchesLineByLine(e%2Ct%2Cn%2Ci)%7Breturn%20this._pieceTree.findMatchesLineByLine(e%2Ct%2Cn%2Ci)%7DfindMatches(e%2Ct%2Cn%2Ci%2Cs%2Co%2Ca%3D1%2F0)%7Blet%20l%3Dnull%3Bl%3D%3D%3Dnull%26%26(l%3D%5Bthis.getFullModelRange()%5D)%2Cl%3Dl.sort((c%2Cd)%3D%3Ec.startLineNumber-d.startLineNumber%7C%7Cc.startColumn-d.startColumn)%3Blet%20f%3D%5B%5D%3Bf.push(l.reduce((c%2Cd)%3D%3EA.areIntersecting(c%2Cd)%3Fc.plusRange(d)%3A(f.push(c)%2Cd)))%3Blet%20u%3Bif(!n%26%26e.indexOf(%60%0A%60)%3C0)%7Blet%20d%3Dnew%20Y(e%2Cn%2Ci%2Cs).parseSearchRequest()%3Bif(!d)return%5B%5D%3Bu%3Db%3D%3Ethis.findMatchesLineByLine(b%2Cd%2Co%2Ca)%7Delse%20u%3Dc%3D%3Ehe.findMatches(this%2Cnew%20Y(e%2Cn%2Ci%2Cs)%2Cc%2Co%2Ca)%3Breturn%20f.map(u).reduce((c%2Cd)%3D%3Ec.concat(d)%2C%5B%5D)%7D%7D%3Bfunction%20xt(r%2Ce%3D!0)%7Breturn%20new%20Te(r%2Ce)%7Dvar%20ke%3Dclass%7Bconstructor(e)%7Bthis._model%3Dnull%3Bthis._model%3Dxt(e)%7DgetModel()%7Breturn%20this._model%7Dformat(e)%7Bif(!this._model)throw%20new%20Error(%22Model%20not%20initialized%22)%3Breturn%20ot(this._model%2Ce)%7DfoldRange()%7Bif(!this._model)throw%20new%20Error(%22Model%20not%20initialized%22)%3Breturn%20Fe(this._model)%7Dvalidate()%7Bif(!this._model)throw%20new%20Error(%22Model%20not%20initialized%22)%3Breturn%20lt(this._model)%7DupdateModel(e)%7Breturn%20this._model%3F.applyOperation(e)%2Ce%7Dundo()%7Bthis._model%3F.undo()%7Dredo()%7Bthis._model%3F.redo()%7Dparse()%7Bif(!this._model)throw%20new%20Error(%22Model%20not%20initialized%22)%3Breturn%20at(this._model)%7D%7D%3Bvar%20W%3Dnull%3Bself.onmessage%3Dr%3D%3E%7Blet%7Bmethod%3Ae%2Cparams%3At%2CmessageId%3An%7D%3Dr.data%3Bif(e%3D%3D%3D%22init%22)%7BW%3Dnew%20ke(t.value)%2Cself.postMessage(%7BmessageId%3An%2Cresult%3A%22Worker%20initialized%22%7D)%3Breturn%7Dif(!W)%7Bself.postMessage(%7BmessageId%3An%2Cerror%3A%22Worker%20not%20initialized%22%7D)%3Breturn%7Dlet%20i%3Bswitch(e)%7Bcase%22updateModel%22%3AW.updateModel(t.op)%3Bbreak%3Bcase%22undo%22%3AW.undo()%3Bbreak%3Bcase%22redo%22%3AW.redo()%3Bbreak%3Bcase%22format%22%3Ai%3DW.format(t.options)%3Bbreak%3Bcase%22foldRange%22%3Ai%3DW.foldRange()%3Bbreak%3Bcase%22validate%22%3Ai%3DW.validate()%3Bbreak%3Bdefault%3Ai%3D%7Berror%3A%22Unknown%20method%22%7D%7Dself.postMessage(%7BmessageId%3An%2Cresult%3Ai%7D)%7D%3B%7D)()%3B%0A`);
    const blob = new Blob([workerRaw], { type: "application/javascript" });
    const workerURL = URL.createObjectURL(blob);
    this._worker = new Worker(workerURL);
    this._callbacks = /* @__PURE__ */ new Map();
    this._worker.onmessage = this._handleWorkerMessage.bind(this);
  }
  async init(value) {
    await this._sendRequest("init", { value });
  }
  updateModel(op) {
    return this._sendRequest("updateModel", { op });
  }
  undo() {
    return this._sendRequest("undo", {});
  }
  redo() {
    return this._sendRequest("redo", {});
  }
  formatJson(options) {
    return this._sendRequest("format", { options });
  }
  foldRange() {
    return this._sendRequest("foldRange", {});
  }
  validate() {
    return this._sendRequest("validate", {});
  }
  _sendRequest(method, params) {
    return new Promise((resolve, reject) => {
      const messageId = Date.now() + Math.random();
      this._callbacks.set(messageId, resolve);
      this._worker.postMessage({ messageId, method, params });
    });
  }
  _handleWorkerMessage(event) {
    const { messageId, result, error } = event.data;
    const callback = this._callbacks.get(messageId);
    if (callback) {
      if (error) {
        callback(new Error(error));
      } else {
        callback(result);
      }
      this._callbacks.delete(messageId);
    }
  }
  dispose() {
    this._worker.terminate();
    this._callbacks.clear();
  }
};
function getJsonWorkerManager() {
  const currentNameSpaceId2 = getCurrentNameSpaceId();
  if (!currentNameSpaceId2) {
    throw new Error("No active worker ID set");
  }
  let workerManager = workerManagerMap.get(currentNameSpaceId2);
  if (!workerManager) {
    workerManager = new JsonWorkerManager();
    workerManagerMap.set(currentNameSpaceId2, workerManager);
  }
  return workerManager;
}
function disposeWorkerManager(id) {
  const workerManager = workerManagerMap.get(id);
  if (workerManager) {
    workerManagerMap.delete(id);
    workerManager.dispose();
  }
}

// src/model/foldingRange.ts
var MAX_FOLDING_REGIONS = 65535;
var MAX_LINE_NUMBER = 16777215;
var MASK_INDENT = 4278190080;
var BitField = class {
  constructor(size) {
    const numWords = Math.ceil(size / 32);
    this._states = new Uint32Array(numWords);
  }
  get(index) {
    const arrayIndex = index / 32 | 0;
    const bit = index % 32;
    return (this._states[arrayIndex] & 1 << bit) !== 0;
  }
  set(index, newState) {
    const arrayIndex = index / 32 | 0;
    const bit = index % 32;
    const value = this._states[arrayIndex];
    if (newState) {
      this._states[arrayIndex] = value | 1 << bit;
    } else {
      this._states[arrayIndex] = value & ~(1 << bit);
    }
  }
};
var FoldingRegions = class _FoldingRegions {
  constructor(startIndexes, endIndexes, types) {
    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
      throw new Error("invalid startIndexes or endIndexes size");
    }
    this._startIndexes = startIndexes;
    this._endIndexes = endIndexes;
    this._collapseStates = new BitField(startIndexes.length);
    this._userDefinedStates = new BitField(startIndexes.length);
    this._recoveredStates = new BitField(startIndexes.length);
    this._types = types;
    this._parentsComputed = false;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = true;
      const parentIndexes = [];
      const isInsideLast = (startLineNumber, endLineNumber) => {
        const index = parentIndexes[parentIndexes.length - 1];
        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;
      };
      for (let i = 0, len = this._startIndexes.length; i < len; i++) {
        const startLineNumber = this._startIndexes[i];
        const endLineNumber = this._endIndexes[i];
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
        }
        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
          parentIndexes.pop();
        }
        const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
        parentIndexes.push(i);
        this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
        this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(index) {
    return this._startIndexes[index] & MAX_LINE_NUMBER;
  }
  getEndLineNumber(index) {
    return this._endIndexes[index] & MAX_LINE_NUMBER;
  }
  getType(index) {
    return this._types ? this._types[index] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(index) {
    return this._collapseStates.get(index);
  }
  setCollapsed(index, newState) {
    this._collapseStates.set(index, newState);
  }
  isUserDefined(index) {
    return this._userDefinedStates.get(index);
  }
  setUserDefined(index, newState) {
    return this._userDefinedStates.set(index, newState);
  }
  isRecovered(index) {
    return this._recoveredStates.get(index);
  }
  setRecovered(index, newState) {
    return this._recoveredStates.set(index, newState);
  }
  getSource(index) {
    if (this.isUserDefined(index)) {
      return 1 /* userDefined */;
    } else if (this.isRecovered(index)) {
      return 2 /* recovered */;
    }
    return 0 /* provider */;
  }
  setSource(index, source) {
    if (source === 1 /* userDefined */) {
      this.setUserDefined(index, true);
      this.setRecovered(index, false);
    } else if (source === 2 /* recovered */) {
      this.setUserDefined(index, false);
      this.setRecovered(index, true);
    } else {
      this.setUserDefined(index, false);
      this.setRecovered(index, false);
    }
  }
  setCollapsedAllOfType(type, newState) {
    let hasChanged = false;
    if (this._types) {
      for (let i = 0; i < this._types.length; i++) {
        if (this._types[i] === type) {
          this.setCollapsed(i, newState);
          hasChanged = true;
        }
      }
    }
    return hasChanged;
  }
  toRegion(index) {
    return new FoldingRegion(this, index);
  }
  getParentIndex(index) {
    this.ensureParentIndices();
    const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
    if (parent === MAX_FOLDING_REGIONS) {
      return -1;
    }
    return parent;
  }
  contains(index, line) {
    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
  }
  findIndex(line) {
    let low = 0, high = this._startIndexes.length;
    if (high === 0) {
      return -1;
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (line < this.getStartLineNumber(mid)) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low - 1;
  }
  findRange(line) {
    let index = this.findIndex(line);
    if (index >= 0) {
      const endLineNumber = this.getEndLineNumber(index);
      if (endLineNumber >= line) {
        return index;
      }
      index = this.getParentIndex(index);
      while (index !== -1) {
        if (this.contains(index, line)) {
          return index;
        }
        index = this.getParentIndex(index);
      }
    }
    return -1;
  }
  toFoldRange(index) {
    return {
      startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,
      endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,
      type: this._types ? this._types[index] : void 0,
      isCollapsed: this.isCollapsed(index),
      source: this.getSource(index)
    };
  }
  static fromFoldRanges(ranges) {
    ranges = ranges.sort((a, b) => a.startLineNumber - b.startLineNumber);
    const rangesLength = ranges.length;
    const startIndexes = new Uint32Array(rangesLength);
    const endIndexes = new Uint32Array(rangesLength);
    let types = [];
    let gotTypes = false;
    for (let i = 0; i < rangesLength; i++) {
      const range = ranges[i];
      startIndexes[i] = range.startLineNumber;
      endIndexes[i] = range.endLineNumber;
      types.push(range.type);
      if (range.type) {
        gotTypes = true;
      }
    }
    if (!gotTypes) {
      types = void 0;
    }
    const regions = new _FoldingRegions(startIndexes, endIndexes, types);
    for (let i = 0; i < rangesLength; i++) {
      if (ranges[i].isCollapsed) {
        regions.setCollapsed(i, true);
      }
      regions.setSource(i, ranges[i].source);
    }
    return regions;
  }
  /**
   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
   * Each input must be pre-sorted on startLineNumber.
   * The first list is assumed to always include all regions currently defined by range providers.
   * The second list only contains the previously collapsed and all manual ranges.
   * If the line position matches, the range of the new range is taken, and the range is no longer manual
   * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
   * overlapping entries in the first list are discarded.
   * Invalid entries are discarded. An entry is invalid if:
   * 		the start and end line numbers aren't a valid range of line numbers,
   * 		it is out of sequence or has the same start line as a preceding entry,
   * 		it overlaps a preceding entry and is not fully contained by that entry.
   */
  static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {
    maxLineNumber = maxLineNumber ?? Number.MAX_VALUE;
    const getIndexedFunction = (r, limit) => {
      return Array.isArray(r) ? (i) => {
        return i < limit ? r[i] : void 0;
      } : (i) => {
        return i < limit ? r.toFoldRange(i) : void 0;
      };
    };
    const getA = getIndexedFunction(rangesA, rangesA.length);
    const getB = getIndexedFunction(rangesB, rangesB.length);
    let indexA = 0;
    let indexB = 0;
    let nextA = getA(0);
    let nextB = getB(0);
    const stackedRanges = [];
    let topStackedRange;
    let prevLineNumber = 0;
    const resultRanges = [];
    while (nextA || nextB) {
      let useRange = void 0;
      if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {
        if (nextA && nextA.startLineNumber === nextB.startLineNumber) {
          if (nextB.source === 1 /* userDefined */) {
            useRange = nextB;
          } else {
            useRange = nextA;
            useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;
            useRange.source = 0 /* provider */;
          }
          nextA = getA(++indexA);
        } else {
          useRange = nextB;
          if (nextB.isCollapsed && nextB.source === 0 /* provider */) {
            useRange.source = 2 /* recovered */;
          }
        }
        nextB = getB(++indexB);
      } else {
        let scanIndex = indexB;
        let prescanB = nextB;
        while (true) {
          if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {
            useRange = nextA;
            break;
          }
          if (prescanB.source === 1 /* userDefined */ && prescanB.endLineNumber > nextA.endLineNumber) {
            break;
          }
          prescanB = getB(++scanIndex);
        }
        nextA = getA(++indexA);
      }
      if (useRange) {
        while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) {
          topStackedRange = stackedRanges.pop();
        }
        if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {
          resultRanges.push(useRange);
          prevLineNumber = useRange.startLineNumber;
          if (topStackedRange) {
            stackedRanges.push(topStackedRange);
          }
          topStackedRange = useRange;
        }
      }
    }
    return resultRanges;
  }
};
var FoldingRegion = class {
  constructor(ranges, index) {
    this.ranges = ranges;
    this.index = index;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(range) {
    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
  }
  containsLine(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
  }
  hidesLine(lineNumber) {
    return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;
  }
};

// src/common/strings.ts
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
function createRegExp(searchString, isRegex, options = {}) {
  if (!searchString) {
    throw new Error("Cannot create regex from empty string");
  }
  if (!isRegex) {
    searchString = escapeRegExpCharacters(searchString);
  }
  if (options.wholeWord) {
    if (!/\B/.test(searchString.charAt(0))) {
      searchString = "\\b" + searchString;
    }
    if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
      searchString = searchString + "\\b";
    }
  }
  let modifiers = "";
  if (options.global) {
    modifiers += "g";
  }
  if (!options.matchCase) {
    modifiers += "i";
  }
  if (options.multiline) {
    modifiers += "m";
  }
  if (options.unicode) {
    modifiers += "u";
  }
  return new RegExp(searchString, modifiers);
}
function getLeadingWhitespace(str, start = 0, end = str.length) {
  for (let i = start; i < end; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
      return str.substring(start, i);
    }
  }
  return str.substring(start, end);
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
      return i;
    }
  }
  return -1;
}
function countEOL(text) {
  let eolCount = 0;
  let firstLineLength = 0;
  let lastLineStart = 0;
  let eol = 0 /* Unknown */;
  for (let i = 0, len = text.length; i < len; i++) {
    const chr = text.charCodeAt(i);
    if (chr === 13 /* CarriageReturn */) {
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
        eol |= 2 /* CRLF */;
        i++;
      } else {
        eol |= 3 /* Invalid */;
      }
      lastLineStart = i + 1;
    } else if (chr === 10 /* LineFeed */) {
      eol |= 1 /* LF */;
      if (eolCount === 0) {
        firstLineLength = i;
      }
      eolCount++;
      lastLineStart = i + 1;
    }
  }
  if (eolCount === 0) {
    firstLineLength = text.length;
  }
  return [eolCount, firstLineLength, text.length - lastLineStart, eol];
}

// src/common/utils.ts
function isObject(val) {
  return typeof val === "object" && val !== null && !Array.isArray(val);
}
function isNumber(val) {
  return typeof val === "number";
}
function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      j = k;
    } else {
      i = k + 1;
    }
  }
  return i;
}

// src/model/hiddenRangeModel.ts
var HiddenRangeModel = class {
  constructor(foldingModel) {
    this._hiddenRanges = [];
    this._hasLineChanged = false;
    this.emitter = getEmitter();
    this._foldingModel = foldingModel;
    if (this._foldingModel.regions.length) {
      this.updateHiddenRanges();
    }
  }
  updateHiddenRanges() {
    let updateHiddenAreas = false;
    const newHiddenAreas = [];
    let i = 0;
    let k = 0;
    let lastCollapsedStart = Number.MAX_VALUE;
    let lastCollapsedEnd = -1;
    const ranges = this._foldingModel.regions;
    for (; i < ranges.length; i++) {
      if (!ranges.isCollapsed(i)) {
        continue;
      }
      const startLineNumber = ranges.getStartLineNumber(i) + 1;
      const endLineNumber = ranges.getEndLineNumber(i);
      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
        continue;
      }
      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
        newHiddenAreas.push(this._hiddenRanges[k]);
        k++;
      } else {
        updateHiddenAreas = true;
        newHiddenAreas.push({ startLineNumber, startColumn: 1, endLineNumber, endColumn: 1 });
      }
      lastCollapsedStart = startLineNumber;
      lastCollapsedEnd = endLineNumber;
    }
    if (this._hasLineChanged || updateHiddenAreas || k < this._hiddenRanges.length) {
      this.applyHiddenRanges(newHiddenAreas);
    }
  }
  applyHiddenRanges(newHiddenAreas) {
    this._hasLineChanged = false;
    this._hiddenRanges = newHiddenAreas;
    this.emitter.emit("forceRender", void 0);
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  isHiddenLine(lineNumber) {
    return this.findRange(lineNumber, this._hiddenRanges) !== null;
  }
  findRange(lineNumber, ranges) {
    const i = findFirstIdxMonotonousOrArrLen(ranges, (r) => lineNumber < r.startLineNumber) - 1;
    if (i >= 0 && ranges[i].endLineNumber >= lineNumber) {
      return ranges[i];
    }
    return null;
  }
  getHiddenLineCount() {
    let count = 0;
    for (const range of this._hiddenRanges) {
      count += range.endLineNumber - range.startLineNumber + 1;
    }
    return count;
  }
  notifyChangeModelContent(e) {
    if (this._hiddenRanges.length && !this._hasLineChanged) {
      if (Array.isArray(e)) {
        this._hasLineChanged = e.some((change) => {
          return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.newText)[0] !== 0 || countEOL(change.oldText)[0] !== 0;
        });
      } else {
        this._hasLineChanged = e.range.endLineNumber !== e.range.startLineNumber || countEOL(e.newText)[0] !== 0 || countEOL(e.oldText)[0] !== 0;
      }
    }
  }
};

// src/model/foldingModel.ts
var FoldingModel = class {
  constructor(jsonModel) {
    this._regions = null;
    this._jsonWorkerManager = getJsonWorkerManager();
    this.emitter = getEmitter();
    this._jsonModel = jsonModel;
    this.updateFoldingRanges();
    this.emitter.on("contentChanged", (e) => {
      this._hiddenRangeModel.notifyChangeModelContent(e);
    });
    this.emitter.on("problemsChanged", (e) => {
      this._jsonWorkerManager.foldRange().then((ranges) => {
        const newRegions = FoldingRegions.fromFoldRanges(ranges);
        this.update(newRegions);
        this._hiddenRangeModel.updateHiddenRanges();
      });
    });
  }
  get regions() {
    return this._regions;
  }
  updateFoldingRanges() {
    this._jsonWorkerManager.foldRange().then((ranges) => {
      this._regions = FoldingRegions.fromFoldRanges(ranges);
      this._hiddenRangeModel = new HiddenRangeModel(this);
    });
  }
  update(newRegions, blockedLineNumers = []) {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers, newRegions);
    const newRanges = FoldingRegions.sanitizeAndMerge(
      newRegions,
      foldedOrManualRanges,
      this._jsonModel.getLineCount()
    );
    this._regions = FoldingRegions.fromFoldRanges(newRanges);
  }
  _currentFoldedOrManualRanges(blockedLineNumers = [], newRegions) {
    const isBlocked = (startLineNumber, endLineNumber) => {
      if (newRegions) {
        const index = newRegions.findRange(startLineNumber);
        if (index === -1) return true;
        const region = newRegions.toRegion(index);
        if (!region || region.endLineNumber !== endLineNumber) return true;
      }
      for (const blockedLineNumber of blockedLineNumers) {
        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {
          return true;
        }
      }
      return false;
    };
    const foldedRanges = [];
    for (let i = 0; i < this._regions.length; i++) {
      if (this._regions.isCollapsed(i)) {
        const startLineNumber = this._regions.getStartLineNumber(i);
        const endLineNumber = this._regions.getEndLineNumber(i);
        if (!isBlocked(startLineNumber, endLineNumber)) {
          foldedRanges.push({
            startLineNumber,
            endLineNumber,
            isCollapsed: true,
            source: 0 /* provider */,
            type: this._regions.getType(i)
          });
        }
      }
    }
    return foldedRanges;
  }
  toggleCollapseState(toggledRegions) {
    if (!toggledRegions.length) {
      return;
    }
    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
    for (const region of toggledRegions) {
      const index = region.regionIndex;
      const newCollapsed = !this._regions.isCollapsed(index);
      this._regions.setCollapsed(index, newCollapsed);
    }
    this._hiddenRangeModel.updateHiddenRanges();
  }
  toggleFoldingRange(startLine) {
    toggleCollapseState(this, 1, [startLine]);
  }
  isCollapsed(lineNumber) {
    if (!this._regions) return false;
    const index = this._regions.findRange(lineNumber);
    const region = this._regions.toRegion(index);
    return region && region.isCollapsed;
  }
  isLineCollapsed(lineNumber) {
    if (!this._regions) return false;
    return this._hiddenRangeModel.isHiddenLine(lineNumber);
  }
  isFoldable(lineNumber) {
    const index = this._regions.findRange(lineNumber);
    const region = this._regions.toRegion(index);
    return region && region.startLineNumber === lineNumber;
  }
  getVisibleLineCount() {
    if (!this._regions || !this._hiddenRangeModel) return this._jsonModel.getLineCount();
    return this._jsonModel.getLineCount() - this._hiddenRangeModel.getHiddenLineCount();
  }
  getActualLineNumber(visibleLineNumber) {
    if (!this._regions || !this._hiddenRangeModel) return visibleLineNumber;
    let actualLine = visibleLineNumber;
    const hiddenRanges = this._hiddenRangeModel.hiddenRanges;
    for (const range of hiddenRanges) {
      if (range.startLineNumber <= actualLine) {
        actualLine += range.endLineNumber - range.startLineNumber + 1;
      } else {
        break;
      }
    }
    return actualLine;
  }
  getNextVisibleLine(actualLineNumber) {
    if (!this._regions || !this._hiddenRangeModel) return actualLineNumber + 1;
    let nextLine = actualLineNumber + 1;
    const hiddenRanges = this._hiddenRangeModel.hiddenRanges;
    const containingRange = this._hiddenRangeModel.findRange(nextLine, hiddenRanges);
    if (containingRange) {
      return containingRange.endLineNumber + 1;
    }
    return nextLine;
  }
  getRegionAtLine(lineNumber) {
    if (this._regions) {
      const index = this._regions.findRange(lineNumber);
      if (index >= 0) {
        return this._regions.toRegion(index);
      }
    }
    return null;
  }
  getRegionsInside(region, filter) {
    const result = [];
    const index = region ? region.regionIndex + 1 : 0;
    const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
    if (filter && filter.length === 2) {
      const levelStack = [];
      for (let i = index, len = this._regions.length; i < len; i++) {
        const current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
            levelStack.pop();
          }
          levelStack.push(current);
          if (filter(current, levelStack.length)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    } else {
      for (let i = index, len = this._regions.length; i < len; i++) {
        const current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          if (!filter || filter(current)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    }
    return result;
  }
};
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        const regionsInside = foldingModel.getRegionsInside(
          region,
          (r, level) => r.isCollapsed !== doCollapse && level < levels
        );
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}

// src/view/search/searchWidget.ts
var SearchWidget = class {
  constructor(view, jsonModel) {
    //TODO: 修改searchResults存储数据结构
    this.searchResults = null;
    this._currentResultIndex = -1;
    this.matchCase = false;
    this.wordSeparators = null;
    this.isRegex = false;
    this._view = view;
    this._jsonModel = jsonModel;
  }
  search(searchText, caseSensitive, wholeWord, regex) {
    this._currentResultIndex = -1;
    const isRegex = regex;
    const matchCase = caseSensitive;
    const wordSeparators = !wholeWord ? this.wordSeparators : "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
    const searchScope = null;
    const captureMatches = false;
    const limitResultCount = Infinity;
    this.searchResults = this._jsonModel.findMatches(
      searchText,
      searchScope,
      isRegex,
      matchCase,
      wordSeparators,
      captureMatches,
      limitResultCount
    );
    this._view.layout();
  }
  replace(replaceText) {
    if (!replaceText || !this.searchResults) return;
    if (this._currentResultIndex < 0) {
      this._currentResultIndex = 0;
    }
    const currentMatch = this.searchResults[this._currentResultIndex];
    const startOffset = this._jsonModel.getOffsetAt(
      currentMatch.range.startLineNumber,
      currentMatch.range.startColumn
    );
    const endOffset = this._jsonModel.getOffsetAt(
      currentMatch.range.endLineNumber,
      currentMatch.range.endColumn
    );
    const op = {
      range: currentMatch.range,
      newText: replaceText,
      oldText: this._jsonModel.getValueInRange(currentMatch.range),
      type: "replace",
      rangeOffset: startOffset,
      rangeLength: endOffset - startOffset
    };
    this.searchResults.splice(this._currentResultIndex, 1);
    this._jsonModel.applyOperation(op);
  }
  replaceAll(replaceText) {
    if (!replaceText || !this.searchResults) return;
    const op = [];
    for (let i = this.searchResults.length - 1; i >= 0; i--) {
      const match = this.searchResults[i];
      const startOffset = this._jsonModel.getOffsetAt(match.range.startLineNumber, match.range.startColumn);
      const endOffset = this._jsonModel.getOffsetAt(match.range.endLineNumber, match.range.endColumn);
      op.push({
        range: match.range,
        newText: replaceText,
        oldText: this._jsonModel.getValueInRange(match.range),
        type: "replace",
        rangeOffset: startOffset,
        rangeLength: endOffset - startOffset
      });
    }
    this.searchResults = null;
    this._jsonModel.applyOperation(op);
  }
  navigateResults(direction) {
    if (!this.searchResults || this.searchResults.length === 0) return;
    this._currentResultIndex += direction;
    if (this._currentResultIndex < 0) {
      this._currentResultIndex = this.searchResults.length - 1;
    } else if (this._currentResultIndex >= this.searchResults.length) {
      this._currentResultIndex = 0;
    }
    const currentMatch = this.searchResults[this._currentResultIndex];
    if (!currentMatch) return;
    if (currentMatch.range.startLineNumber > this._view.startLineNumber + this._view.visibleLineCount || currentMatch.range.startLineNumber < this._view.startLineNumber) {
      this._view.scrollToLine(currentMatch.range.startLineNumber);
    } else {
      this._view.layout();
    }
  }
  binarySearchByLine(targetLine) {
    const matches = [];
    if (!this.searchResults) return null;
    let left = 0;
    let right = this.searchResults.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const currentLine = this.searchResults[mid].range.startLineNumber;
      if (currentLine === targetLine) {
        let i = mid;
        while (i >= 0 && this.searchResults[i].range.startLineNumber === targetLine) {
          matches.unshift(this.searchResults[i]);
          i--;
        }
        i = mid + 1;
        while (i < this.searchResults.length && this.searchResults[i].range.startLineNumber === targetLine) {
          matches.push(this.searchResults[i]);
          i++;
        }
        return matches;
      }
      if (currentLine < targetLine) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return matches;
  }
};

// src/view/edit/editWidget.ts
import { applyEdits } from "jsonc-parser";

// src/view/edit/getEnterAction.ts
function getIndentationAtPosition(model, lineNumber, column) {
  const lineText = model.getLineContent(lineNumber);
  let indentation = getLeadingWhitespace(lineText);
  if (indentation.length > column - 1) {
    indentation = indentation.substring(0, column - 1);
  }
  return indentation;
}
function processJsonEnterAction(model, range) {
  const currentLineText = model.getLineContent(range.startLineNumber);
  const beforeText = currentLineText.substring(0, range.startColumn - 1);
  const afterText = currentLineText.substring(range.startColumn - 1);
  const previousLineText = range.startLineNumber > 1 ? model.getLineContent(range.startLineNumber - 1) : "";
  const enterResult = onEnter(beforeText, afterText, previousLineText);
  if (!enterResult) {
    return null;
  }
  const indentAction = enterResult.indentAction;
  let appendText = enterResult.appendText;
  const removeText = enterResult.removeText || 0;
  if (!appendText) {
    if (indentAction === 1 /* Indent */ || indentAction === 2 /* IndentOutdent */) {
      appendText = "	";
    } else {
      appendText = "";
    }
  } else if (indentAction === 1 /* Indent */) {
    appendText = "	" + appendText;
  }
  let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
  if (removeText) {
    indentation = indentation.substring(0, indentation.length - removeText);
  }
  return {
    indentAction,
    appendText,
    removeText,
    indentation
  };
}
function onEnter(beforeText, afterText, previousLineText) {
  const brackets = [
    { open: "{", openRegExp: /\{\s*$/, close: "}", closeRegExp: /^\s*\}/ },
    { open: "[", openRegExp: /\[\s*$/, close: "]", closeRegExp: /^\s*\]/ }
  ];
  if (beforeText.length > 0 && afterText.length > 0) {
    for (let i = 0, len = brackets.length; i < len; i++) {
      const bracket = brackets[i];
      if (bracket.openRegExp.test(beforeText) && bracket.closeRegExp.test(afterText)) {
        return { indentAction: 2 /* IndentOutdent */ };
      }
    }
  }
  if (beforeText.length > 0) {
    for (let i = 0, len = brackets.length; i < len; i++) {
      const bracket = brackets[i];
      if (bracket.openRegExp.test(beforeText)) {
        return { indentAction: 1 /* Indent */ };
      }
    }
  }
  return null;
}

// src/view/edit/editWidget.ts
var EditWidget = class {
  constructor(view, jsonModel, selectionModel, _jsonWorkerManager = getJsonWorkerManager()) {
    this._jsonWorkerManager = _jsonWorkerManager;
    this._isComposition = false;
    this._autoClosingPairs = {
      "{": "}",
      "[": "]",
      "(": ")",
      '"': '"'
    };
    this.emitter = getEmitter();
    this._view = view;
    this._jsonModel = jsonModel;
    this._selectionModel = selectionModel;
    this.attachEventListeners();
  }
  attachEventListeners() {
    this._jsonWorkerManager.validate().then((result) => {
      this.emitter.emit("problemsChanged", {
        problems: result.problems,
        root: result.root
      });
    });
    this._view.contentDom.addEventListener("beforeinput", (e) => {
      this._handleBeforeInput(e);
    });
    this._view.contentDom.addEventListener("compositionstart", (e) => {
      this._handleCompositionStart(e);
    });
    this._view.contentDom.addEventListener("compositionend", (e) => {
      this._handleCompositionEnd(e);
    });
    this._view.contentDom.addEventListener("keydown", (e) => {
      this._handleKeyDown(e);
    });
  }
  buildBaseOperation(type = "insert") {
    const startRow = this._selectionModel.startRow;
    const startCol = this._selectionModel.startCol;
    const endRow = this._selectionModel.endRow;
    const endCol = this._selectionModel.endCol;
    const startOffset = this._jsonModel.getOffsetAt(startRow, startCol);
    const endOffset = this._jsonModel.getOffsetAt(endRow, endCol);
    const op = {
      type,
      range: {
        startLineNumber: startRow,
        startColumn: startCol,
        endLineNumber: endRow,
        endColumn: endCol
      },
      rangeOffset: startOffset,
      rangeLength: endOffset - startOffset,
      oldText: this._jsonModel.getValueInRange({
        startLineNumber: startRow,
        startColumn: startCol,
        endLineNumber: endRow,
        endColumn: endCol
      }),
      newText: ""
    };
    if (this._selectionModel.isSelectedAll) {
      op.range = {
        startLineNumber: 1,
        startColumn: 1,
        endLineNumber: this._jsonModel.getLineCount(),
        endColumn: this._jsonModel.getLineLength(this._jsonModel.getLineCount()) + 1
      };
      op.rangeOffset = 0;
      op.rangeLength = this._jsonModel.getValue().length;
      op.oldText = this._jsonModel.getValue();
    }
    return op;
  }
  _handleCompositionStart(e) {
    e.preventDefault();
    this._isComposition = true;
    this._selectionModel.savePreviousSelection();
  }
  _handleCompositionEnd(e) {
    e.preventDefault();
    this._isComposition = false;
    this._selectionModel.restorePreviousSelection();
    const op = this.buildBaseOperation("replace");
    op.newText = e.data || "";
    this._selectionModel.isSelectedAll = false;
    this._jsonModel.applyOperation(op);
  }
  _handleBeforeInput(e) {
    if (this._isComposition) return;
    e.preventDefault();
    this._selectionModel.updateFromSelection();
    const op = this.buildBaseOperation();
    const { startLineNumber, startColumn, endLineNumber, endColumn } = op.range;
    switch (e.inputType) {
      case "insertText":
        if (this._selectionModel.isCollapsed) {
          op.type = "insert";
        } else {
          op.type = "replace";
        }
        op.newText = e.data || "";
        if (this._autoClosingPairs[op.newText]) {
          op.newText += this._autoClosingPairs[op.newText];
          op.keepPosition = {
            lineNumber: startLineNumber,
            column: startColumn + 1
          };
        }
        break;
      case "insertParagraph":
        op.newText = "\n";
        op.keepPosition = {
          lineNumber: startLineNumber + 1,
          column: 1
        };
        const enterAction = processJsonEnterAction(this._jsonModel, {
          startLineNumber,
          startColumn,
          endLineNumber,
          endColumn
        });
        if (enterAction) {
          if (enterAction.indentAction === 1 /* Indent */) {
            op.newText = "\n" + this.normalizeIndentation(enterAction.appendText + enterAction.indentation) || "";
            op.keepPosition = {
              lineNumber: startLineNumber + 1,
              column: op.newText.length
            };
          } else {
            const normalIndent = this.normalizeIndentation(enterAction.indentation);
            const increasedIndent = this.normalizeIndentation(enterAction.indentation + enterAction.appendText);
            op.newText = "\n" + increasedIndent + "\n" + normalIndent;
            op.keepPosition = {
              lineNumber: startLineNumber + 1,
              column: increasedIndent.length + 1
            };
          }
        } else {
          const lineText = this._jsonModel.getLineContent(startLineNumber);
          const indentation = getLeadingWhitespace(lineText).substring(0, startColumn - 1);
          op.newText = "\n" + this.normalizeIndentation(indentation) || "";
          op.keepPosition = {
            lineNumber: startLineNumber + 1,
            column: op.newText.length
          };
        }
        break;
      case "deleteContentBackward":
        if (this._selectionModel.isCollapsed) {
          op.rangeOffset -= 1;
          op.oldText = this._jsonModel.getValueInRange({
            startLineNumber,
            startColumn: startColumn - 1,
            endLineNumber,
            endColumn
          });
        }
        op.type = "delete";
        op.rangeLength = op.oldText.length;
        break;
      case "insertFromPaste":
        const pasteData = e.dataTransfer?.getData("text/plain");
        op.type = "replace";
        op.newText = pasteData || "";
        break;
    }
    this._selectionModel.isSelectedAll = false;
    this._jsonModel.applyOperation(op);
  }
  format() {
    this._jsonWorkerManager.formatJson(
      this._view.options?.formatOptions || {
        tabSize: 2,
        insertSpaces: true
      }
    ).then((edits) => {
      const newValue = applyEdits(this._jsonModel.getValue(), edits);
      const op = {
        type: "replace",
        range: {
          startLineNumber: 1,
          startColumn: 1,
          endLineNumber: this._jsonModel.getLineCount(),
          endColumn: this._jsonModel.getLineLength(this._jsonModel.getLineCount()) + 1
        },
        rangeOffset: 0,
        rangeLength: this._jsonModel.getValue().length,
        oldText: this._jsonModel.getValue(),
        newText: newValue
      };
      this._jsonModel.applyOperation(op);
    });
  }
  normalizeIndentation(str) {
    const indentSize = this._view.options?.formatOptions?.tabSize || 4;
    const insertSpaces = !!this._view.options?.formatOptions?.insertSpaces;
    let firstIndex = firstNonWhitespaceIndex(str);
    if (firstIndex === -1) {
      firstIndex = str.length;
    }
    return this._normalizeIndentationFromWhitespace(str.substring(0, firstIndex), indentSize, insertSpaces) + str.substring(firstIndex);
  }
  _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {
    let spacesCnt = 0;
    for (let i = 0; i < str.length; i++) {
      if (str.charAt(i) === "	") {
        spacesCnt = this.nextIndentTabStop(spacesCnt, indentSize);
      } else {
        spacesCnt++;
      }
    }
    let result = "";
    if (!insertSpaces) {
      const tabsCnt = Math.floor(spacesCnt / indentSize);
      spacesCnt = spacesCnt % indentSize;
      for (let i = 0; i < tabsCnt; i++) {
        result += "	";
      }
    }
    for (let i = 0; i < spacesCnt; i++) {
      result += " ";
    }
    return result;
  }
  nextIndentTabStop(spacesCnt, indentSize) {
    return spacesCnt + indentSize - spacesCnt % indentSize;
  }
  _handleKeyDown(e) {
    this._selectionModel.updateFromSelection();
    const startRow = this._selectionModel.startRow;
    const startCol = this._selectionModel.startCol;
    const endRow = this._selectionModel.endRow;
    const endCol = this._selectionModel.endCol;
    const startOffset = this._jsonModel.getOffsetAt(startRow, startCol);
    const endOffset = this._jsonModel.getOffsetAt(endRow, endCol);
    const op = this.buildBaseOperation();
    switch (e.key) {
      case "Tab":
        if (this._view.completeWidget.isVisible) {
          e.preventDefault();
          this._view.completeWidget._handleKeyDown(e);
          return;
        }
        e.preventDefault();
        let insertText = "";
        if (this._view.options?.formatOptions?.insertSpaces) {
          const tabSize = this._view.options?.formatOptions?.tabSize || 4;
          for (let i = 0; i < tabSize; i++) {
            insertText += " ";
          }
        } else {
          insertText = "	";
        }
        op.newText = insertText;
        this._jsonModel.applyOperation(op);
        break;
      case "f":
        if (e.shiftKey && e.metaKey) {
          e.preventDefault();
          this.format();
        }
        break;
      case "ArrowRight":
      case "ArrowLeft":
        if (this._view.completeWidget.isVisible) {
          this._view.completeWidget.hide();
        }
        break;
      case "ArrowDown":
      case "ArrowUp":
        if (this._view.completeWidget.isVisible) {
          e.preventDefault();
          this._view.completeWidget._handleKeyDown(e);
        }
        break;
      case "Enter":
        if (this._view.completeWidget.isVisible) {
          e.preventDefault();
          this._view.completeWidget._handleKeyDown(e);
        }
        break;
      case "a":
        if (e.metaKey) {
          this._selectionModel.isSelectedAll = true;
        }
        break;
      case "x":
        if (e.metaKey) {
          e.preventDefault();
          this._cutHandler();
        }
        break;
      case "z":
        if (e.metaKey && !e.shiftKey) {
          e.preventDefault();
          this._jsonModel.undo();
        } else if (e.metaKey && e.shiftKey) {
          e.preventDefault();
          this._jsonModel.redo();
        }
        break;
      case "c":
        if (e.metaKey) {
          e.preventDefault();
          this._copyHandler();
        }
        break;
    }
  }
  _cutHandler() {
    const op = this.buildBaseOperation("replace");
    if (this._selectionModel.isCollapsed) {
      const { startLineNumber, endLineNumber } = op.range;
      op.rangeOffset = this._jsonModel.getOffsetAt(startLineNumber, 1);
      op.oldText = this._jsonModel.getValueInRange({
        startLineNumber,
        startColumn: 1,
        endLineNumber,
        endColumn: this._jsonModel.getLineLength(endLineNumber) + 1
      });
      op.range = {
        startLineNumber,
        startColumn: 1,
        endLineNumber,
        endColumn: this._jsonModel.getLineLength(endLineNumber) + 1
      };
    }
    navigator.clipboard.writeText(op.oldText);
    this._jsonModel.applyOperation(op);
  }
  _copyHandler() {
    const op = this.buildBaseOperation("replace");
    navigator.clipboard.writeText(op.oldText);
  }
};

// src/view/fold/foldWidget.ts
var FoldWidget = class {
  constructor(view, foldingModel) {
    this._isMouseOver = false;
    this._view = view;
    this._foldingModel = foldingModel;
    this._attachEventListeners();
  }
  _attachEventListeners() {
    this._view.lineScrollDom.addEventListener("mouseover", (e) => {
      this._handleLineNumberHover(e);
    });
    this._view.lineScrollDom.addEventListener("mouseleave", () => {
      this._handleLineNumberContainerLeave();
    });
  }
  _handleLineNumberHover(e) {
    this._showFoldingIcon();
    this._isMouseOver = true;
  }
  _handleLineNumberContainerLeave() {
    this.removeAllFoldingIcons();
    this._isMouseOver = false;
  }
  _showFoldingIcon() {
    if (this._isMouseOver) return;
    const lineNumberElement = this._view.lineScrollDom.children;
    for (let i = 0; i < lineNumberElement.length; i++) {
      const element = lineNumberElement[i];
      if (this._foldingModel.isFoldable(Number(element.dataset.lineNumber))) {
        element.appendChild(this._createFoldingIcon(Number(element.dataset.lineNumber)));
      }
    }
  }
  _createFoldSvg(isCollapsed) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("fill", "none");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttribute("width", "1em");
    svg.setAttribute("height", "1em");
    if (isCollapsed) {
      svg.setAttribute("transform", "rotate(270)");
    }
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = "M21.8329 6.59139L12.8063 18.9004C12.4068 19.4452 11.5931 19.4452 11.1935 18.9004L2.16693 6.59139C1.68255 5.93086 2.15424 5.00003 2.97334 5.00003L21.0265 5.00003C21.8456 5.00003 22.3173 5.93087 21.8329 6.59139Z";
    path.setAttribute("d", d);
    path.setAttribute("fill", "var(--semi-color-tertiary)");
    svg.appendChild(path);
    return svg;
  }
  _createFoldingIcon(lineNumber) {
    const foldingIconClass = "semi-json-viewer-folding-icon";
    const foldingIcon = elt("span", foldingIconClass);
    const isCollapsed = this._foldingModel.isCollapsed(lineNumber);
    foldingIcon.appendChild(this._createFoldSvg(isCollapsed));
    setStyles(foldingIcon, {
      position: "absolute",
      right: "0",
      top: "0",
      width: "40%",
      height: "100%",
      cursor: "pointer",
      zIndex: "1",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    });
    foldingIcon.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this._foldingModel.toggleFoldingRange(lineNumber);
      this._view.scalingCellSizeAndPositionManager.resetCell(0);
      this._view.layout();
      this._isMouseOver = false;
    });
    return foldingIcon;
  }
  removeAllFoldingIcons() {
    const foldingIconClass = "semi-json-viewer-folding-icon";
    const foldingIcons = this._view.lineScrollDom.querySelectorAll(`.${foldingIconClass}`);
    foldingIcons.forEach((icon) => icon.remove());
  }
};

// src/tokens/offsetRange.ts
var OffsetRange = class _OffsetRange {
  constructor(start, endExclusive) {
    this.start = start;
    this.endExclusive = endExclusive;
    if (start > endExclusive) {
      throw new Error(`Invalid range: ${this.toString()}`);
    }
  }
  static addRange(range, sortedRanges) {
    let i = 0;
    while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
      i++;
    }
    let j = i;
    while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
      j++;
    }
    if (i === j) {
      sortedRanges.splice(i, 0, range);
    } else {
      const start = Math.min(range.start, sortedRanges[i].start);
      const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
      sortedRanges.splice(i, j - i, new _OffsetRange(start, end));
    }
  }
  static tryCreate(start, endExclusive) {
    if (start > endExclusive) {
      return void 0;
    }
    return new _OffsetRange(start, endExclusive);
  }
  static ofLength(length) {
    return new _OffsetRange(0, length);
  }
  static ofStartAndLength(start, length) {
    return new _OffsetRange(start, start + length);
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(offset) {
    return new _OffsetRange(this.start + offset, this.endExclusive + offset);
  }
  deltaStart(offset) {
    return new _OffsetRange(this.start + offset, this.endExclusive);
  }
  deltaEnd(offset) {
    return new _OffsetRange(this.start, this.endExclusive + offset);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  equals(other) {
    return this.start === other.start && this.endExclusive === other.endExclusive;
  }
  containsRange(other) {
    return this.start <= other.start && other.endExclusive <= this.endExclusive;
  }
  contains(offset) {
    return this.start <= offset && offset < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(other) {
    return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(other) {
    const start = Math.max(this.start, other.start);
    const end = Math.min(this.endExclusive, other.endExclusive);
    if (start <= end) {
      return new _OffsetRange(start, end);
    }
    return void 0;
  }
  intersects(other) {
    const start = Math.max(this.start, other.start);
    const end = Math.min(this.endExclusive, other.endExclusive);
    return start < end;
  }
  intersectsOrTouches(other) {
    const start = Math.max(this.start, other.start);
    const end = Math.min(this.endExclusive, other.endExclusive);
    return start <= end;
  }
  isBefore(other) {
    return this.endExclusive <= other.start;
  }
  isAfter(other) {
    return this.start >= other.endExclusive;
  }
  slice(arr) {
    return arr.slice(this.start, this.endExclusive);
  }
  substring(str) {
    return str.substring(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(value) {
    if (this.isEmpty) {
      throw new Error(`Invalid clipping range: ${this.toString()}`);
    }
    return Math.max(this.start, Math.min(this.endExclusive - 1, value));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(value) {
    if (this.isEmpty) {
      throw new Error(`Invalid clipping range: ${this.toString()}`);
    }
    if (value < this.start) {
      return this.endExclusive - (this.start - value) % this.length;
    }
    if (value >= this.endExclusive) {
      return this.start + (value - this.start) % this.length;
    }
    return value;
  }
  map(f) {
    const result = [];
    for (let i = this.start; i < this.endExclusive; i++) {
      result.push(f(i));
    }
    return result;
  }
  forEach(f) {
    for (let i = this.start; i < this.endExclusive; i++) {
      f(i);
    }
  }
};

// src/common/async.ts
function runWhenGlobalIdle(callback) {
  const handler = window.requestIdleCallback(callback);
  let disposed = false;
  return {
    dispose: () => {
      if (disposed) {
        return;
      }
      disposed = true;
      window.cancelIdleCallback(handler);
    }
  };
}

// src/common/stopWatch.ts
var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
var StopWatch = class _StopWatch {
  static create(highResolution) {
    return new _StopWatch(highResolution);
  }
  constructor(highResolution) {
    this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance?.now.bind(globalThis.performance);
    this._startTime = this._now();
    this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now();
    this._stopTime = -1;
  }
  elapsed() {
    if (this._stopTime !== -1) {
      return this._stopTime - this._startTime;
    }
    return this._now() - this._startTime;
  }
};

// src/tokens/jsonModelToken.ts
var TokenizerWithStateStore = class {
  constructor(lineCount, tokenizationSupport) {
    this.tokenizationSupport = tokenizationSupport;
    this.initialState = tokenizationSupport.getInitialState();
    this.store = new TrackingTokenizationStateStore(lineCount);
  }
  getStartState(lineNumber) {
    return this.store.getStartState(lineNumber, this.initialState);
  }
  getFirstInvalidLine() {
    return this.store.getFirstInvalidLine(this.initialState);
  }
};
var JsonTokenizerWithStateStoreAndModel = class extends TokenizerWithStateStore {
  constructor(lineCount, tokenizationSupport, _jsonModel) {
    super(lineCount, tokenizationSupport);
    this._jsonModel = _jsonModel;
  }
  updateTokensUntilLine(lineNumber, backgroundTokenizationStore) {
    while (true) {
      const lineToTokenize = this.getFirstInvalidLine();
      if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {
        break;
      }
      const text = this._jsonModel.getLineContent(lineToTokenize.lineNumber);
      const result = this.tokenizationSupport.tokenize(text, lineToTokenize.startState);
      backgroundTokenizationStore.setTokens(lineToTokenize.lineNumber, result.tokens);
      this.store.setEndState(lineToTokenize.lineNumber, result.endState);
    }
  }
};
var TrackingTokenizationStateStore = class {
  constructor(lineCount) {
    this.lineCount = lineCount;
    this._tokenizationStateStore = new TokenizationStateStore();
    this._invalidatedLines = new RangePriorityQueue();
    this._invalidatedLines.addRange(new OffsetRange(1, lineCount + 1));
  }
  getEndState(lineNumber) {
    return this._tokenizationStateStore.getEndState(lineNumber);
  }
  setEndState(lineNumber, state) {
    this._invalidatedLines.delete(lineNumber);
    const result = this._tokenizationStateStore.setEndState(lineNumber, state);
    if (result && lineNumber < this.lineCount) {
      this._invalidatedLines.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));
    }
    return result;
  }
  getStartState(lineNumber, initialState) {
    if (lineNumber === 1) {
      return initialState;
    }
    return this.getEndState(lineNumber - 1);
  }
  getFirstInvalidEndStateLineNumber() {
    return this._invalidatedLines.min;
  }
  getFirstInvalidLine(initialState) {
    const lineNumber = this.getFirstInvalidEndStateLineNumber();
    if (lineNumber === null) {
      return null;
    }
    const startState = this.getStartState(lineNumber, initialState);
    if (!startState) {
      throw new Error("Start state must be defined");
    }
    return {
      lineNumber,
      startState: this.getStartState(lineNumber, initialState)
    };
  }
  allStatesValid() {
    return this._invalidatedLines.min === null;
  }
  invalidateRange({ from, to }) {
    this._invalidatedLines.addRange(new OffsetRange(from, to));
  }
};
var TokenizationStateStore = class {
  constructor() {
    this._lineEndState = new Array();
  }
  getEndState(lineNumber) {
    return this._lineEndState[lineNumber];
  }
  setEndState(lineNumber, state) {
    const oldState = this._lineEndState[lineNumber];
    if (oldState && oldState.equals(state)) {
      return false;
    }
    this._lineEndState[lineNumber] = state;
    return true;
  }
};
var RangePriorityQueue = class {
  constructor() {
    this._ranges = [];
  }
  getRange() {
    return this._ranges;
  }
  addRange(range) {
    OffsetRange.addRange(range, this._ranges);
  }
  get min() {
    return this._ranges[0]?.start ?? null;
  }
  /**
   * 现有的范围集合中添加一个新的范围
   * @param range
   * @param newLength
   */
  addRangeAndResize(range, newLength) {
    let idxFirstMightBeIntersecting = 0;
    while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {
      idxFirstMightBeIntersecting++;
    }
    let idxFirstIsAfter = idxFirstMightBeIntersecting;
    while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {
      idxFirstIsAfter++;
    }
    const delta = newLength - range.length;
    for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {
      this._ranges[i] = this._ranges[i].delta(delta);
    }
    if (idxFirstMightBeIntersecting === idxFirstIsAfter) {
      const newRange = new OffsetRange(range.start, range.start + newLength);
      if (!newRange.isEmpty) {
        this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);
      }
    } else {
      const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);
      const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);
      const newRange = new OffsetRange(start, endEx + delta);
      if (!newRange.isEmpty) {
        this._ranges.splice(
          idxFirstMightBeIntersecting,
          idxFirstIsAfter - idxFirstMightBeIntersecting,
          newRange
        );
      } else {
        this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);
      }
    }
  }
  /**
   * 删除一个值
   * @param value
   */
  delete(value) {
    const idx = this._ranges.findIndex((r) => r.contains(value));
    if (idx !== -1) {
      const range = this._ranges[idx];
      if (range.start === value) {
        if (range.endExclusive === value + 1) {
          this._ranges.splice(idx, 1);
        } else {
          this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);
        }
      } else {
        if (range.endExclusive === value + 1) {
          this._ranges[idx] = new OffsetRange(range.start, value);
        } else {
          this._ranges.splice(
            idx,
            1,
            new OffsetRange(range.start, value),
            new OffsetRange(value + 1, range.endExclusive)
          );
        }
      }
    }
  }
};
var JsonBackgroundTokenizer = class {
  constructor(_jsonTokenizerWithStateStoreAndModel, _backgroundTokenizationStore) {
    this._jsonTokenizerWithStateStoreAndModel = _jsonTokenizerWithStateStoreAndModel;
    this._backgroundTokenizationStore = _backgroundTokenizationStore;
  }
  handleChanges() {
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    runWhenGlobalIdle((deadline) => {
      this._backgroundTokenizeWithDeadline(deadline);
    });
  }
  _backgroundTokenizeWithDeadline(deadline) {
    const endTime = Date.now() + deadline.timeRemaining();
    const execute = () => {
      if (!this._hasLinesToTokenize()) return;
      this._backgroundTokenize();
      if (Date.now() < endTime) {
        setTimeout(execute);
      } else {
        this._beginBackgroundTokenization();
      }
    };
    execute();
  }
  _backgroundTokenize() {
    const lineCount = this._jsonTokenizerWithStateStoreAndModel._jsonModel.getLineCount();
    const stopWatch = StopWatch.create(true);
    do {
      if (stopWatch.elapsed() > 1) {
        break;
      }
      const tokenizedNumber = this._tokenizeOneInvalidLine();
      if (tokenizedNumber > lineCount) {
        break;
      }
    } while (this._hasLinesToTokenize());
  }
  _hasLinesToTokenize() {
    if (!this._jsonTokenizerWithStateStoreAndModel) {
      return false;
    }
    return !this._jsonTokenizerWithStateStoreAndModel.store.allStatesValid();
  }
  _tokenizeOneInvalidLine() {
    const firstInvalidLine = this._jsonTokenizerWithStateStoreAndModel.getFirstInvalidLine();
    if (!firstInvalidLine) {
      return this._jsonTokenizerWithStateStoreAndModel._jsonModel.getLineCount() + 1;
    }
    this._jsonTokenizerWithStateStoreAndModel.updateTokensUntilLine(
      firstInvalidLine.lineNumber,
      this._backgroundTokenizationStore
    );
    return firstInvalidLine.lineNumber;
  }
  requestTokens({ from, to }) {
    this._jsonTokenizerWithStateStoreAndModel.store.invalidateRange({
      from: from === 1 ? 1 : from - 1,
      to: to + 1
    });
  }
};

// src/tokens/tokenizationJsonModelPart.ts
var TokenizationJsonModelPart = class {
  constructor(jsonModel) {
    this._jsonModel = null;
    this.emitter = getEmitter();
    this._jsonModel = jsonModel;
    this.tokens = new GrammarTokens(this._jsonModel);
  }
  getLineTokens(lineNumber) {
    return this.tokens.getLineTokens(lineNumber);
  }
  handleDidChangeContent(e) {
    this.tokens.handleDidChangeContent(e);
  }
  forceTokenize(lineNumber) {
    this.tokens.forceTokenize(lineNumber);
  }
  requestTokens(range) {
    this.tokens.backgroundTokenizer?.requestTokens(range);
  }
};
var GrammarTokens = class {
  constructor(jsonModel) {
    this._tokens = /* @__PURE__ */ new Map();
    this._tokenizer = null;
    this._backgroundTokenizer = null;
    this.emitter = getEmitter();
    this._jsonModel = jsonModel;
    this.emitter.on("contentChanged", (e) => {
      let from = 0;
      let to = this._jsonModel.getLineCount();
      if (Array.isArray(e)) {
        from = e[e.length - 1].range.startLineNumber;
      } else {
        from = e.range.startLineNumber;
      }
      this._backgroundTokenizer?.requestTokens({
        from,
        to
      });
      this._backgroundTokenizer?.handleChanges();
    });
    this.resetTokenization();
  }
  get backgroundTokenizer() {
    return this._backgroundTokenizer;
  }
  resetTokenization() {
    this._tokens.clear();
    const JsonTokenizationSupport = createTokenizationSupport(true);
    const initialState = JsonTokenizationSupport.getInitialState();
    if (JsonTokenizationSupport && initialState) {
      this._tokenizer = new JsonTokenizerWithStateStoreAndModel(
        this._jsonModel.getLineCount(),
        JsonTokenizationSupport,
        this._jsonModel
      );
    }
    const b = {
      setTokens: (lineNumber, tokens) => {
        this._tokens.set(lineNumber, tokens);
      }
    };
    if (this._tokenizer) {
      this._backgroundTokenizer = new JsonBackgroundTokenizer(this._tokenizer, b);
      this._backgroundTokenizer.handleChanges();
    }
  }
  getLineTokens(lineNumber) {
    return this._tokens.get(lineNumber) || [];
  }
  handleDidChangeContent(e) {
    this._backgroundTokenizer?.handleChanges();
  }
  forceTokenize(lineNumber) {
    const b = {
      setTokens: (lineNumber2, tokens) => {
        this._tokens.set(lineNumber2, tokens);
      }
    };
    this._tokenizer?.updateTokensUntilLine(lineNumber, b);
  }
};

// src/view/virtualized/CellSizeAndPositionManager.ts
var CellSizeAndPositionManager = class {
  constructor(params) {
    this._lastMeasuredIndex = -1;
    this._cellSizeAndPositionData = {};
    this._lastBatchedIndex = -1;
    this._cellCount = params.cellCount;
    this._cellSizeGetter = params.cellSizeGetter;
    this._estimatedCellSize = params.estimatedCellSize;
  }
  areOffsetsAdjusted() {
    return false;
  }
  configure(params) {
    this._cellCount = params.cellCount;
    this._cellSizeGetter = params.cellSizeGetter;
    this._estimatedCellSize = params.estimatedCellSize;
  }
  getCellCount() {
    return this._cellCount;
  }
  getEstimatedCellSize() {
    return this._estimatedCellSize;
  }
  getLastMeasuredIndex() {
    return this._lastMeasuredIndex;
  }
  getOffsetAdjustment() {
    return 0;
  }
  getSizeAndPositionOfCell(index) {
    if (index < 0 || index >= this._cellCount) {
      throw new Error("index out of bounds");
    }
    if (index > this._lastMeasuredIndex) {
      const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
      let offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
      for (let i = this._lastMeasuredIndex + 1; i <= index; i++) {
        const size = this._cellSizeGetter({ index: i });
        if (size === void 0 || isNaN(size)) {
          throw new Error("invalid size");
        } else if (size === null) {
          this._cellSizeAndPositionData[i] = {
            offset,
            size: 0
          };
          this._lastBatchedIndex = index;
        } else {
          this._cellSizeAndPositionData[i] = {
            offset,
            size
          };
          offset += size;
          this._lastMeasuredIndex = index;
        }
      }
    }
    return this._cellSizeAndPositionData[index];
  }
  getSizeAndPositionOfLastMeasuredCell() {
    return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 };
  }
  getTotalSize() {
    const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
    const totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
    const numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;
    const totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
    return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
  }
  getUpdatedOffsetForIndex({ align, containerSize, currentOffset, targetIndex }) {
    if (currentOffset < 0) {
      return 0;
    }
    const datum = this.getSizeAndPositionOfCell(targetIndex);
    const maxOffset = datum.offset;
    const minOffset = maxOffset - containerSize + datum.size;
    let idealOffset = currentOffset;
    switch (align) {
      case "start":
        idealOffset = maxOffset;
        break;
      case "end":
        idealOffset = minOffset;
        break;
      case "center":
        idealOffset = maxOffset - (containerSize - datum.size) / 2;
        break;
      default:
        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
        break;
    }
    const totalSize = this.getTotalSize();
    return Math.max(0, Math.min(idealOffset, totalSize - containerSize));
  }
  getVisibleCellRange(params) {
    const containerSize = params.containerSize;
    let offset = params.offset;
    const totalSize = this.getTotalSize();
    if (totalSize === 0) {
      return {};
    }
    const maxOffset = offset + containerSize;
    const start = this._findNearestCell(offset);
    const datum = this.getSizeAndPositionOfCell(start);
    offset = datum.offset + datum.size;
    let stop = start;
    while (offset < maxOffset && stop < this._cellCount - 1) {
      stop++;
      offset += this.getSizeAndPositionOfCell(stop).size;
    }
    return {
      start,
      stop
    };
  }
  _binarySearch(high, low, offset) {
    while (low <= high) {
      const middle = low + Math.floor((high - low) / 2);
      const currentOffset = this.getSizeAndPositionOfCell(middle).offset;
      if (currentOffset === offset) {
        return middle;
      } else if (currentOffset < offset) {
        low = middle + 1;
      } else if (currentOffset > offset) {
        high = middle - 1;
      }
    }
    if (low > 0) {
      return low - 1;
    } else {
      return 0;
    }
  }
  resetCell(index) {
    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
  }
  _exponentialSearch(index, offset) {
    let interval = 1;
    while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {
      index += interval;
      interval *= 2;
    }
    return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
  }
  _findNearestCell(offset) {
    if (isNaN(offset)) {
      throw new Error("offset is NaN");
    }
    offset = Math.max(0, offset);
    const lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
    if (lastMeasuredCellSizeAndPosition.offset >= offset) {
      return this._binarySearch(lastMeasuredIndex, 0, offset);
    } else {
      return this._exponentialSearch(lastMeasuredIndex, offset);
    }
  }
};

// src/view/virtualized/ScalingCellSizeAndPositionManager.ts
var DEFAULT_MAX_ELEMENT_SIZE = 15e5;
var CHROME_MAX_ELEMENT_SIZE = 16777100;
var isBrowser = () => typeof window !== "undefined";
var isChrome = () => !!window.chrome;
var getMaxElementSize = () => {
  if (isBrowser()) {
    if (isChrome()) {
      return CHROME_MAX_ELEMENT_SIZE;
    }
  }
  return DEFAULT_MAX_ELEMENT_SIZE;
};
var ScalingCellSizeAndPositionManager = class {
  constructor({ maxScrollSize = getMaxElementSize(), cellCount, cellSizeGetter, estimatedCellSize }) {
    this._maxScrollSize = maxScrollSize;
    this._cellSizeAndPositionManager = new CellSizeAndPositionManager({
      cellCount,
      cellSizeGetter,
      estimatedCellSize
    });
  }
  areOffsetsAdjusted() {
    return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
  }
  configure(params) {
    this._cellSizeAndPositionManager.configure(params);
  }
  getCellCount() {
    return this._cellSizeAndPositionManager.getCellCount();
  }
  getEstimatedCellSize() {
    return this._cellSizeAndPositionManager.getEstimatedCellSize();
  }
  getLastMeasuredIndex() {
    return this._cellSizeAndPositionManager.getLastMeasuredIndex();
  }
  getOffsetAdjustment({ containerSize, offset }) {
    const totalSize = this._cellSizeAndPositionManager.getTotalSize();
    const safeTotalSize = this.getTotalSize();
    const offsetPercentage = this._getOffsetPercentage({
      containerSize,
      offset,
      totalSize: safeTotalSize
    });
    return Math.round(offsetPercentage * (safeTotalSize - totalSize));
  }
  getTotalSize() {
    return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
  }
  getSizeAndPositionOfCell(index) {
    return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
  }
  getSizeAndPositionOfLastMeasuredCell() {
    return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
  }
  getVisibleCellRange({
    containerSize,
    offset
    // safe
  }) {
    offset = this._safeOffsetToOffset({
      containerSize,
      offset
    });
    return this._cellSizeAndPositionManager.getVisibleCellRange({
      containerSize,
      offset
    });
  }
  resetCell(index) {
    this._cellSizeAndPositionManager.resetCell(index);
  }
  getUpdatedOffsetForIndex({
    align = "auto",
    containerSize,
    currentOffset,
    // safe
    targetIndex
  }) {
    currentOffset = this._safeOffsetToOffset({
      containerSize,
      offset: currentOffset
    });
    const offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
      align,
      containerSize,
      currentOffset,
      targetIndex
    });
    return this._offsetToSafeOffset({
      containerSize,
      offset
    });
  }
  _getOffsetPercentage({
    containerSize,
    offset,
    // safe
    totalSize
  }) {
    return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
  }
  _offsetToSafeOffset({
    containerSize,
    offset
    // unsafe
  }) {
    const totalSize = this._cellSizeAndPositionManager.getTotalSize();
    const safeTotalSize = this.getTotalSize();
    if (totalSize === safeTotalSize) {
      return offset;
    } else {
      const offsetPercentage = this._getOffsetPercentage({
        containerSize,
        offset,
        totalSize
      });
      return Math.round(offsetPercentage * (safeTotalSize - containerSize));
    }
  }
  _safeOffsetToOffset({
    containerSize,
    offset
    // safe
  }) {
    const totalSize = this._cellSizeAndPositionManager.getTotalSize();
    const safeTotalSize = this.getTotalSize();
    if (totalSize === safeTotalSize) {
      return offset;
    } else {
      const offsetPercentage = this._getOffsetPercentage({
        containerSize,
        offset,
        totalSize: safeTotalSize
      });
      return Math.round(offsetPercentage * (totalSize - containerSize));
    }
  }
};

// src/service/jsonService.ts
import { format } from "jsonc-parser";

// src/service/parse.ts
import * as Json from "jsonc-parser";

// src/service/jsonTypes.ts
var Diagnostic = class _Diagnostic {
  constructor(message, code, range) {
    this.message = message;
    this.code = code;
    this.range = range;
  }
  static create(message, code, range) {
    return new _Diagnostic(message, code, range);
  }
};
var ErrRange = class _ErrRange {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  static create(start, end) {
    return new _ErrRange(start, end);
  }
};
var CompletionItemKind;
((CompletionItemKind2) => {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
var InsertTextFormat;
((InsertTextFormat2) => {
  InsertTextFormat2.PlainText = 1;
  InsertTextFormat2.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var TextEdit;
((TextEdit2) => {
  function replace(range, newText) {
    return {
      range,
      newText
    };
  }
  TextEdit2.replace = replace;
})(TextEdit || (TextEdit = {}));
var CompletionItem;
((CompletionItem2) => {
  function create(label) {
    return { label };
  }
  CompletionItem2.create = create;
})(CompletionItem || (CompletionItem = {}));

// src/service/parse.ts
function getNodePath2(node) {
  return Json.getNodePath(node);
}
function getPathChain(path) {
  let result = "root";
  for (let i = 0; i < path.length; i++) {
    if (typeof path[i] === "number") {
      result += "[" + path[i] + "]";
    } else {
      result += "." + path[i];
    }
  }
  return result;
}
function contains(node, offset, includeRightBound = false) {
  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
}
var ASTNodeImpl = class {
  constructor(parent, offset, length = 0) {
    this.offset = offset;
    this.length = length;
    this.parent = parent;
  }
  get children() {
    return [];
  }
  toString() {
    return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : "");
  }
};
var NullASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, offset) {
    super(parent, offset);
    this.type = "null";
    this.value = null;
  }
};
var BooleanASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, boolValue, offset) {
    super(parent, offset);
    this.type = "boolean";
    this.value = boolValue;
  }
};
var ArrayASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, offset) {
    super(parent, offset);
    this.type = "array";
    this.items = [];
  }
  get children() {
    return this.items;
  }
};
var NumberASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, offset) {
    super(parent, offset);
    this.type = "number";
    this.isInteger = true;
    this.value = Number.NaN;
  }
};
var ObjectASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, offset) {
    super(parent, offset);
    this.type = "object";
    this.properties = [];
  }
  get children() {
    return this.properties;
  }
};
var StringASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, offset, length) {
    super(parent, offset, length);
    this.type = "string";
    this.value = "";
  }
};
var PropertyASTNodeImpl = class extends ASTNodeImpl {
  constructor(parent, offset, keyNode) {
    super(parent, offset);
    this.type = "property";
    this.colonOffset = -1;
    this.keyNode = keyNode;
  }
  get children() {
    return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
  }
};
var JsonDocument = class {
  constructor(root) {
    this.root = root;
  }
  getNodeFromOffset(offset, includeRightBound = false) {
    if (!this.root) {
      return void 0;
    }
    return Json.findNodeAtOffset(this.root, offset, includeRightBound);
  }
  visit(visitor) {
    if (this.root) {
      const doVisit = (node) => {
        let ctn = visitor(node);
        const children = node.children;
        if (Array.isArray(children)) {
          for (let i = 0; i < children.length && ctn; i++) {
            ctn = doVisit(children[i]);
          }
        }
        return ctn;
      };
      doVisit(this.root);
    }
  }
};
function parseJson(jsonModel) {
  const problems = [];
  let lastProblemOffset = -1;
  const text = jsonModel.getValue();
  const scanner = Json.createScanner(text, false);
  function _scanNext() {
    while (true) {
      const token2 = scanner.scan();
      _checkScanError();
      switch (token2) {
        case Json.SyntaxKind.LineBreakTrivia:
        case Json.SyntaxKind.Trivia:
          break;
        default:
          return token2;
      }
    }
  }
  function _checkScanError() {
    switch (scanner.getTokenError()) {
      case Json.ScanError.InvalidUnicode:
        _error("Invalid unicode sequence in string.", 260 /* InvalidUnicode */);
        return true;
      case Json.ScanError.InvalidEscapeCharacter:
        _error("Invalid escape character in string.", 261 /* InvalidEscapeCharacter */);
        return true;
      case Json.ScanError.UnexpectedEndOfNumber:
        _error("Unexpected end of number.", 259 /* UnexpectedEndOfNumber */);
        return true;
      case Json.ScanError.UnexpectedEndOfComment:
        _error("Unexpected end of comment.", 257 /* UnexpectedEndOfComment */);
        return true;
      case Json.ScanError.UnexpectedEndOfString:
        _error("Unexpected end of string.", 258 /* UnexpectedEndOfString */);
        return true;
      case Json.ScanError.InvalidCharacter:
        _error("Invalid characters in string. Control characters must be escaped.", 262 /* InvalidCharacter */);
        return true;
    }
    return false;
  }
  function _errorAtRange(message, code, startOffset, endOffset) {
    if (problems.length === 0 || startOffset !== lastProblemOffset) {
      const range = ErrRange.create(jsonModel.positionAt(startOffset), jsonModel.positionAt(endOffset));
      problems.push(Diagnostic.create(message, code, range));
      lastProblemOffset = startOffset;
    }
    return;
  }
  function _finalize(node, scanNext) {
    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;
    if (scanNext) {
      _scanNext();
    }
    return node;
  }
  function _error(message, code, node = void 0, skipUntilAfter = [], skipUntil = []) {
    let start = scanner.getTokenOffset();
    let end = scanner.getTokenOffset() + scanner.getTokenLength();
    if (start === end && start > 0) {
      start--;
      while (start > 0 && /\s/.test(text.charAt(start))) {
        start--;
      }
      end = start + 1;
    }
    _errorAtRange(message, code, start, end);
    if (node) {
      _finalize(node, false);
    }
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token2 = scanner.getToken();
      while (token2 !== Json.SyntaxKind.EOF) {
        if (skipUntilAfter.indexOf(token2) !== -1) {
          _scanNext();
          break;
        } else if (skipUntil.indexOf(token2) !== -1) {
          break;
        }
        token2 = _scanNext();
      }
    }
    return node;
  }
  function _parseArray(parent) {
    if (scanner.getToken() !== Json.SyntaxKind.OpenBracketToken) {
      return void 0;
    }
    const node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());
    _scanNext();
    let needComma = false;
    while (scanner.getToken() !== Json.SyntaxKind.CloseBracketToken && scanner.getToken() !== Json.SyntaxKind.EOF) {
      if (scanner.getToken() === Json.SyntaxKind.CommaToken) {
        if (!needComma) {
          _error("Value expected.", 516 /* ValueExpected */);
        }
        const commaOffset = scanner.getTokenOffset();
        _scanNext();
        if (scanner.getToken() === Json.SyntaxKind.CloseBracketToken) {
          if (needComma) {
            _errorAtRange("Trailing comma", 519 /* TrailingComma */, commaOffset, commaOffset + 1);
          }
          continue;
        }
      } else if (needComma) {
        _error("Comma expected.", 514 /* CommaExpected */, void 0, [], [Json.SyntaxKind.CloseBracketToken]);
        break;
      }
      const item = _parseValue(node);
      if (!item) {
        _error("Value expected.", 516 /* ValueExpected */, void 0, [], [Json.SyntaxKind.CloseBracketToken]);
        break;
      } else {
        node.items.push(item);
      }
      needComma = true;
    }
    if (scanner.getToken() !== Json.SyntaxKind.CloseBracketToken) {
      return _error("Expected comma or closing bracket", 518 /* CommaOrCloseBraceExpected */, node);
    }
    return _finalize(node, true);
  }
  const keyPlaceholder = new StringASTNodeImpl(void 0, 0, 0);
  function _parseProperty(parent, keysSeen) {
    const node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);
    let key = _parseString(node);
    if (!key) {
      if (scanner.getToken() === Json.SyntaxKind.Unknown) {
        _error("Property keys must be doublequoted", 528 /* PropertyKeysMustBeDoublequoted */);
        const keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());
        keyNode.value = scanner.getTokenValue();
        key = keyNode;
        _scanNext();
      } else {
        return void 0;
      }
    }
    node.keyNode = key;
    if (key.value !== "//") {
      const seen = keysSeen[key.value];
      if (seen) {
        _errorAtRange(
          "Duplicate object key",
          520 /* DuplicateKey */,
          node.keyNode.offset,
          node.keyNode.offset + node.keyNode.length
        );
        if (isObject(seen)) {
          _errorAtRange(
            "Duplicate object key",
            520 /* DuplicateKey */,
            seen.keyNode.offset,
            seen.keyNode.offset + seen.keyNode.length
          );
        }
        keysSeen[key.value] = true;
      } else {
        keysSeen[key.value] = node;
      }
    }
    if (scanner.getToken() === Json.SyntaxKind.ColonToken) {
      node.colonOffset = scanner.getTokenOffset();
      _scanNext();
    } else {
      _error("Colon expected", 515 /* ColonExpected */);
      if (scanner.getToken() === Json.SyntaxKind.StringLiteral && jsonModel.positionAt(key.offset + key.length).lineNumber < jsonModel.positionAt(scanner.getTokenOffset()).lineNumber) {
        node.length = key.length;
        return node;
      }
    }
    const value = _parseValue(node);
    if (!value) {
      return _error(
        "Value expected",
        516 /* ValueExpected */,
        node,
        [],
        [Json.SyntaxKind.CloseBraceToken, Json.SyntaxKind.CommaToken]
      );
    }
    node.valueNode = value;
    node.length = value.offset + value.length - node.offset;
    return node;
  }
  function _parseObject(parent) {
    if (scanner.getToken() !== Json.SyntaxKind.OpenBraceToken) {
      return void 0;
    }
    const node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());
    const keysSeen = /* @__PURE__ */ Object.create(null);
    _scanNext();
    let needsComma = false;
    while (scanner.getToken() !== Json.SyntaxKind.CloseBraceToken && scanner.getToken() !== Json.SyntaxKind.EOF) {
      if (scanner.getToken() === Json.SyntaxKind.CommaToken) {
        if (!needsComma) {
          _error("Property expected", 513 /* PropertyExpected */);
        }
        const commaOffset = scanner.getTokenOffset();
        _scanNext();
        if (scanner.getToken() === Json.SyntaxKind.CloseBraceToken) {
          if (needsComma) {
            _errorAtRange("Trailing comma", 519 /* TrailingComma */, commaOffset, commaOffset + 1);
          }
          continue;
        }
      } else if (needsComma) {
        _error("Expected comma", 514 /* CommaExpected */);
      }
      const property = _parseProperty(node, keysSeen);
      if (!property) {
        _error(
          "Property expected",
          513 /* PropertyExpected */,
          void 0,
          [],
          [Json.SyntaxKind.CloseBraceToken, Json.SyntaxKind.CommaToken]
        );
      } else {
        node.properties.push(property);
      }
      needsComma = true;
    }
    if (scanner.getToken() !== Json.SyntaxKind.CloseBraceToken) {
      return _error("Expected comma or closing brace", 518 /* CommaOrCloseBraceExpected */, node);
    }
    return _finalize(node, true);
  }
  function _parseString(parent) {
    if (scanner.getToken() !== Json.SyntaxKind.StringLiteral) {
      return void 0;
    }
    const node = new StringASTNodeImpl(parent, scanner.getTokenOffset());
    node.value = scanner.getTokenValue();
    return _finalize(node, true);
  }
  function _parseNumber(parent) {
    if (scanner.getToken() !== Json.SyntaxKind.NumericLiteral) {
      return void 0;
    }
    const node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());
    if (scanner.getTokenError() === Json.ScanError.None) {
      const tokenValue = scanner.getTokenValue();
      try {
        const numberValue = JSON.parse(tokenValue);
        if (!isNumber(numberValue)) {
          return _error("Invalid number format.", 0 /* Undefined */, node);
        }
        node.value = numberValue;
      } catch (e) {
        return _error("Invalid number format.", 0 /* Undefined */, node);
      }
      node.isInteger = tokenValue.indexOf(".") === -1;
    }
    return _finalize(node, true);
  }
  function _parseLiteral(parent) {
    let node;
    switch (scanner.getToken()) {
      case Json.SyntaxKind.NullKeyword:
        return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);
      case Json.SyntaxKind.TrueKeyword:
        return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);
      case Json.SyntaxKind.FalseKeyword:
        return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);
      default:
        return void 0;
    }
  }
  function _parseValue(parent) {
    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);
  }
  let _root = void 0;
  const token = _scanNext();
  if (token !== Json.SyntaxKind.EOF) {
    _root = _parseValue(_root);
    if (!_root) {
      _error("Expected a JSON object, array or literal", 0 /* Undefined */);
    } else if (scanner.getToken() !== Json.SyntaxKind.EOF) {
      _error("End of file expected.", 0 /* Undefined */);
    }
  }
  return {
    problems,
    root: new JsonDocument(_root)
  };
}

// src/service/jsonService.ts
function parseJsonAst(jsonModel) {
  return parseJson(jsonModel).root;
}

// src/common/position.ts
var Position = class {
  constructor(lineNumber, column) {
    this.lineNumber = lineNumber;
    this.column = column;
  }
};

// src/common/range.ts
var Range2 = class _Range {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
      this.startLineNumber = endLineNumber;
      this.startColumn = endColumn;
      this.endLineNumber = startLineNumber;
      this.endColumn = startColumn;
    } else {
      this.startLineNumber = startLineNumber;
      this.startColumn = startColumn;
      this.endLineNumber = endLineNumber;
      this.endColumn = endColumn;
    }
  }
  static create(start, end) {
    return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(a, b) {
    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(range) {
    return _Range.plusRange(this, range);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(a, b) {
    let startLineNumber;
    let startColumn;
    let endLineNumber;
    let endColumn;
    if (b.startLineNumber < a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = b.startColumn;
    } else if (b.startLineNumber === a.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = Math.min(b.startColumn, a.startColumn);
    } else {
      startLineNumber = a.startLineNumber;
      startColumn = a.startColumn;
    }
    if (b.endLineNumber > a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = b.endColumn;
    } else if (b.endLineNumber === a.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = Math.max(b.endColumn, a.endColumn);
    } else {
      endLineNumber = a.endLineNumber;
      endColumn = a.endColumn;
    }
    return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return _Range.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(range) {
    return new Position(range.startLineNumber, range.startColumn);
  }
};

// src/service/completion.ts
import * as Json2 from "jsonc-parser";
var JSONCompletion = class {
  constructor(options) {
    this._options = options;
  }
  doCompletion(jsonModel, position, doc) {
    const result = {
      items: [],
      isIncomplete: false
    };
    const text = jsonModel.getValue();
    const offset = jsonModel.getOffsetAt(position.lineNumber, position.column);
    let node = doc.getNodeFromOffset(offset, true);
    if (node && offset === node.offset + node.length && offset > 0) {
      const ch = text[offset - 1];
      if (node.type === "object" && ch === "}" || node.type === "array" && ch === "]") {
        node = node.parent;
      }
    }
    const currentWord = this.getCurrentWord(jsonModel, offset);
    let overwriteRange;
    if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
      overwriteRange = Range2.create(
        jsonModel.positionAt(node.offset),
        jsonModel.positionAt(node.offset + node.length)
      );
    } else {
      let overwriteStart = offset - currentWord.length;
      if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
        overwriteStart--;
      }
      overwriteRange = Range2.create(jsonModel.positionAt(overwriteStart), position);
    }
    const proposed = /* @__PURE__ */ new Map();
    const collector = {
      add: (suggestion) => {
        let label = suggestion.label;
        const existing = proposed.get(label);
        if (!existing) {
          label = label.replace(/[\n]/g, "\u21B5");
          if (label.length > 60) {
            const shortenedLabel = label.substring(0, 57).trim() + "...";
            if (!proposed.has(shortenedLabel)) {
              label = shortenedLabel;
            }
          }
          suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);
          suggestion.label = label;
          proposed.set(label, suggestion);
          result.items.push(suggestion);
        } else {
          if (!existing.documentation) {
            existing.documentation = suggestion.documentation;
          }
          if (!existing.detail) {
            existing.detail = suggestion.detail;
          }
          if (!existing.labelDetails) {
            existing.labelDetails = suggestion.labelDetails;
          }
        }
      },
      setAsIncomplete: () => {
        result.isIncomplete = true;
      },
      error: (message) => {
        console.error(message);
      },
      getNumberOfProposals: () => {
        return result.items.length;
      }
    };
    return Promise.resolve().then(() => {
      const collectionPromises = [];
      let addValue = true;
      let currentKey = "";
      let currentProperty = void 0;
      if (node) {
        if (node.type === "string") {
          const parent = node.parent;
          if (parent && parent.type === "property" && parent.keyNode === node) {
            addValue = !parent.valueNode;
            currentProperty = parent;
            currentKey = text.substr(node.offset + 1, node.length - 2);
            if (parent) {
              node = parent.parent;
            }
          }
        }
      }
      if (node && node.type === "object") {
        if (node.offset === offset) {
          return result;
        }
        const properties = node.properties;
        properties.forEach((p) => {
          if (!currentProperty || currentProperty !== p) {
            proposed.set(p.keyNode.value, CompletionItem.create("__"));
          }
        });
        let separatorAfter = "";
        if (addValue) {
          separatorAfter = this.evaluateSeparatorAfter(
            jsonModel,
            jsonModel.getOffsetAt(overwriteRange.endLineNumber, overwriteRange.endColumn)
          );
        }
        this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector, currentWord);
        if (currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
          collector.add({
            kind: CompletionItemKind.Property,
            label: this.getLabelForValue(currentWord),
            insertText: this.getInsertTextForProperty(currentWord, void 0, false, separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: ""
          });
          collector.setAsIncomplete();
        }
      }
      const types = {};
      this.getSchemaLessValueCompletions(doc, node, offset, jsonModel, collector);
      return Promise.all(collectionPromises).then(() => {
        if (collector.getNumberOfProposals() === 0) {
          let offsetForSeparator = offset;
          if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
            offsetForSeparator = node.offset + node.length;
          }
          const separatorAfter = this.evaluateSeparatorAfter(jsonModel, offsetForSeparator);
          this.addFillerValueCompletions(types, separatorAfter, collector);
        } else if (this._options?.staticCompletions) {
          this._options.staticCompletions.forEach((item) => {
            collector.add({
              label: item.label,
              insertText: item.insertText || item.label,
              documentation: item.documentation || ""
            });
          });
        }
        return result;
      });
    });
  }
  /**
   * 获取光标位置前的当前单词
   * @param jsonModel
   * @param offset
   * @returns
   */
  getCurrentWord(jsonModel, offset) {
    let i = offset - 1;
    const text = jsonModel.getValue();
    while (i >= 0 && ' 	\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1) {
      i--;
    }
    return text.substring(i + 1, offset);
  }
  evaluateSeparatorAfter(jsonModel, offset) {
    const scanner = Json2.createScanner(jsonModel.getValue(), true);
    scanner.setPosition(offset);
    const token = scanner.scan();
    switch (token) {
      case Json2.SyntaxKind.CommaToken:
      case Json2.SyntaxKind.CloseBraceToken:
      case Json2.SyntaxKind.CloseBracketToken:
      case Json2.SyntaxKind.EOF:
        return "";
      default:
        return ",";
    }
  }
  getLabelForValue(value) {
    return JSON.stringify(value);
  }
  getInsertTextForPlainText(text) {
    return text.replace(/[\\\$\}]/g, "\\$&");
  }
  getInsertTextForValue(value, separatorAfter) {
    const text = JSON.stringify(value, null, "	");
    if (text === "{}") {
      return "{$1}" + separatorAfter;
    } else if (text === "[]") {
      return "[$1]" + separatorAfter;
    }
    return this.getInsertTextForPlainText(text + separatorAfter);
  }
  getFilterTextForValue(value) {
    return JSON.stringify(value);
  }
  getInsertTextForProperty(key, propertySchema, addValue, separatorAfter) {
    const propertyText = this.getInsertTextForValue(key, "");
    if (!addValue) {
      return propertyText;
    }
    const resultText = propertyText + ": ";
    let value;
    const nValueProposals = 0;
    if (propertySchema) {
    }
    if (!value || nValueProposals > 1) {
      value = "$1";
    }
    return resultText + value + separatorAfter;
  }
  getSchemaLessPropertyCompletions(doc, node, currentKey, collector, currentWord) {
    const collectCompletionsForSimilarObject = (obj) => {
      obj.properties.forEach((p) => {
        const key = p.keyNode.value;
        if (key.toLowerCase().startsWith(currentWord.toLowerCase()) && currentWord !== "") {
          collector.add({
            kind: CompletionItemKind.Property,
            label: key,
            insertText: this.getInsertTextForValue(key, ""),
            insertTextFormat: InsertTextFormat.Snippet,
            filterText: this.getFilterTextForValue(key),
            documentation: ""
          });
        }
      });
    };
    if (node.parent) {
      if (node.parent.type === "property") {
        const parentKey = node.parent.keyNode.value;
        doc.visit((n) => {
          if (n.type === "property" && n !== node.parent && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === "object") {
            collectCompletionsForSimilarObject(n.valueNode);
          }
          return true;
        });
      } else if (node.parent.type === "array") {
        node.parent.items.forEach((n) => {
          if (n.type === "object" && n !== node) {
            collectCompletionsForSimilarObject(n);
          }
        });
      }
    }
  }
  addFillerValueCompletions(types, separatorAfter, collector) {
    if (types["object"]) {
      collector.add({
        kind: this.getSuggestionKind("object"),
        label: "{}",
        insertText: this.getInsertTextForGuessedValue({}, separatorAfter),
        insertTextFormat: InsertTextFormat.Snippet,
        detail: "New object",
        documentation: ""
      });
    }
    if (types["array"]) {
      collector.add({
        kind: this.getSuggestionKind("array"),
        label: "[]",
        insertText: this.getInsertTextForGuessedValue([], separatorAfter),
        insertTextFormat: InsertTextFormat.Snippet,
        detail: "New array",
        documentation: ""
      });
    }
  }
  getInsertTextForGuessedValue(value, separatorAfter) {
    switch (typeof value) {
      case "object":
        if (value === null) {
          return "${1:null}" + separatorAfter;
        }
        return this.getInsertTextForValue(value, separatorAfter);
      case "string":
        let snippetValue = JSON.stringify(value);
        snippetValue = snippetValue.substr(1, snippetValue.length - 2);
        snippetValue = this.getInsertTextForPlainText(snippetValue);
        return '"${1:' + snippetValue + '}"' + separatorAfter;
      case "number":
      case "boolean":
        return "${1:" + JSON.stringify(value) + "}" + separatorAfter;
    }
    return this.getInsertTextForValue(value, separatorAfter);
  }
  getSuggestionKind(type) {
    if (Array.isArray(type)) {
      const array = type;
      type = array.length > 0 ? array[0] : void 0;
    }
    if (!type) {
      return CompletionItemKind.Value;
    }
    switch (type) {
      case "string":
        return CompletionItemKind.Value;
      case "object":
        return CompletionItemKind.Module;
      case "property":
        return CompletionItemKind.Property;
      default:
        return CompletionItemKind.Value;
    }
  }
  getSchemaLessValueCompletions(doc, node, offset, jsonModel, collector) {
    let offsetForSeparator = offset;
    if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
      offsetForSeparator = node.offset + node.length;
      node = node.parent;
    }
    if (!node) {
      return;
    }
    const separatorAfter = this.evaluateSeparatorAfter(jsonModel, offsetForSeparator);
    const collectSuggestionsForValues = (value) => {
      if (value.parent && !contains(value.parent, offset, true)) {
        collector.add({
          kind: this.getSuggestionKind(value.type),
          label: this.getLabelTextForMatchingNode(value, jsonModel),
          insertText: this.getInsertTextForMatchingNode(value, jsonModel, separatorAfter),
          insertTextFormat: InsertTextFormat.Snippet,
          documentation: ""
        });
      }
      if (value.type === "boolean") {
        this.addBooleanValueCompletion(!value.value, separatorAfter, collector);
      }
    };
    if (node.type === "property") {
      if (offset > (node.colonOffset || 0)) {
        const valueNode = node.valueNode;
        if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === "object" || valueNode.type === "array")) {
          return;
        }
        const parentKey = node.keyNode.value;
        doc.visit((n) => {
          if (n.type === "property" && n.keyNode.value === parentKey && n.valueNode) {
            collectSuggestionsForValues(n.valueNode);
          }
          return true;
        });
      }
    }
    if (node.type === "array") {
      if (node.parent && node.parent.type === "property") {
        const parentKey = node.parent.keyNode.value;
        doc.visit((n) => {
          if (n.type === "property" && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === "array") {
            n.valueNode.items.forEach(collectSuggestionsForValues);
          }
          return true;
        });
      } else {
        node.items.forEach(collectSuggestionsForValues);
      }
    }
  }
  getLabelTextForMatchingNode(node, jsonModel) {
    switch (node.type) {
      case "array":
        return "[]";
      case "object":
        return "{}";
      default:
        const content = jsonModel.getValue().substr(node.offset, node.length);
        return content;
    }
  }
  getInsertTextForMatchingNode(node, jsonModel, separatorAfter) {
    switch (node.type) {
      case "array":
        return this.getInsertTextForValue([], separatorAfter);
      case "object":
        return this.getInsertTextForValue({}, separatorAfter);
      default:
        const content = jsonModel.getValue().substr(node.offset, node.length) + separatorAfter;
        return this.getInsertTextForPlainText(content);
    }
  }
  addBooleanValueCompletion(value, separatorAfter, collector) {
    collector.add({
      kind: this.getSuggestionKind("boolean"),
      label: value ? "true" : "false",
      insertText: this.getInsertTextForValue(value, separatorAfter),
      insertTextFormat: InsertTextFormat.Snippet,
      documentation: ""
    });
  }
};

// src/view/complete/completeWidget.ts
var CompleteWidget = class {
  constructor(view, jsonModel, selectionModel) {
    this._selectedIndex = 0;
    this._suggestions = [];
    this.isVisible = false;
    this.emitter = getEmitter();
    this._handleKeyDown = (e) => {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          this._selectedIndex = (this._selectedIndex + 1) % this._suggestions.length;
          this._renderCompletions();
          break;
        case "ArrowUp":
          e.preventDefault();
          this._selectedIndex = (this._selectedIndex - 1 + this._suggestions.length) % this._suggestions.length;
          this._renderCompletions();
          break;
        case "Enter":
        case "Tab":
          e.preventDefault();
          const selectedItem = this._suggestions[this._selectedIndex];
          const { textEdit } = selectedItem;
          if (!textEdit) {
            return;
          }
          const { range } = textEdit;
          const startOffset = this._jsonModel.getOffsetAt(range.startLineNumber, range.startColumn);
          const endOffset = this._jsonModel.getOffsetAt(range.endLineNumber, range.endColumn);
          const op = {
            type: "replace",
            range: {
              startLineNumber: range.startLineNumber,
              startColumn: range.startColumn,
              endLineNumber: range.endLineNumber,
              endColumn: range.endColumn
            },
            rangeLength: endOffset - startOffset,
            rangeOffset: startOffset,
            oldText: this._jsonModel.getValueInRange(range),
            newText: textEdit?.newText || ""
          };
          this._jsonModel.applyOperation(op);
          this.hide();
          break;
      }
    };
    this._view = view;
    this._jsonModel = jsonModel;
    this._selectionModel = selectionModel;
    this._container = this.createCompleteContainer();
    this._suggestionsContainer = this.createSuggestionsContainer();
    this._container.appendChild(this._suggestionsContainer);
    this._view.jsonViewerDom.appendChild(this._container);
    this._attachEventListeners();
  }
  _attachEventListeners() {
    const shouldTrigger = (e) => {
      if (e.type !== "insert") {
        return false;
      }
      if (e.newText.length !== 1) {
        return false;
      }
      if (/\s/.test(e.newText)) {
        return false;
      }
      return true;
    };
    this.emitter.on("contentChanged", (e) => {
      if (Array.isArray(e)) {
        return;
      }
      if (!shouldTrigger(e)) {
        this.hide();
        return;
      }
      this._fetchCompletions();
    });
  }
  _fetchCompletions() {
    const root = parseJsonAst(this._jsonModel);
    const position = {
      lineNumber: this._jsonModel.lastChangeBufferPos.lineNumber,
      column: this._jsonModel.lastChangeBufferPos.column
    };
    new JSONCompletion(this._view.options?.completionOptions || null).doCompletion(this._jsonModel, position, root).then((completions) => {
      this._suggestions = completions.items || [];
      this.show();
    });
  }
  _calculatePosition() {
    const selection = window.getSelection();
    if (!selection || !selection.rangeCount) return { x: 0, y: 0 };
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    const editorRect = this._view.contentDom.getBoundingClientRect();
    const x = rect.left - editorRect.left + 50;
    const y = rect.bottom - editorRect.top;
    return { x, y };
  }
  createCompleteContainer() {
    const className = "semi-json-viewer-complete-container";
    const container = elt("div", className);
    setStyles(container, {
      display: "none"
    });
    return container;
  }
  createSuggestionsContainer() {
    const className = "semi-json-viewer-complete-suggestions-container";
    const container = elt("div", className);
    setStyles(container, {
      maxHeight: "200px",
      overflowY: "auto"
    });
    return container;
  }
  show() {
    if (this._suggestions.length === 0) {
      return;
    }
    const { x, y } = this._calculatePosition();
    if (x < 0 || y < 0) {
      return;
    }
    this.isVisible = true;
    setStyles(this._container, {
      left: `${x}px`,
      top: `${y}px`,
      display: "block"
    });
    this._suggestionsContainer.innerHTML = "";
    this._renderCompletions();
  }
  _renderCompletions() {
    const className = "semi-json-viewer-complete-suggestions-item";
    this._suggestionsContainer.innerHTML = this._suggestions.map(
      (item, index) => `
        <li class="${className}" style="background-color: ${index === this._selectedIndex ? "var(--semi-color-fill-0)" : "transparent"}" data-index="${index}">
            ${item.label}
        </li>
    `
    ).join("");
  }
  hide() {
    if (!this.isVisible) return;
    this.isVisible = false;
    this._container.style.display = "none";
    this._suggestions = [];
  }
};

// src/view/hover/hoverWidget.ts
var HoverWidget = class {
  constructor(view) {
    this._hoverDom = null;
    this._hoverTimer = null;
    this.emitter = getEmitter();
    this._view = view;
    this._tooltipDom = this._createTooltipDom();
    this._view.jsonViewerDom.appendChild(this._tooltipDom);
    this._attachEventListeners();
  }
  _attachEventListeners() {
    this._view.contentDom.addEventListener("mousemove", (e) => {
      if (e.target instanceof HTMLSpanElement && e.target.classList.contains("semi-json-viewer-string-value")) {
        if (this._hoverDom === e.target) {
          return;
        }
        this._clearHoverTimer();
        this._hideTooltip();
        this._hoverDom = e.target;
        this._hoverTimer = window.setTimeout(() => {
          if (this._hoverDom) {
            this.emitter.emit("hoverNode", {
              value: this._hoverDom.textContent ?? "",
              target: this._hoverDom
            });
          }
        }, 700);
      }
    });
    this._view.contentDom.addEventListener("mouseout", (e) => {
      const relatedTarget = e.relatedTarget;
      if (!this._tooltipDom.contains(relatedTarget)) {
        this._clearHoverTimer();
        this._hideTooltip();
      }
    });
    this._tooltipDom.addEventListener("mouseleave", (e) => {
      const relatedTarget = e.relatedTarget;
      if (!this._hoverDom?.contains(relatedTarget)) {
        this._hideTooltip();
      }
    });
    this.emitter.on("renderHoverNode", (e) => {
      this.render(e.el);
    });
  }
  _clearHoverTimer() {
    if (this._hoverTimer) {
      window.clearTimeout(this._hoverTimer);
      this._hoverTimer = null;
    }
  }
  _hideTooltip() {
    setStyles(this._tooltipDom, {
      visibility: "hidden"
    });
    this._tooltipDom.innerHTML = "";
    this._hoverDom = null;
  }
  _createTooltipDom() {
    const div = elt("div", "hover-container");
    setStyles(div, {
      visibility: "hidden",
      position: "absolute",
      zIndex: "1000"
    });
    return div;
  }
  render(el) {
    if (!this._hoverDom) return;
    this._tooltipDom.innerHTML = "";
    this._tooltipDom.appendChild(el);
    const hoverRect = this._hoverDom.getBoundingClientRect();
    const editorRect = this._view.contentDom.getBoundingClientRect();
    const tooltipRect = this._tooltipDom.getBoundingClientRect();
    let left = hoverRect.left - editorRect.left + (hoverRect.width + tooltipRect.width) / 2;
    left = Math.max(5, left);
    left = Math.min(left, editorRect.width - tooltipRect.width - 5);
    let top = hoverRect.top - editorRect.top - tooltipRect.height;
    if (hoverRect.top - tooltipRect.height - 5 < editorRect.top) {
      top = hoverRect.top - editorRect.top + hoverRect.height;
    }
    setStyles(this._tooltipDom, {
      visibility: "visible",
      top: `${top}px`,
      left: `${left}px`
    });
  }
};

// src/view/error/errorWidget.ts
var ErrorWidget = class {
  constructor(view) {
    this.emitter = getEmitter();
    this._problems = [];
    this._view = view;
    this._attachEventListeners();
  }
  _attachEventListeners() {
    this.emitter.on("problemsChanged", (result) => {
      this._problems = result.problems;
      this.renderErrorLine();
    });
  }
  renderErrorLine() {
    if (this._problems.length === 0) return;
    this._problems.forEach((problem) => {
      const { start, end } = problem.range;
      const errMessage = problem.message;
      this.findDomByPos(start, end, errMessage);
    });
  }
  findDomByPos(start, end, errMessage) {
    const line = this._view.getLineElement(start.lineNumber);
    if (!line) return;
    let offset = 1;
    for (let i = 0; i < line.children.length; i++) {
      const child = line.children[i];
      offset += child.textContent?.length || 0;
      if (offset > start.column && offset <= end.column) {
        const className = "semi-json-viewer-error";
        child.classList.add(className);
      }
    }
  }
};

// src/view/viewDOMBuilder.ts
var ViewDOMBuilder = class {
  constructor(lineHeight, totalLines, options) {
    this._lineHeight = lineHeight;
    this._totalLines = totalLines;
    this._options = options;
  }
  createRenderContainer() {
    const renderContainer = elt("div", "json-viewer-container");
    setStyles(renderContainer, {
      position: "relative",
      height: "100%",
      width: "100%",
      overflow: "auto"
    });
    return renderContainer;
  }
  createLineNumberContainer() {
    const lineNumberClass = "semi-json-viewer-line-number-container";
    const lineNumberContainer = elt("div", lineNumberClass);
    setStyles(lineNumberContainer, {
      position: "absolute",
      left: "0",
      top: "0",
      width: "50px"
    });
    return lineNumberContainer;
  }
  createContentContainer() {
    const contentClass = "semi-json-viewer-content-container";
    const contentContainer = elt("div", contentClass);
    setStyles(contentContainer, {
      position: "absolute",
      left: "50px",
      top: "0",
      right: "0",
      overflowX: "auto",
      overflowY: "scroll",
      outline: "none"
    });
    if (!this._options?.readOnly) {
      contentContainer.contentEditable = "true";
      contentContainer.style.caretColor = "black";
      contentContainer.spellcheck = false;
    }
    return contentContainer;
  }
  createScrollElement() {
    const scrollEl = elt("div", "lines-content");
    setStyles(scrollEl, {
      position: "relative",
      overflow: "hidden",
      top: "0",
      left: "0",
      tabSize: (this._options?.formatOptions?.tabSize || 4).toString(),
      height: `${this._lineHeight * this._totalLines}px`
    });
    if (this._options?.autoWrap) {
      scrollEl.style.width = "100%";
    }
    return scrollEl;
  }
  createLineScrollContainer() {
    const lineScrollContainer = elt("div", "line-scroll-container");
    setStyles(lineScrollContainer, {
      position: "absolute",
      top: "0",
      left: "0",
      height: `${this._lineHeight * this._totalLines}px`,
      width: "100%",
      overflow: "hidden"
    });
    return lineScrollContainer;
  }
};

// src/view/view.ts
var View = class {
  constructor(container, model, options) {
    this._root = null;
    this._customRenderMap = /* @__PURE__ */ new Map();
    this.startLineNumber = 1;
    this.visibleLineCount = 0;
    this._verticalOffsetAdjustment = 0;
    this._jsonWorkerManager = getJsonWorkerManager();
    this._measuredHeights = {};
    this.emitter = getEmitter();
    this._container = container;
    this._jsonModel = model;
    this._selectionModel = new SelectionModel(1, 0, this, model);
    this._foldingModel = new FoldingModel(model);
    this._lineHeight = options?.lineHeight || 20;
    this._options = options;
    this._customRenderRule = options?.customRenderRule || null;
    this._domBuilder = new ViewDOMBuilder(this._lineHeight, model.getLineCount(), options);
    this._jsonViewerDom = this._domBuilder.createRenderContainer();
    this._lineNumberDom = this._domBuilder.createLineNumberContainer();
    this._contentDom = this._domBuilder.createContentContainer();
    this._scrollDom = this._domBuilder.createScrollElement();
    this._lineScrollDom = this._domBuilder.createLineScrollContainer();
    this._contentDom.appendChild(this._scrollDom);
    this._lineNumberDom.appendChild(this._lineScrollDom);
    this._jsonViewerDom.appendChild(this._lineNumberDom);
    this._jsonViewerDom.appendChild(this._contentDom);
    this._container.appendChild(this._jsonViewerDom);
    this._searchWidget = new SearchWidget(this, this._jsonModel);
    this._foldWidget = new FoldWidget(this, this._foldingModel);
    this._editWidget = new EditWidget(this, this._jsonModel, this._selectionModel);
    this._completeWidget = new CompleteWidget(this, this._jsonModel, this._selectionModel);
    this._hoverWidget = new HoverWidget(this);
    this._errorWidget = new ErrorWidget(this);
    this._tokenizationJsonModelPart = new TokenizationJsonModelPart(this._jsonModel);
    this._scalingCellSizeAndPositionManager = new ScalingCellSizeAndPositionManager({
      cellCount: this._jsonModel.getLineCount(),
      cellSizeGetter: ({ index }) => this.getCellSize(index),
      estimatedCellSize: this._lineHeight
    });
    this._attachEventListeners();
  }
  get tokenizationJsonModelPart() {
    return this._tokenizationJsonModelPart;
  }
  get contentDom() {
    return this._contentDom;
  }
  get jsonViewerDom() {
    return this._jsonViewerDom;
  }
  get scrollDom() {
    return this._scrollDom;
  }
  get lineScrollDom() {
    return this._lineScrollDom;
  }
  get options() {
    return this._options;
  }
  get completeWidget() {
    return this._completeWidget;
  }
  get editWidget() {
    return this._editWidget;
  }
  get scalingCellSizeAndPositionManager() {
    return this._scalingCellSizeAndPositionManager;
  }
  get searchWidget() {
    return this._searchWidget;
  }
  dispose() {
    this._container.removeChild(this._jsonViewerDom);
  }
  _attachEventListeners() {
    if (this._options?.readOnly && this._options.customRenderRule) {
      const { root } = parseJson(this._jsonModel);
      this._root = root;
    }
    this._jsonViewerDom.addEventListener("scroll", (e) => {
      this.onScroll(this._jsonViewerDom.scrollTop);
    });
    if (this._options?.readOnly) return;
    this._jsonViewerDom.addEventListener("click", (e) => {
      e.preventDefault();
      this._selectionModel.toLastPosition();
    });
    this._contentDom.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this._completeWidget.hide();
      this._selectionModel.isSelectedAll = false;
      this._selectionModel.updateFromSelection();
    });
    this.emitter.on("contentChanged", () => {
      this.resetScalingManagerConfigAndCell(0);
      if (this._jsonModel.lastChangeBufferPos.lineNumber >= this.visibleLineCount + this.startLineNumber) {
        this.scrollToLine(this._jsonModel.lastChangeBufferPos.lineNumber - this.visibleLineCount + 1);
        return;
      }
      this.layout();
    });
    this.emitter.on("forceRender", () => {
      this.resetScalingManagerConfigAndCell(0);
      this.layout();
      this._errorWidget.renderErrorLine();
    });
  }
  getLineElement(lineNumber) {
    return this.scrollDom.querySelector(`[data-line-number="${lineNumber}"]`);
  }
  updateVisibleRange(start, end) {
    this.startLineNumber = start;
    this.visibleLineCount = end - start + 1;
  }
  onScroll(scrollTop) {
    this._jsonViewerDom.scrollTop = scrollTop;
    this.layout();
    this._errorWidget.renderErrorLine();
  }
  scrollToLine(lineNumber) {
    const scrollTop = (lineNumber - 1) * this._lineHeight;
    this._contentDom.scrollTop = scrollTop;
    this.onScroll(scrollTop);
  }
  createLineNumberElement(actualLineNumber, visibleLineNumber) {
    const lineNumberClass = "semi-json-viewer-line-number";
    const lineNumberElement = elt("div", lineNumberClass);
    const rowDatum = this._scalingCellSizeAndPositionManager.getSizeAndPositionOfCell(visibleLineNumber);
    setStyles(lineNumberElement, {
      position: "absolute",
      width: "50px",
      height: `${this._lineHeight}px`,
      lineHeight: `${this._lineHeight}px`,
      top: `${rowDatum.offset + this._verticalOffsetAdjustment}px`
    });
    const lineNumber = elt("span", "line-number-text", {
      position: "absolute",
      left: "0",
      top: "0",
      textAlign: "right",
      width: "60%",
      height: "100%"
    });
    lineNumber.innerHTML = actualLineNumber.toString();
    lineNumberElement.appendChild(lineNumber);
    lineNumberElement.dataset.lineNumber = actualLineNumber.toString();
    return lineNumberElement;
  }
  createLineContentElement(actualLineNumber, visibleLineNumber) {
    const lineElementClass = "semi-json-viewer-view-line";
    const lineElement = elt("div", lineElementClass);
    lineElement.setAttribute("data-line-element", "true");
    const rowDatum = this._scalingCellSizeAndPositionManager.getSizeAndPositionOfCell(visibleLineNumber);
    setStyles(lineElement, {
      lineHeight: `${this._lineHeight}px`,
      width: "100%",
      position: "absolute",
      top: `${rowDatum.offset + this._verticalOffsetAdjustment}px`
    });
    if (!this._options?.autoWrap) {
      lineElement.style.height = `${this._lineHeight}px`;
    }
    lineElement.dataset.lineNumber = actualLineNumber.toString();
    lineElement.lineNumber = actualLineNumber;
    return lineElement;
  }
  getCellSize(index) {
    if (this._options?.autoWrap) {
      return this._measuredHeights[index] || this._lineHeight;
    }
    return this._lineHeight;
  }
  _measureAndUpdateItemHeight(item, index) {
    const height = item.offsetHeight;
    const width = item.children[0].getBoundingClientRect().width * 2;
    if (!this._options?.autoWrap && width > this._scrollDom.offsetWidth) {
      this._scrollDom.style.width = `${width}px`;
    }
    if (height === 0) {
      item.style.height = `${this._lineHeight}px`;
      return;
    }
    if (height !== this._measuredHeights[index]) {
      this._measuredHeights[index] = height;
      this._scalingCellSizeAndPositionManager.resetCell(index);
      this._scrollDom.style.height = `${this._scalingCellSizeAndPositionManager.getTotalSize()}px`;
    }
  }
  clearContainers() {
    this._lineScrollDom.innerHTML = "";
    this._scrollDom.innerHTML = "";
  }
  resetScalingManagerConfigAndCell(index) {
    this._scalingCellSizeAndPositionManager.configure({
      cellCount: this._jsonModel.getLineCount(),
      cellSizeGetter: ({ index: index2 }) => this.getCellSize(index2),
      estimatedCellSize: this._lineHeight
    });
    this._scalingCellSizeAndPositionManager.resetCell(index);
  }
  layout() {
    this.clearContainers();
    this._customRenderMap.clear();
    const visibleLineCount = this._foldingModel.getVisibleLineCount();
    this._scalingCellSizeAndPositionManager.configure({
      cellCount: visibleLineCount,
      cellSizeGetter: ({ index }) => this.getCellSize(index),
      estimatedCellSize: this._lineHeight
    });
    const visibleRange = this._scalingCellSizeAndPositionManager.getVisibleCellRange({
      containerSize: this._container.clientHeight,
      offset: this._jsonViewerDom.scrollTop
    });
    const verticalOffsetAdjustment = this._scalingCellSizeAndPositionManager.getOffsetAdjustment({
      containerSize: this._container.clientHeight,
      offset: this._jsonViewerDom.scrollTop
    });
    this._verticalOffsetAdjustment = verticalOffsetAdjustment;
    this.renderVisibleLines(visibleRange.start, visibleRange.stop);
    this.updateVisibleRange(visibleRange.start + 1, visibleRange.stop + 1);
    if (!this._options?.readOnly) {
      this._selectionModel.toViewPosition();
      this._completeWidget.show();
    }
    const totalSize = this._scalingCellSizeAndPositionManager.getTotalSize();
    this._scrollDom.style.height = `${totalSize}px`;
    this._lineScrollDom.style.height = `${totalSize}px`;
    if (this._options?.readOnly && this._customRenderMap.size > 0) {
      this._customRenderMap.forEach((value, key) => {
        key.innerHTML = "";
      });
      this.emitter.emit("customRender", {
        customRenderMap: this._customRenderMap
      });
    }
  }
  renderVisibleLines(startVisibleLine, endVisibleLine) {
    this._tokenizationJsonModelPart.forceTokenize(endVisibleLine + 1);
    let actualLineNumber = this._foldingModel.getActualLineNumber(startVisibleLine + 1);
    let visibleLineNumber = startVisibleLine;
    while (visibleLineNumber <= endVisibleLine && actualLineNumber <= this._jsonModel.getLineCount()) {
      if (!this._foldingModel.isLineCollapsed(actualLineNumber)) {
        this.renderLine(actualLineNumber, visibleLineNumber);
        visibleLineNumber++;
      }
      actualLineNumber = this._foldingModel.getNextVisibleLine(actualLineNumber);
    }
  }
  renderLine(actualLineNumber, visibleLineNumber) {
    const line = this._jsonModel.getLineContent(actualLineNumber);
    const tokens = this._tokenizationJsonModelPart.getLineTokens(actualLineNumber);
    const lineNumberElement = this.renderLineNumber(actualLineNumber, visibleLineNumber);
    const lineElement = this.renderLineContent(actualLineNumber, visibleLineNumber, tokens, line);
  }
  renderLineNumber(actualLineNumber, visibleLineNumber) {
    const lineNumberElement = this.createLineNumberElement(actualLineNumber, visibleLineNumber);
    this._lineScrollDom.appendChild(lineNumberElement);
    return lineNumberElement;
  }
  renderLineContent(actualLineNumber, visibleLineNumber, tokens, line) {
    const lineElement = this.createLineContentElement(actualLineNumber, visibleLineNumber);
    const contentContainer = this.renderTokensWithHighlight(tokens, line, actualLineNumber);
    lineElement.appendChild(contentContainer);
    this._scrollDom.appendChild(lineElement);
    this._measureAndUpdateItemHeight(lineElement, visibleLineNumber);
    return lineElement;
  }
  renderTokensWithHighlight(tokens, text, lineNumber) {
    const container = document.createElement("span");
    let currentOffset = 0;
    const searchResults = this._searchWidget.binarySearchByLine(lineNumber);
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      const start = token.startIndex;
      const end = i + 1 < tokens.length ? tokens[i + 1].startIndex : text.length;
      let content = text.substring(start, end);
      if (searchResults && searchResults.length > 0) {
        const highlightedSpan = this.createHighlightedContent(content, currentOffset, searchResults, token.scopes);
        container.appendChild(highlightedSpan);
      } else {
        if (this._options?.readOnly && this._tryApplyCustomRender(token.scopes, content)) {
          const offset = this._jsonModel.getOffsetAt(lineNumber, (start + end) / 2);
          const node = this._root?.getNodeFromOffset(offset);
          const path = getNodePath2(node);
          const pathChain = getPathChain(path);
          const customElement = this._renderCustomToken(content, this._customRenderRule, token, pathChain);
          if (customElement instanceof HTMLElement) {
            container.appendChild(customElement);
            continue;
          } else if (customElement !== null) {
            const span2 = document.createElement("span");
            span2.className = token.scopes;
            span2.textContent = content;
            container.appendChild(span2);
            this._customRenderMap.set(span2, customElement);
            continue;
          }
        }
        const span = document.createElement("span");
        span.className = token.scopes;
        span.textContent = content;
        if (!this._options?.autoWrap) {
          span.style.whiteSpace = "pre";
        }
        container.appendChild(span);
      }
      currentOffset += content.length;
    }
    return container;
  }
  createHighlightedContent(content, offset, searchResults, tokenClass) {
    const container = document.createElement("span");
    let lastIndex = 0;
    for (const match of searchResults) {
      const startIndex = Math.max(0, match.range.startColumn - 1 - offset);
      const endIndex = Math.min(content.length, match.range.endColumn - 1 - offset);
      if (startIndex >= content.length || endIndex <= 0) continue;
      if (startIndex > lastIndex) {
        const normalSpan = document.createElement("span");
        normalSpan.className = tokenClass;
        normalSpan.textContent = content.substring(lastIndex, startIndex);
        container.appendChild(normalSpan);
      }
      const highlightSpan = document.createElement("span");
      highlightSpan.textContent = content.substring(startIndex, endIndex);
      const currentMatch = this._searchWidget.searchResults?.[this._searchWidget._currentResultIndex];
      const isCurrentMatch = match.range.startLineNumber === currentMatch?.range.startLineNumber && match.range.endLineNumber === currentMatch?.range.endLineNumber && match.range.startColumn === currentMatch?.range.startColumn && match.range.endColumn === currentMatch?.range.endColumn;
      highlightSpan.className = `${tokenClass} semi-json-viewer-search-result${isCurrentMatch ? " semi-json-viewer-current-search-result" : ""}`;
      highlightSpan.dataset.startColumn = match.range.startColumn.toString();
      highlightSpan.dataset.endColumn = match.range.endColumn.toString();
      container.appendChild(highlightSpan);
      lastIndex = endIndex;
    }
    if (lastIndex < content.length) {
      const remainingSpan = document.createElement("span");
      remainingSpan.className = tokenClass;
      remainingSpan.textContent = content.substring(lastIndex);
      container.appendChild(remainingSpan);
    }
    return container;
  }
  _tryApplyCustomRender(tokenClass, content) {
    if (!this._customRenderRule || this._customRenderRule.length <= 0) return false;
    if (tokenClass === TOKEN_VALUE_BOOLEAN || tokenClass === TOKEN_VALUE_NULL || tokenClass === TOKEN_VALUE_STRING || tokenClass === TOKEN_VALUE_NUMBER || tokenClass === TOKEN_PROPERTY_NAME) {
      return true;
    }
    return false;
  }
  isMatch(content, pathChain, rule) {
    const match = rule.match;
    if (typeof match === "function") {
      return match(content, pathChain);
    } else if (typeof match === "string") {
      return match === content;
    } else if (match instanceof RegExp) {
      return match.test(content);
    }
    return false;
  }
  _renderCustomToken(content, rule, token, pathChain) {
    const realContent = content.replace(/^"|"$/g, "");
    for (const item of rule) {
      if (this.isMatch(realContent, pathChain, item)) {
        const element = item.render(content);
        return element;
      }
    }
    return null;
  }
};

// src/common/model.ts
var FindMatch = class {
  /**
   * @internal
   */
  constructor(range, matches) {
    this._findMatchBrand = void 0;
    this.range = range;
    this.matches = matches;
  }
};
var SearchData = class {
  constructor(regex, wordSeparators, simpleSearch) {
    this.regex = regex;
    this.wordSeparators = wordSeparators;
    this.simpleSearch = simpleSearch;
  }
};

// src/pieceTreeTextBuffer/rbTreeBase.ts
var TreeNode = class {
  // line feeds cnt in the left subtree (not in order)
  constructor(piece, color) {
    this.piece = piece;
    this.color = color;
    this.size_left = 0;
    this.lf_left = 0;
    this.parent = this;
    this.left = this;
    this.right = this;
  }
  next() {
    if (this.right !== SENTINEL) {
      return leftest(this.right);
    }
    let node = this;
    while (node.parent !== SENTINEL) {
      if (node.parent.left === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL) {
      return SENTINEL;
    } else {
      return node.parent;
    }
  }
  prev() {
    if (this.left !== SENTINEL) {
      return righttest(this.left);
    }
    let node = this;
    while (node.parent !== SENTINEL) {
      if (node.parent.right === node) {
        break;
      }
      node = node.parent;
    }
    if (node.parent === SENTINEL) {
      return SENTINEL;
    } else {
      return node.parent;
    }
  }
  detach() {
    this.parent = null;
    this.left = null;
    this.right = null;
  }
};
var SENTINEL = new TreeNode(null, 0 /* Black */);
SENTINEL.parent = SENTINEL;
SENTINEL.left = SENTINEL;
SENTINEL.right = SENTINEL;
SENTINEL.color = 0 /* Black */;
function leftest(node) {
  while (node.left !== SENTINEL) {
    node = node.left;
  }
  return node;
}
function righttest(node) {
  while (node.right !== SENTINEL) {
    node = node.right;
  }
  return node;
}
function calculateSize(node) {
  if (node === SENTINEL) {
    return 0;
  }
  return node.size_left + node.piece.length + calculateSize(node.right);
}
function calculateLF(node) {
  if (node === SENTINEL) {
    return 0;
  }
  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
}
function resetSentinel() {
  SENTINEL.parent = SENTINEL;
}
function leftRotate(tree, x) {
  const y = x.right;
  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  x.right = y.left;
  if (y.left !== SENTINEL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === SENTINEL) {
    tree.root = y;
  } else if (x.parent.left === x) {
    x.parent.left = y;
  } else {
    x.parent.right = y;
  }
  y.left = x;
  x.parent = y;
}
function rightRotate(tree, y) {
  const x = y.left;
  y.left = x.right;
  if (x.right !== SENTINEL) {
    x.right.parent = y;
  }
  x.parent = y.parent;
  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
  if (y.parent === SENTINEL) {
    tree.root = x;
  } else if (y === y.parent.right) {
    y.parent.right = x;
  } else {
    y.parent.left = x;
  }
  x.right = y;
  y.parent = x;
}
function rbDelete(tree, z) {
  let x;
  let y;
  if (z.left === SENTINEL) {
    y = z;
    x = y.right;
  } else if (z.right === SENTINEL) {
    y = z;
    x = y.left;
  } else {
    y = leftest(z.right);
    x = y.right;
  }
  if (y === tree.root) {
    tree.root = x;
    x.color = 0 /* Black */;
    z.detach();
    resetSentinel();
    tree.root.parent = SENTINEL;
    return;
  }
  const yWasRed = y.color === 1 /* Red */;
  if (y === y.parent.left) {
    y.parent.left = x;
  } else {
    y.parent.right = x;
  }
  if (y === z) {
    x.parent = y.parent;
    recomputeTreeMetadata(tree, x);
  } else {
    if (y.parent === z) {
      x.parent = y;
    } else {
      x.parent = y.parent;
    }
    recomputeTreeMetadata(tree, x);
    y.left = z.left;
    y.right = z.right;
    y.parent = z.parent;
    y.color = z.color;
    if (z === tree.root) {
      tree.root = y;
    } else {
      if (z === z.parent.left) {
        z.parent.left = y;
      } else {
        z.parent.right = y;
      }
    }
    if (y.left !== SENTINEL) {
      y.left.parent = y;
    }
    if (y.right !== SENTINEL) {
      y.right.parent = y;
    }
    y.size_left = z.size_left;
    y.lf_left = z.lf_left;
    recomputeTreeMetadata(tree, y);
  }
  z.detach();
  if (x.parent.left === x) {
    const newSizeLeft = calculateSize(x);
    const newLFLeft = calculateLF(x);
    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
      const delta = newSizeLeft - x.parent.size_left;
      const lf_delta = newLFLeft - x.parent.lf_left;
      x.parent.size_left = newSizeLeft;
      x.parent.lf_left = newLFLeft;
      updateTreeMetadata(tree, x.parent, delta, lf_delta);
    }
  }
  recomputeTreeMetadata(tree, x.parent);
  if (yWasRed) {
    resetSentinel();
    return;
  }
  let w;
  while (x !== tree.root && x.color === 0 /* Black */) {
    if (x === x.parent.left) {
      w = x.parent.right;
      if (w.color === 1 /* Red */) {
        w.color = 0 /* Black */;
        x.parent.color = 1 /* Red */;
        leftRotate(tree, x.parent);
        w = x.parent.right;
      }
      if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {
        w.color = 1 /* Red */;
        x = x.parent;
      } else {
        if (w.right.color === 0 /* Black */) {
          w.left.color = 0 /* Black */;
          w.color = 1 /* Red */;
          rightRotate(tree, w);
          w = x.parent.right;
        }
        w.color = x.parent.color;
        x.parent.color = 0 /* Black */;
        w.right.color = 0 /* Black */;
        leftRotate(tree, x.parent);
        x = tree.root;
      }
    } else {
      w = x.parent.left;
      if (w.color === 1 /* Red */) {
        w.color = 0 /* Black */;
        x.parent.color = 1 /* Red */;
        rightRotate(tree, x.parent);
        w = x.parent.left;
      }
      if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {
        w.color = 1 /* Red */;
        x = x.parent;
      } else {
        if (w.left.color === 0 /* Black */) {
          w.right.color = 0 /* Black */;
          w.color = 1 /* Red */;
          leftRotate(tree, w);
          w = x.parent.left;
        }
        w.color = x.parent.color;
        x.parent.color = 0 /* Black */;
        w.left.color = 0 /* Black */;
        rightRotate(tree, x.parent);
        x = tree.root;
      }
    }
  }
  x.color = 0 /* Black */;
  resetSentinel();
}
function fixInsert(tree, x) {
  recomputeTreeMetadata(tree, x);
  while (x !== tree.root && x.parent.color === 1 /* Red */) {
    if (x.parent === x.parent.parent.left) {
      const y = x.parent.parent.right;
      if (y.color === 1 /* Red */) {
        x.parent.color = 0 /* Black */;
        y.color = 0 /* Black */;
        x.parent.parent.color = 1 /* Red */;
        x = x.parent.parent;
      } else {
        if (x === x.parent.right) {
          x = x.parent;
          leftRotate(tree, x);
        }
        x.parent.color = 0 /* Black */;
        x.parent.parent.color = 1 /* Red */;
        rightRotate(tree, x.parent.parent);
      }
    } else {
      const y = x.parent.parent.left;
      if (y.color === 1 /* Red */) {
        x.parent.color = 0 /* Black */;
        y.color = 0 /* Black */;
        x.parent.parent.color = 1 /* Red */;
        x = x.parent.parent;
      } else {
        if (x === x.parent.left) {
          x = x.parent;
          rightRotate(tree, x);
        }
        x.parent.color = 0 /* Black */;
        x.parent.parent.color = 1 /* Red */;
        leftRotate(tree, x.parent.parent);
      }
    }
  }
  tree.root.color = 0 /* Black */;
}
function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {
  while (x !== tree.root && x !== SENTINEL) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lineFeedCntDelta;
    }
    x = x.parent;
  }
}
function recomputeTreeMetadata(tree, x) {
  let delta = 0;
  let lf_delta = 0;
  if (x === tree.root) {
    return;
  }
  while (x !== tree.root && x === x.parent.right) {
    x = x.parent;
  }
  if (x === tree.root) {
    return;
  }
  x = x.parent;
  delta = calculateSize(x.left) - x.size_left;
  lf_delta = calculateLF(x.left) - x.lf_left;
  x.size_left += delta;
  x.lf_left += lf_delta;
  while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
    if (x.parent.left === x) {
      x.parent.size_left += delta;
      x.parent.lf_left += lf_delta;
    }
    x = x.parent;
  }
}

// src/common/map.ts
var _a;
var LinkedMap = class {
  constructor() {
    this[_a] = "LinkedMap";
    this._map = /* @__PURE__ */ new Map();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state = 0;
  }
  clear() {
    this._map.clear();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    return this._head?.value;
  }
  get last() {
    return this._tail?.value;
  }
  has(key) {
    return this._map.has(key);
  }
  get(key, touch = 0 /* None */) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    if (touch !== 0 /* None */) {
      this.touch(item, touch);
    }
    return item.value;
  }
  set(key, value, touch = 0 /* None */) {
    let item = this._map.get(key);
    if (item) {
      item.value = value;
      if (touch !== 0 /* None */) {
        this.touch(item, touch);
      }
    } else {
      item = { key, value, next: void 0, previous: void 0 };
      switch (touch) {
        case 0 /* None */:
          this.addItemLast(item);
          break;
        case 1 /* AsOld */:
          this.addItemFirst(item);
          break;
        case 2 /* AsNew */:
          this.addItemLast(item);
          break;
        default:
          this.addItemLast(item);
          break;
      }
      this._map.set(key, item);
      this._size++;
    }
    return this;
  }
  delete(key) {
    return !!this.remove(key);
  }
  remove(key) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    this._map.delete(key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  shift() {
    if (!this._head && !this._tail) {
      return void 0;
    }
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    const item = this._head;
    this._map.delete(item.key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  forEach(callbackfn, thisArg) {
    const state = this._state;
    let current = this._head;
    while (current) {
      if (thisArg) {
        callbackfn.bind(thisArg)(current.value, current.key, this);
      } else {
        callbackfn(current.value, current.key, this);
      }
      if (this._state !== state) {
        throw new Error(`LinkedMap got modified during iteration.`);
      }
      current = current.next;
    }
  }
  keys() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: current.key, done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  values() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: current.value, done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  entries() {
    const map = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = {
            value: [current.key, current.value],
            done: false
          };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  [(_a = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(newSize) {
    if (newSize >= this.size) {
      return;
    }
    if (newSize === 0) {
      this.clear();
      return;
    }
    let current = this._head;
    let currentSize = this.size;
    while (current && currentSize > newSize) {
      this._map.delete(current.key);
      current = current.next;
      currentSize--;
    }
    this._head = current;
    this._size = currentSize;
    if (current) {
      current.previous = void 0;
    }
    this._state++;
  }
  trimNew(newSize) {
    if (newSize >= this.size) {
      return;
    }
    if (newSize === 0) {
      this.clear();
      return;
    }
    let current = this._tail;
    let currentSize = this.size;
    while (current && currentSize > newSize) {
      this._map.delete(current.key);
      current = current.previous;
      currentSize--;
    }
    this._tail = current;
    this._size = currentSize;
    if (current) {
      current.next = void 0;
    }
    this._state++;
  }
  addItemFirst(item) {
    if (!this._head && !this._tail) {
      this._tail = item;
    } else if (!this._head) {
      throw new Error("Invalid list");
    } else {
      item.next = this._head;
      this._head.previous = item;
    }
    this._head = item;
    this._state++;
  }
  addItemLast(item) {
    if (!this._head && !this._tail) {
      this._head = item;
    } else if (!this._tail) {
      throw new Error("Invalid list");
    } else {
      item.previous = this._tail;
      this._tail.next = item;
    }
    this._tail = item;
    this._state++;
  }
  removeItem(item) {
    if (item === this._head && item === this._tail) {
      this._head = void 0;
      this._tail = void 0;
    } else if (item === this._head) {
      if (!item.next) {
        throw new Error("Invalid list");
      }
      item.next.previous = void 0;
      this._head = item.next;
    } else if (item === this._tail) {
      if (!item.previous) {
        throw new Error("Invalid list");
      }
      item.previous.next = void 0;
      this._tail = item.previous;
    } else {
      const next = item.next;
      const previous = item.previous;
      if (!next || !previous) {
        throw new Error("Invalid list");
      }
      next.previous = previous;
      previous.next = next;
    }
    item.next = void 0;
    item.previous = void 0;
    this._state++;
  }
  touch(item, touch) {
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    if (touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */) {
      return;
    }
    if (touch === 1 /* AsOld */) {
      if (item === this._head) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._tail) {
        previous.next = void 0;
        this._tail = previous;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.previous = void 0;
      item.next = this._head;
      this._head.previous = item;
      this._head = item;
      this._state++;
    } else if (touch === 2 /* AsNew */) {
      if (item === this._tail) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._head) {
        next.previous = void 0;
        this._head = next;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = this._tail;
      this._tail.next = item;
      this._tail = item;
      this._state++;
    }
  }
  toJSON() {
    const data = [];
    this.forEach((value, key) => {
      data.push([key, value]);
    });
    return data;
  }
  fromJSON(data) {
    this.clear();
    for (const [key, value] of data) {
      this.set(key, value);
    }
  }
};
var Cache = class extends LinkedMap {
  constructor(limit, ratio = 1) {
    super();
    this._limit = limit;
    this._ratio = Math.min(Math.max(0, ratio), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(limit) {
    this._limit = limit;
    this.checkTrim();
  }
  get ratio() {
    return this._ratio;
  }
  set ratio(ratio) {
    this._ratio = Math.min(Math.max(0, ratio), 1);
    this.checkTrim();
  }
  get(key, touch = 2 /* AsNew */) {
    return super.get(key, touch);
  }
  peek(key) {
    return super.get(key, 0 /* None */);
  }
  set(key, value) {
    super.set(key, value, 2 /* AsNew */);
    return this;
  }
  checkTrim() {
    if (this.size > this._limit) {
      this.trim(Math.round(this._limit * this._ratio));
    }
  }
};
var LRUCache = class extends Cache {
  constructor(limit, ratio = 1) {
    super(limit, ratio);
  }
  trim(newSize) {
    this.trimOld(newSize);
  }
  set(key, value) {
    super.set(key, value);
    this.checkTrim();
    return this;
  }
};

// src/common/uint.ts
function toUint8(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 255 /* MAX_UINT_8 */) {
    return 255 /* MAX_UINT_8 */;
  }
  return v | 0;
}

// src/common/characterClassifier.ts
var CharacterClassifier = class _CharacterClassifier {
  constructor(_defaultValue) {
    const defaultValue = toUint8(_defaultValue);
    this._defaultValue = defaultValue;
    this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
    this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(defaultValue) {
    const asciiMap = new Uint8Array(256);
    asciiMap.fill(defaultValue);
    return asciiMap;
  }
  set(charCode, _value) {
    const value = toUint8(_value);
    if (charCode >= 0 && charCode < 256) {
      this._asciiMap[charCode] = value;
    } else {
      this._map.set(charCode, value);
    }
  }
  get(charCode) {
    if (charCode >= 0 && charCode < 256) {
      return this._asciiMap[charCode];
    } else {
      return this._map.get(charCode) || this._defaultValue;
    }
  }
  clear() {
    this._asciiMap.fill(this._defaultValue);
    this._map.clear();
  }
};

// src/common/wordCharacterClassifier.ts
var WordCharacterClassifier = class extends CharacterClassifier {
  constructor(wordSeparators, intlSegmenterLocales) {
    super(0 /* Regular */);
    this._segmenter = null;
    this._cachedLine = null;
    this._cachedSegments = [];
    this.intlSegmenterLocales = intlSegmenterLocales;
    if (this.intlSegmenterLocales.length > 0) {
      this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, {
        granularity: "word"
      });
    } else {
      this._segmenter = null;
    }
    for (let i = 0, len = wordSeparators.length; i < len; i++) {
      this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);
    }
    this.set(32 /* Space */, 1 /* Whitespace */);
    this.set(9 /* Tab */, 1 /* Whitespace */);
  }
  findPrevIntlWordBeforeOrAtOffset(line, offset) {
    let candidate = null;
    for (const segment of this._getIntlSegmenterWordsOnLine(line)) {
      if (segment.index > offset) {
        break;
      }
      candidate = segment;
    }
    return candidate;
  }
  findNextIntlWordAtOrAfterOffset(lineContent, offset) {
    for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {
      if (segment.index < offset) {
        continue;
      }
      return segment;
    }
    return null;
  }
  _getIntlSegmenterWordsOnLine(line) {
    if (!this._segmenter) {
      return [];
    }
    if (this._cachedLine === line) {
      return this._cachedSegments;
    }
    this._cachedLine = line;
    this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));
    return this._cachedSegments;
  }
  _filterWordSegments(segments) {
    const result = [];
    for (const segment of segments) {
      if (this._isWordLike(segment)) {
        result.push(segment);
      }
    }
    return result;
  }
  _isWordLike(segment) {
    if (segment.isWordLike) {
      return true;
    }
    return false;
  }
};
var wordClassifierCache = new LRUCache(10);
function getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {
  const key = `${wordSeparators}/${intlSegmenterLocales.join(",")}`;
  let result = wordClassifierCache.get(key);
  if (!result) {
    result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);
    wordClassifierCache.set(key, result);
  }
  return result;
}

// src/model/textModelSearch.ts
var LineFeedCounter = class {
  constructor(text) {
    const lineFeedsOffsets = [];
    let lineFeedsOffsetsLen = 0;
    for (let i = 0, textLen = text.length; i < textLen; i++) {
      if (text.charCodeAt(i) === 10 /* LineFeed */) {
        lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
      }
    }
    this._lineFeedsOffsets = lineFeedsOffsets;
  }
  findLineFeedCountBeforeOffset(offset) {
    const lineFeedsOffsets = this._lineFeedsOffsets;
    let min = 0;
    let max = lineFeedsOffsets.length - 1;
    if (max === -1) {
      return 0;
    }
    if (offset <= lineFeedsOffsets[0]) {
      return 0;
    }
    while (min < max) {
      const mid = min + ((max - min) / 2 >> 0);
      if (lineFeedsOffsets[mid] >= offset) {
        max = mid - 1;
      } else {
        if (lineFeedsOffsets[mid + 1] >= offset) {
          min = mid;
          max = mid;
        } else {
          min = mid + 1;
        }
      }
    }
    return min + 1;
  }
};
var TextModelSearch = class {
  static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) return [];
    if (searchData.regex.multiline) {
      return this._doFindMatchesMultiline(
        model,
        searchRange,
        new Searcher(searchData.wordSeparators, searchData.regex),
        captureMatches,
        limitResultCount
      );
    }
    return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
  }
  static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {
    const pos = searchRange.getStartPosition();
    const deltaOffset = model.getOffsetAt(pos.lineNumber, pos.column);
    const text = model.getValueInRange(searchRange, 1 /* LF */);
    const lfCounter = model.getEOL() === "\r\n" ? new LineFeedCounter(text) : null;
    const result = [];
    let counter = 0;
    let m;
    searcher.reset(0);
    while (m = searcher.next(text)) {
      result[counter++] = createFindMatch(
        this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),
        m,
        captureMatches
      );
      if (counter >= limitResultCount) {
        return result;
      }
    }
    return result;
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {
    let startOffset;
    let lineFeedCountBeforeMatch = 0;
    if (lfCounter) {
      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch;
    } else {
      startOffset = deltaOffset + matchIndex;
    }
    let endOffset;
    if (lfCounter) {
      const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
      const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
      endOffset = startOffset + match0.length + lineFeedCountInMatch;
    } else {
      endOffset = startOffset + match0.length;
    }
    const startPosition = model.positionAt(startOffset);
    const endPosition = model.positionAt(endOffset);
    return new Range2(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
  }
  static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {
    const res = [];
    let resLen = 0;
    if (searchRange.startLineNumber === searchRange.endLineNumber) {
      const text2 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
      resLen = this._findMatchesInLine(
        searchData,
        text2,
        searchRange.startLineNumber,
        searchRange.startColumn - 1,
        resLen,
        res,
        captureMatches,
        limitResultCount
      );
    }
    const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
    resLen = this._findMatchesInLine(
      searchData,
      text,
      searchRange.startLineNumber,
      searchRange.startColumn - 1,
      resLen,
      res,
      captureMatches,
      limitResultCount
    );
    for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resLen < limitResultCount; lineNumber++) {
      resLen = this._findMatchesInLine(
        searchData,
        model.getLineContent(lineNumber),
        lineNumber,
        0,
        resLen,
        res,
        captureMatches,
        limitResultCount
      );
    }
    if (resLen < limitResultCount) {
      const text2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
      resLen = this._findMatchesInLine(
        searchData,
        text2,
        searchRange.endLineNumber,
        0,
        resLen,
        res,
        captureMatches,
        limitResultCount
      );
    }
    return res;
  }
  static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(
            new Range2(
              lineNumber,
              lastMatchIndex + 1 + deltaOffset,
              lineNumber,
              lastMatchIndex + 1 + searchStringLen + deltaOffset
            ),
            null
          );
          if (resultLen >= limitResultCount) return resultLen;
        }
      }
    }
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(
          new Range2(
            lineNumber,
            m.index + 1 + deltaOffset,
            lineNumber,
            m.index + 1 + m[0].length + deltaOffset
          ),
          m,
          captureMatches
        );
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
};
var SearchParams = class {
  constructor(searchString, isRegex, matchCase, wordSeparators) {
    this.searchString = searchString;
    this.isRegex = isRegex;
    this.matchCase = matchCase;
    this.wordSeparators = wordSeparators;
  }
  parseSearchRequest() {
    if (this.searchString === "") {
      return null;
    }
    let multiline;
    if (this.isRegex) {
      multiline = isMultilineRegexSource(this.searchString);
    } else {
      multiline = this.searchString.indexOf("\n") >= 0;
    }
    let regex = null;
    try {
      regex = createRegExp(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: false,
        multiline,
        global: true,
        unicode: true
      });
    } catch (err) {
      return null;
    }
    if (!regex) {
      return null;
    }
    let canUseSimpleSearch = !this.isRegex && !multiline;
    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
      canUseSimpleSearch = this.matchCase;
    }
    return new SearchData(
      regex,
      this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null,
      canUseSimpleSearch ? this.searchString : null
    );
  }
};
function isMultilineRegexSource(searchString) {
  if (!searchString || searchString.length === 0) {
    return false;
  }
  for (let i = 0, len = searchString.length; i < len; i++) {
    const chCode = searchString.charCodeAt(i);
    if (chCode === 10 /* LineFeed */) {
      return true;
    }
    if (chCode === 92 /* Backslash */) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = searchString.charCodeAt(i);
      if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */) {
        return true;
      }
    }
  }
  return false;
}
function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex === 0) {
    return true;
  }
  const charBefore = text.charCodeAt(matchStartIndex - 1);
  if (wordSeparators.get(charBefore) !== 0 /* Regular */) {
    return true;
  }
  if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {
    return true;
  }
  if (matchLength > 0) {
    const firstCharInMatch = text.charCodeAt(matchStartIndex);
    if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {
      return true;
    }
  }
  return false;
}
function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex + matchLength === textLength) {
    return true;
  }
  const charAfter = text.charCodeAt(matchStartIndex + matchLength);
  if (wordSeparators.get(charAfter) !== 0 /* Regular */) {
    return true;
  }
  if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {
    return true;
  }
  if (matchLength > 0) {
    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
    if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {
      return true;
    }
  }
  return false;
}
function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
}
var Searcher = class {
  constructor(wordSeparators, searchRegex) {
    this._wordSeparators = wordSeparators;
    this._searchRegex = searchRegex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  reset(lastIndex) {
    this._searchRegex.lastIndex = lastIndex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  next(text) {
    const textLength = text.length;
    let m;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
        return null;
      }
      m = this._searchRegex.exec(text);
      if (!m) {
        return null;
      }
      const matchStartIndex = m.index;
      const matchLength = m[0].length;
      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
        if (matchLength === 0) {
          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
            this._searchRegex.lastIndex += 2;
          } else {
            this._searchRegex.lastIndex += 1;
          }
          continue;
        }
        return null;
      }
      this._prevMatchStartIndex = matchStartIndex;
      this._prevMatchLength = matchLength;
      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
        return m;
      }
    } while (m);
    return null;
  }
};
function createFindMatch(range, rawMatches, captureMatches) {
  if (!captureMatches) {
    return new FindMatch(range, null);
  }
  const matches = [];
  for (let i = 0, len = rawMatches.length; i < len; i++) {
    matches[i] = rawMatches[i];
  }
  return new FindMatch(range, matches);
}

// src/pieceTreeTextBuffer/pieceTreeBase.ts
var AverageBufferSize = 65535;
function createUintArray(arr) {
  let r;
  if (arr[arr.length - 1] < 65536) {
    r = new Uint16Array(arr.length);
  } else {
    r = new Uint32Array(arr.length);
  }
  r.set(arr, 0);
  return r;
}
var LineStarts = class {
  constructor(lineStarts, cr, lf, crlf, isBasicASCII) {
    this.lineStarts = lineStarts;
    this.cr = cr;
    this.lf = lf;
    this.crlf = crlf;
    this.isBasicASCII = isBasicASCII;
  }
};
function createLineStartsFast(str, readonly = true) {
  const r = [0];
  let rLength = 1;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13 /* CarriageReturn */) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {
        r[rLength++] = i + 2;
        i++;
      } else {
        r[rLength++] = i + 1;
      }
    } else if (chr === 10 /* LineFeed */) {
      r[rLength++] = i + 1;
    }
  }
  if (readonly) {
    return createUintArray(r);
  } else {
    return r;
  }
}
function createLineStarts(r, str) {
  r.length = 0;
  r[0] = 0;
  let rLength = 1;
  let cr = 0, lf = 0, crlf = 0;
  let isBasicASCII = true;
  for (let i = 0, len = str.length; i < len; i++) {
    const chr = str.charCodeAt(i);
    if (chr === 13 /* CarriageReturn */) {
      if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {
        crlf++;
        r[rLength++] = i + 2;
        i++;
      } else {
        cr++;
        r[rLength++] = i + 1;
      }
    } else if (chr === 10 /* LineFeed */) {
      lf++;
      r[rLength++] = i + 1;
    } else {
      if (isBasicASCII) {
        if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {
          isBasicASCII = false;
        }
      }
    }
  }
  const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);
  r.length = 0;
  return result;
}
var Piece = class {
  constructor(bufferIndex, start, end, lineFeedCnt, length) {
    this.bufferIndex = bufferIndex;
    this.start = start;
    this.end = end;
    this.lineFeedCnt = lineFeedCnt;
    this.length = length;
  }
};
var StringBuffer = class {
  constructor(buffer, lineStarts) {
    this.buffer = buffer;
    this.lineStarts = lineStarts;
  }
};
var PieceTreeSnapshot = class {
  constructor(tree, BOM) {
    this._pieces = [];
    this._tree = tree;
    this._BOM = BOM;
    this._index = 0;
    if (tree.root !== SENTINEL) {
      tree.iterate(tree.root, (node) => {
        if (node !== SENTINEL) {
          this._pieces.push(node.piece);
        }
        return true;
      });
    }
  }
  read() {
    if (this._pieces.length === 0) {
      if (this._index === 0) {
        this._index++;
        return this._BOM;
      } else {
        return null;
      }
    }
    if (this._index > this._pieces.length - 1) {
      return null;
    }
    if (this._index === 0) {
      return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);
    }
    return this._tree.getPieceContent(this._pieces[this._index++]);
  }
};
var PieceTreeSearchCache = class {
  constructor(limit) {
    this._limit = limit;
    this._cache = [];
  }
  get(offset) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const nodePos = this._cache[i];
      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
        return nodePos;
      }
    }
    return null;
  }
  get2(lineNumber) {
    for (let i = this._cache.length - 1; i >= 0; i--) {
      const nodePos = this._cache[i];
      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
        return nodePos;
      }
    }
    return null;
  }
  set(nodePosition) {
    if (this._cache.length >= this._limit) {
      this._cache.shift();
    }
    this._cache.push(nodePosition);
  }
  validate(offset) {
    let hasInvalidVal = false;
    const tmp = this._cache;
    for (let i = 0; i < tmp.length; i++) {
      const nodePos = tmp[i];
      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
        tmp[i] = null;
        hasInvalidVal = true;
        continue;
      }
    }
    if (hasInvalidVal) {
      const newArr = [];
      for (const entry of tmp) {
        if (entry !== null) {
          newArr.push(entry);
        }
      }
      this._cache = newArr;
    }
  }
};
var PieceTreeBase = class {
  constructor(chunks, eol, eolNormalized) {
    this.create(chunks, eol, eolNormalized);
  }
  create(chunks, eol, eolNormalized) {
    this._buffers = [new StringBuffer("", [0])];
    this._lastChangeBufferPos = { line: 0, column: 0 };
    this.root = SENTINEL;
    this._lineCnt = 1;
    this._length = 0;
    this._EOL = eol;
    this._EOLLength = eol.length;
    this._EOLNormalized = eolNormalized;
    let lastNode = null;
    for (let i = 0, len = chunks.length; i < len; i++) {
      if (chunks[i].buffer.length > 0) {
        if (!chunks[i].lineStarts) {
          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);
        }
        const piece = new Piece(
          i + 1,
          { line: 0, column: 0 },
          {
            line: chunks[i].lineStarts.length - 1,
            column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]
          },
          chunks[i].lineStarts.length - 1,
          chunks[i].buffer.length
        );
        this._buffers.push(chunks[i]);
        lastNode = this.rbInsertRight(lastNode, piece);
      }
    }
    this._searchCache = new PieceTreeSearchCache(1);
    this._lastVisitedLine = { lineNumber: 0, value: "" };
    this.computeBufferMetadata();
  }
  normalizeEOL(eol) {
    const averageBufferSize = AverageBufferSize;
    const min = averageBufferSize - Math.floor(averageBufferSize / 3);
    const max = min * 2;
    let tempChunk = "";
    let tempChunkLen = 0;
    const chunks = [];
    this.iterate(this.root, (node) => {
      const str = this.getNodeContent(node);
      const len = str.length;
      if (tempChunkLen <= min || tempChunkLen + len < max) {
        tempChunk += str;
        tempChunkLen += len;
        return true;
      }
      const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
      tempChunk = str;
      tempChunkLen = len;
      return true;
    });
    if (tempChunkLen > 0) {
      const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
      chunks.push(new StringBuffer(text, createLineStartsFast(text)));
    }
    this.create(chunks, eol, true);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(newEOL) {
    this._EOL = newEOL;
    this._EOLLength = this._EOL.length;
    this.normalizeEOL(newEOL);
  }
  createSnapshot(BOM) {
    return new PieceTreeSnapshot(this, BOM);
  }
  equal(other) {
    if (this.getLength() !== other.getLength()) {
      return false;
    }
    if (this.getLineCount() !== other.getLineCount()) {
      return false;
    }
    let offset = 0;
    const ret = this.iterate(this.root, (node) => {
      if (node === SENTINEL) {
        return true;
      }
      const str = this.getNodeContent(node);
      const len = str.length;
      const startPosition = other.nodeAt(offset);
      const endPosition = other.nodeAt(offset + len);
      const val = other.getValueInRange2(startPosition, endPosition);
      offset += len;
      return str === val;
    });
    return ret;
  }
  getOffsetAt(lineNumber, column) {
    let leftLen = 0;
    let x = this.root;
    while (x !== SENTINEL) {
      if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
        leftLen += x.size_left;
        const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        return leftLen += accumualtedValInCurrentIndex + column - 1;
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        leftLen += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return leftLen;
  }
  getPositionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    let x = this.root;
    let lfCnt = 0;
    const originalOffset = offset;
    while (x !== SENTINEL) {
      if (x.size_left !== 0 && x.size_left >= offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        const out = this.getIndexOf(x, offset - x.size_left);
        lfCnt += x.lf_left + out.index;
        if (out.index === 0) {
          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          const column = originalOffset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        }
        return new Position(lfCnt + 1, out.remainder + 1);
      } else {
        offset -= x.size_left + x.piece.length;
        lfCnt += x.lf_left + x.piece.lineFeedCnt;
        if (x.right === SENTINEL) {
          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
          const column = originalOffset - offset - lineStartOffset;
          return new Position(lfCnt + 1, column + 1);
        } else {
          x = x.right;
        }
      }
    }
    return new Position(1, 1);
  }
  getValueInRange(range, eol) {
    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
      return "";
    }
    const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);
    const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);
    const value = this.getValueInRange2(startPosition, endPosition);
    if (eol) {
      if (eol !== this._EOL || !this._EOLNormalized) {
        return value.replace(/\r\n|\r|\n/g, eol);
      }
      if (eol === this.getEOL() && this._EOLNormalized) {
        return value;
      }
      return value.replace(/\r\n|\r|\n/g, eol);
    }
    return value;
  }
  getValueInRange2(startPosition, endPosition) {
    if (startPosition.node === endPosition.node) {
      const node = startPosition.node;
      const buffer2 = this._buffers[node.piece.bufferIndex].buffer;
      const startOffset2 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
      return buffer2.substring(startOffset2 + startPosition.remainder, startOffset2 + endPosition.remainder);
    }
    let x = startPosition.node;
    const buffer = this._buffers[x.piece.bufferIndex].buffer;
    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
    let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
    x = x.next();
    while (x !== SENTINEL) {
      const buffer2 = this._buffers[x.piece.bufferIndex].buffer;
      const startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (x === endPosition.node) {
        ret += buffer2.substring(startOffset2, startOffset2 + endPosition.remainder);
        break;
      } else {
        ret += buffer2.substr(startOffset2, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  getLinesContent() {
    const lines = [];
    let linesLength = 0;
    let currentLine = "";
    let danglingCR = false;
    this.iterate(this.root, (node) => {
      if (node === SENTINEL) {
        return true;
      }
      const piece = node.piece;
      let pieceLength = piece.length;
      if (pieceLength === 0) {
        return true;
      }
      const buffer = this._buffers[piece.bufferIndex].buffer;
      const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
      const pieceStartLine = piece.start.line;
      const pieceEndLine = piece.end.line;
      let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
      if (danglingCR) {
        if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {
          pieceStartOffset++;
          pieceLength--;
        }
        lines[linesLength++] = currentLine;
        currentLine = "";
        danglingCR = false;
        if (pieceLength === 0) {
          return true;
        }
      }
      if (pieceStartLine === pieceEndLine) {
        if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {
          danglingCR = true;
          currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);
        } else {
          currentLine += buffer.substr(pieceStartOffset, pieceLength);
        }
        return true;
      }
      currentLine += this._EOLNormalized ? buffer.substring(
        pieceStartOffset,
        Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)
      ) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, "");
      lines[linesLength++] = currentLine;
      for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
        currentLine = this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, "");
        lines[linesLength++] = currentLine;
      }
      if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {
        danglingCR = true;
        if (piece.end.column === 0) {
          linesLength--;
        } else {
          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);
        }
      } else {
        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);
      }
      return true;
    });
    if (danglingCR) {
      lines[linesLength++] = currentLine;
      currentLine = "";
    }
    lines[linesLength++] = currentLine;
    return lines;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(lineNumber) {
    if (this._lastVisitedLine.lineNumber === lineNumber) {
      return this._lastVisitedLine.value;
    }
    this._lastVisitedLine.lineNumber = lineNumber;
    if (lineNumber === this._lineCnt) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);
    } else if (this._EOLNormalized) {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);
    } else {
      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, "");
    }
    return this._lastVisitedLine.value;
  }
  _getCharCode(nodePos) {
    if (nodePos.remainder === nodePos.node.piece.length) {
      const matchingNode = nodePos.node.next();
      if (!matchingNode) {
        return 0;
      }
      const buffer = this._buffers[matchingNode.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
      return buffer.buffer.charCodeAt(startOffset);
    } else {
      const buffer = this._buffers[nodePos.node.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
      const targetOffset = startOffset + nodePos.remainder;
      return buffer.buffer.charCodeAt(targetOffset);
    }
  }
  getLineCharCode(lineNumber, index) {
    const nodePos = this.nodeAt2(lineNumber, index + 1);
    return this._getCharCode(nodePos);
  }
  getLineLength(lineNumber) {
    if (lineNumber === this.getLineCount()) {
      const startOffset = this.getOffsetAt(lineNumber, 1);
      return this.getLength() - startOffset;
    }
    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;
  }
  getCharCode(offset) {
    const nodePos = this.nodeAt(offset);
    return this._getCharCode(nodePos);
  }
  getNearestChunk(offset) {
    const nodePos = this.nodeAt(offset);
    if (nodePos.remainder === nodePos.node.piece.length) {
      const matchingNode = nodePos.node.next();
      if (!matchingNode || matchingNode === SENTINEL) {
        return "";
      }
      const buffer = this._buffers[matchingNode.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);
      return buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);
    } else {
      const buffer = this._buffers[nodePos.node.piece.bufferIndex];
      const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
      const targetOffset = startOffset + nodePos.remainder;
      const targetEnd = startOffset + nodePos.node.piece.length;
      return buffer.buffer.substring(targetOffset, targetEnd);
    }
  }
  findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
    const buffer = this._buffers[node.piece.bufferIndex];
    const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);
    const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);
    const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);
    let m;
    const ret = { line: 0, column: 0 };
    let searchText;
    let offsetInBuffer;
    if (searcher._wordSeparators) {
      searchText = buffer.buffer.substring(start, end);
      offsetInBuffer = (offset) => offset + start;
      searcher.reset(0);
    } else {
      searchText = buffer.buffer;
      offsetInBuffer = (offset) => offset;
      searcher.reset(start);
    }
    do {
      m = searcher.next(searchText);
      if (m) {
        if (offsetInBuffer(m.index) >= end) {
          return resultLen;
        }
        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
        const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);
        const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
        const retEndColumn = retStartColumn + m[0].length;
        result[resultLen++] = createFindMatch(
          new Range2(
            startLineNumber + lineFeedCnt,
            retStartColumn,
            startLineNumber + lineFeedCnt,
            retEndColumn
          ),
          m,
          captureMatches
        );
        if (offsetInBuffer(m.index) + m[0].length >= end) {
          return resultLen;
        }
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    const result = [];
    let resultLen = 0;
    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
    let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);
    if (startPosition === null) {
      return [];
    }
    const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);
    if (endPosition === null) {
      return [];
    }
    let start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    const end = this.positionInBuffer(endPosition.node, endPosition.remainder);
    if (startPosition.node === endPosition.node) {
      this.findMatchesInNode(
        startPosition.node,
        searcher,
        searchRange.startLineNumber,
        searchRange.startColumn,
        start,
        end,
        searchData,
        captureMatches,
        limitResultCount,
        resultLen,
        result
      );
      return result;
    }
    let startLineNumber = searchRange.startLineNumber;
    let currentNode = startPosition.node;
    while (currentNode !== endPosition.node) {
      const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);
      if (lineBreakCnt >= 1) {
        const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;
        const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);
        const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
        const startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
        resultLen = this.findMatchesInNode(
          currentNode,
          searcher,
          startLineNumber,
          startColumn3,
          start,
          this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer),
          searchData,
          captureMatches,
          limitResultCount,
          resultLen,
          result
        );
        if (resultLen >= limitResultCount) {
          return result;
        }
        startLineNumber += lineBreakCnt;
      }
      const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      if (startLineNumber === searchRange.endLineNumber) {
        const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
        resultLen = this._findMatchesInLine(
          searchData,
          searcher,
          text,
          searchRange.endLineNumber,
          startColumn2,
          resultLen,
          result,
          captureMatches,
          limitResultCount
        );
        return result;
      }
      resultLen = this._findMatchesInLine(
        searchData,
        searcher,
        this.getLineContent(startLineNumber).substr(startColumn2),
        startLineNumber,
        startColumn2,
        resultLen,
        result,
        captureMatches,
        limitResultCount
      );
      if (resultLen >= limitResultCount) {
        return result;
      }
      startLineNumber++;
      startPosition = this.nodeAt2(startLineNumber, 1);
      currentNode = startPosition.node;
      start = this.positionInBuffer(startPosition.node, startPosition.remainder);
    }
    if (startLineNumber === searchRange.endLineNumber) {
      const startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
      const text = this.getLineContent(startLineNumber).substring(startColumn2, searchRange.endColumn - 1);
      resultLen = this._findMatchesInLine(
        searchData,
        searcher,
        text,
        searchRange.endLineNumber,
        startColumn2,
        resultLen,
        result,
        captureMatches,
        limitResultCount
      );
      return result;
    }
    const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
    resultLen = this.findMatchesInNode(
      endPosition.node,
      searcher,
      startLineNumber,
      startColumn,
      start,
      end,
      searchData,
      captureMatches,
      limitResultCount,
      resultLen,
      result
    );
    return result;
  }
  _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
    const wordSeparators = searchData.wordSeparators;
    if (!captureMatches && searchData.simpleSearch) {
      const searchString = searchData.simpleSearch;
      const searchStringLen = searchString.length;
      const textLength = text.length;
      let lastMatchIndex = -searchStringLen;
      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
          result[resultLen++] = new FindMatch(
            new Range2(
              lineNumber,
              lastMatchIndex + 1 + deltaOffset,
              lineNumber,
              lastMatchIndex + 1 + searchStringLen + deltaOffset
            ),
            null
          );
          if (resultLen >= limitResultCount) {
            return resultLen;
          }
        }
      }
      return resultLen;
    }
    let m;
    searcher.reset(0);
    do {
      m = searcher.next(text);
      if (m) {
        result[resultLen++] = createFindMatch(
          new Range2(
            lineNumber,
            m.index + 1 + deltaOffset,
            lineNumber,
            m.index + 1 + m[0].length + deltaOffset
          ),
          m,
          captureMatches
        );
        if (resultLen >= limitResultCount) {
          return resultLen;
        }
      }
    } while (m);
    return resultLen;
  }
  // #endregion
  // #region Piece Table
  insert(offset, value, eolNormalized = false) {
    this._EOLNormalized = this._EOLNormalized && eolNormalized;
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (this.root !== SENTINEL) {
      const { node, remainder, nodeStartOffset } = this.nodeAt(offset);
      const piece = node.piece;
      const bufferIndex = piece.bufferIndex;
      const insertPosInBuffer = this.positionInBuffer(node, remainder);
      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {
        this.appendToNode(node, value);
        this.computeBufferMetadata();
        return;
      }
      if (nodeStartOffset === offset) {
        this.insertContentToNodeLeft(value, node);
        this._searchCache.validate(offset);
      } else if (nodeStartOffset + node.piece.length > offset) {
        const nodesToDel = [];
        let newRightPiece = new Piece(
          piece.bufferIndex,
          insertPosInBuffer,
          piece.end,
          this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),
          this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)
        );
        if (this.shouldCheckCRLF() && this.endWithCR(value)) {
          const headOfRight = this.nodeCharCodeAt(node, remainder);
          if (headOfRight === 10) {
            const newStart = {
              line: newRightPiece.start.line + 1,
              column: 0
            };
            newRightPiece = new Piece(
              newRightPiece.bufferIndex,
              newStart,
              newRightPiece.end,
              this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),
              newRightPiece.length - 1
            );
            value += "\n";
          }
        }
        if (this.shouldCheckCRLF() && this.startWithLF(value)) {
          const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);
          if (tailOfLeft === 13) {
            const previousPos = this.positionInBuffer(node, remainder - 1);
            this.deleteNodeTail(node, previousPos);
            value = "\r" + value;
            if (node.piece.length === 0) {
              nodesToDel.push(node);
            }
          } else {
            this.deleteNodeTail(node, insertPosInBuffer);
          }
        } else {
          this.deleteNodeTail(node, insertPosInBuffer);
        }
        const newPieces = this.createNewPieces(value);
        if (newRightPiece.length > 0) {
          this.rbInsertRight(node, newRightPiece);
        }
        let tmpNode = node;
        for (let k = 0; k < newPieces.length; k++) {
          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
        }
        this.deleteNodes(nodesToDel);
      } else {
        this.insertContentToNodeRight(value, node);
      }
    } else {
      const pieces = this.createNewPieces(value);
      let node = this.rbInsertLeft(null, pieces[0]);
      for (let k = 1; k < pieces.length; k++) {
        node = this.rbInsertRight(node, pieces[k]);
      }
    }
    this.computeBufferMetadata();
  }
  delete(offset, cnt) {
    this._lastVisitedLine.lineNumber = 0;
    this._lastVisitedLine.value = "";
    if (cnt <= 0 || this.root === SENTINEL) {
      return;
    }
    const startPosition = this.nodeAt(offset);
    const endPosition = this.nodeAt(offset + cnt);
    const startNode = startPosition.node;
    const endNode = endPosition.node;
    if (startNode === endNode) {
      const startSplitPosInBuffer2 = this.positionInBuffer(startNode, startPosition.remainder);
      const endSplitPosInBuffer2 = this.positionInBuffer(startNode, endPosition.remainder);
      if (startPosition.nodeStartOffset === offset) {
        if (cnt === startNode.piece.length) {
          const next = startNode.next();
          rbDelete(this, startNode);
          this.validateCRLFWithPrevNode(next);
          this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(startNode, endSplitPosInBuffer2);
        this._searchCache.validate(offset);
        this.validateCRLFWithPrevNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
        this.deleteNodeTail(startNode, startSplitPosInBuffer2);
        this.validateCRLFWithNextNode(startNode);
        this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(startNode, startSplitPosInBuffer2, endSplitPosInBuffer2);
      this.computeBufferMetadata();
      return;
    }
    const nodesToDel = [];
    const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);
    this.deleteNodeTail(startNode, startSplitPosInBuffer);
    this._searchCache.validate(offset);
    if (startNode.piece.length === 0) {
      nodesToDel.push(startNode);
    }
    const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);
    this.deleteNodeHead(endNode, endSplitPosInBuffer);
    if (endNode.piece.length === 0) {
      nodesToDel.push(endNode);
    }
    const secondNode = startNode.next();
    for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {
      nodesToDel.push(node);
    }
    const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
    this.deleteNodes(nodesToDel);
    this.validateCRLFWithNextNode(prev);
    this.computeBufferMetadata();
  }
  insertContentToNodeLeft(value, node) {
    const nodesToDel = [];
    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {
      const piece = node.piece;
      const newStart = { line: piece.start.line + 1, column: 0 };
      const nPiece = new Piece(
        piece.bufferIndex,
        newStart,
        piece.end,
        this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),
        piece.length - 1
      );
      node.piece = nPiece;
      value += "\n";
      updateTreeMetadata(this, node, -1, -1);
      if (node.piece.length === 0) {
        nodesToDel.push(node);
      }
    }
    const newPieces = this.createNewPieces(value);
    let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);
    for (let k = newPieces.length - 2; k >= 0; k--) {
      newNode = this.rbInsertLeft(newNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
    this.deleteNodes(nodesToDel);
  }
  insertContentToNodeRight(value, node) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const newPieces = this.createNewPieces(value);
    const newNode = this.rbInsertRight(node, newPieces[0]);
    let tmpNode = newNode;
    for (let k = 1; k < newPieces.length; k++) {
      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);
    }
    this.validateCRLFWithPrevNode(newNode);
  }
  positionInBuffer(node, remainder, ret) {
    const piece = node.piece;
    const bufferIndex = node.piece.bufferIndex;
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    const startOffset = lineStarts[piece.start.line] + piece.start.column;
    const offset = startOffset + remainder;
    let low = piece.start.line;
    let high = piece.end.line;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStart = lineStarts[mid];
      if (mid === high) {
        break;
      }
      midStop = lineStarts[mid + 1];
      if (offset < midStart) {
        high = mid - 1;
      } else if (offset >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    if (ret) {
      ret.line = mid;
      ret.column = offset - midStart;
      return null;
    }
    return {
      line: mid,
      column: offset - midStart
    };
  }
  getLineFeedCnt(bufferIndex, start, end) {
    if (end.column === 0) {
      return end.line - start.line;
    }
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    if (end.line === lineStarts.length - 1) {
      return end.line - start.line;
    }
    const nextLineStartOffset = lineStarts[end.line + 1];
    const endOffset = lineStarts[end.line] + end.column;
    if (nextLineStartOffset > endOffset + 1) {
      return end.line - start.line;
    }
    const previousCharOffset = endOffset - 1;
    const buffer = this._buffers[bufferIndex].buffer;
    if (buffer.charCodeAt(previousCharOffset) === 13) {
      return end.line - start.line + 1;
    } else {
      return end.line - start.line;
    }
  }
  offsetInBuffer(bufferIndex, cursor) {
    const lineStarts = this._buffers[bufferIndex].lineStarts;
    return lineStarts[cursor.line] + cursor.column;
  }
  deleteNodes(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      rbDelete(this, nodes[i]);
    }
  }
  createNewPieces(text) {
    if (text.length > AverageBufferSize) {
      const newPieces = [];
      while (text.length > AverageBufferSize) {
        const lastChar = text.charCodeAt(AverageBufferSize - 1);
        let splitText;
        if (lastChar === 13 /* CarriageReturn */ || lastChar >= 55296 && lastChar <= 56319) {
          splitText = text.substring(0, AverageBufferSize - 1);
          text = text.substring(AverageBufferSize - 1);
        } else {
          splitText = text.substring(0, AverageBufferSize);
          text = text.substring(AverageBufferSize);
        }
        const lineStarts3 = createLineStartsFast(splitText);
        newPieces.push(
          new Piece(
            this._buffers.length,
            { line: 0, column: 0 },
            {
              line: lineStarts3.length - 1,
              column: splitText.length - lineStarts3[lineStarts3.length - 1]
            },
            lineStarts3.length - 1,
            splitText.length
          )
        );
        this._buffers.push(new StringBuffer(splitText, lineStarts3));
      }
      const lineStarts2 = createLineStartsFast(text);
      newPieces.push(
        new Piece(
          this._buffers.length,
          { line: 0, column: 0 },
          {
            line: lineStarts2.length - 1,
            column: text.length - lineStarts2[lineStarts2.length - 1]
          },
          lineStarts2.length - 1,
          text.length
        )
      );
      this._buffers.push(new StringBuffer(text, lineStarts2));
      return newPieces;
    }
    let startOffset = this._buffers[0].buffer.length;
    const lineStarts = createLineStartsFast(text, false);
    let start = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = {
        line: this._lastChangeBufferPos.line,
        column: this._lastChangeBufferPos.column + 1
      };
      start = this._lastChangeBufferPos;
      for (let i = 0; i < lineStarts.length; i++) {
        lineStarts[i] += startOffset + 1;
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += "_" + text;
      startOffset += 1;
    } else {
      if (startOffset !== 0) {
        for (let i = 0; i < lineStarts.length; i++) {
          lineStarts[i] += startOffset;
        }
      }
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
      this._buffers[0].buffer += text;
    }
    const endOffset = this._buffers[0].buffer.length;
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];
    const endPos = { line: endIndex, column: endColumn };
    const newPiece = new Piece(
      0,
      start,
      endPos,
      this.getLineFeedCnt(0, start, endPos),
      endOffset - startOffset
    );
    this._lastChangeBufferPos = endPos;
    return [newPiece];
  }
  getLinesRawContent() {
    return this.getContentOfSubTree(this.root);
  }
  getLineRawContent(lineNumber, endOffset = 0) {
    let x = this.root;
    let ret = "";
    const cache = this._searchCache.get2(lineNumber);
    if (cache) {
      x = cache.node;
      const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);
      const buffer = this._buffers[x.piece.bufferIndex].buffer;
      const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
        ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
      } else {
        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);
        return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
      }
    } else {
      let nodeStartOffset = 0;
      const originalLineNumber = lineNumber;
      while (x !== SENTINEL) {
        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {
          x = x.left;
        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          nodeStartOffset += x.size_left;
          this._searchCache.set({
            node: x,
            nodeStartOffset,
            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
          });
          return buffer.substring(
            startOffset + prevAccumulatedValue,
            startOffset + accumulatedValue - endOffset
          );
        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
          const buffer = this._buffers[x.piece.bufferIndex].buffer;
          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
          ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
          break;
        } else {
          lineNumber -= x.lf_left + x.piece.lineFeedCnt;
          nodeStartOffset += x.size_left + x.piece.length;
          x = x.right;
        }
      }
    }
    x = x.next();
    while (x !== SENTINEL) {
      const buffer = this._buffers[x.piece.bufferIndex].buffer;
      if (x.piece.lineFeedCnt > 0) {
        const accumulatedValue = this.getAccumulatedValue(x, 0);
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);
        return ret;
      } else {
        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);
        ret += buffer.substr(startOffset, x.piece.length);
      }
      x = x.next();
    }
    return ret;
  }
  computeBufferMetadata() {
    let x = this.root;
    let lfCnt = 1;
    let len = 0;
    while (x !== SENTINEL) {
      lfCnt += x.lf_left + x.piece.lineFeedCnt;
      len += x.size_left + x.piece.length;
      x = x.right;
    }
    this._lineCnt = lfCnt;
    this._length = len;
    this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(node, accumulatedValue) {
    const piece = node.piece;
    const pos = this.positionInBuffer(node, accumulatedValue);
    const lineCnt = pos.line - piece.start.line;
    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {
      const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);
      if (realLineCnt !== lineCnt) {
        return { index: realLineCnt, remainder: 0 };
      }
    }
    return { index: lineCnt, remainder: pos.column };
  }
  getAccumulatedValue(node, index) {
    if (index < 0) {
      return 0;
    }
    const piece = node.piece;
    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    const expectedLineStartIndex = piece.start.line + index + 1;
    if (expectedLineStartIndex > piece.end.line) {
      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
    } else {
      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
    }
  }
  deleteNodeTail(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const newEnd = pos;
    const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = newEndOffset - originalEndOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  deleteNodeHead(node, pos) {
    const piece = node.piece;
    const originalLFCnt = piece.lineFeedCnt;
    const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const newStart = pos;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
    const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);
    const lf_delta = newLineFeedCnt - originalLFCnt;
    const size_delta = originalStartOffset - newStartOffset;
    const newLength = piece.length + size_delta;
    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, size_delta, lf_delta);
  }
  shrinkNode(node, start, end) {
    const piece = node.piece;
    const originalStartPos = piece.start;
    const originalEndPos = piece.end;
    const oldLength = piece.length;
    const oldLFCnt = piece.lineFeedCnt;
    const newEnd = start;
    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);
    const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);
    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
    const newPiece = new Piece(
      piece.bufferIndex,
      end,
      originalEndPos,
      this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),
      this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)
    );
    const newNode = this.rbInsertRight(node, newPiece);
    this.validateCRLFWithPrevNode(newNode);
  }
  appendToNode(node, value) {
    if (this.adjustCarriageReturnFromNext(value, node)) {
      value += "\n";
    }
    const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);
    const startOffset = this._buffers[0].buffer.length;
    this._buffers[0].buffer += value;
    const lineStarts = createLineStartsFast(value, false);
    for (let i = 0; i < lineStarts.length; i++) {
      lineStarts[i] += startOffset;
    }
    if (hitCRLF) {
      const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop();
      this._lastChangeBufferPos = {
        line: this._lastChangeBufferPos.line - 1,
        column: startOffset - prevStartOffset
      };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));
    const endIndex = this._buffers[0].lineStarts.length - 1;
    const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];
    const newEnd = { line: endIndex, column: endColumn };
    const newLength = node.piece.length + value.length;
    const oldLineFeedCnt = node.piece.lineFeedCnt;
    const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);
    const lf_delta = newLineFeedCnt - oldLineFeedCnt;
    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
    this._lastChangeBufferPos = newEnd;
    updateTreeMetadata(this, node, value.length, lf_delta);
  }
  nodeAt(offset) {
    let x = this.root;
    const cache = this._searchCache.get(offset);
    if (cache) {
      return {
        node: cache.node,
        nodeStartOffset: cache.nodeStartOffset,
        remainder: offset - cache.nodeStartOffset
      };
    }
    let nodeStartOffset = 0;
    while (x !== SENTINEL) {
      if (x.size_left > offset) {
        x = x.left;
      } else if (x.size_left + x.piece.length >= offset) {
        nodeStartOffset += x.size_left;
        const ret = {
          node: x,
          remainder: offset - x.size_left,
          nodeStartOffset
        };
        this._searchCache.set(ret);
        return ret;
      } else {
        offset -= x.size_left + x.piece.length;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    return null;
  }
  nodeAt2(lineNumber, column) {
    let x = this.root;
    let nodeStartOffset = 0;
    while (x !== SENTINEL) {
      if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {
        x = x.left;
      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);
        nodeStartOffset += x.size_left;
        return {
          node: x,
          remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
          nodeStartOffset
        };
      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);
        if (prevAccumualtedValue + column - 1 <= x.piece.length) {
          return {
            node: x,
            remainder: prevAccumualtedValue + column - 1,
            nodeStartOffset
          };
        } else {
          column -= x.piece.length - prevAccumualtedValue;
          break;
        }
      } else {
        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
        nodeStartOffset += x.size_left + x.piece.length;
        x = x.right;
      }
    }
    x = x.next();
    while (x !== SENTINEL) {
      if (x.piece.lineFeedCnt > 0) {
        const accumulatedValue = this.getAccumulatedValue(x, 0);
        const nodeStartOffset2 = this.offsetOfNode(x);
        return {
          node: x,
          remainder: Math.min(column - 1, accumulatedValue),
          nodeStartOffset: nodeStartOffset2
        };
      } else {
        if (x.piece.length >= column - 1) {
          const nodeStartOffset2 = this.offsetOfNode(x);
          return {
            node: x,
            remainder: column - 1,
            nodeStartOffset: nodeStartOffset2
          };
        } else {
          column -= x.piece.length;
        }
      }
      x = x.next();
    }
    return null;
  }
  nodeCharCodeAt(node, offset) {
    if (node.piece.lineFeedCnt < 1) {
      return -1;
    }
    const buffer = this._buffers[node.piece.bufferIndex];
    const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;
    return buffer.buffer.charCodeAt(newOffset);
  }
  offsetOfNode(node) {
    if (!node) {
      return 0;
    }
    let pos = node.size_left;
    while (node !== this.root) {
      if (node.parent.right === node) {
        pos += node.parent.size_left + node.parent.piece.length;
      }
      node = node.parent;
    }
    return pos;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === "\n");
  }
  startWithLF(val) {
    if (typeof val === "string") {
      return val.charCodeAt(0) === 10;
    }
    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {
      return false;
    }
    const piece = val.piece;
    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;
    const line = piece.start.line;
    const startOffset = lineStarts[line] + piece.start.column;
    if (line === lineStarts.length - 1) {
      return false;
    }
    const nextLineOffset = lineStarts[line + 1];
    if (nextLineOffset > startOffset + 1) {
      return false;
    }
    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
  }
  endWithCR(val) {
    if (typeof val === "string") {
      return val.charCodeAt(val.length - 1) === 13;
    }
    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {
      return false;
    }
    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(nextNode) {
    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {
      const node = nextNode.prev();
      if (this.endWithCR(node)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  validateCRLFWithNextNode(node) {
    if (this.shouldCheckCRLF() && this.endWithCR(node)) {
      const nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        this.fixCRLF(node, nextNode);
      }
    }
  }
  fixCRLF(prev, next) {
    const nodesToDel = [];
    const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;
    let newEnd;
    if (prev.piece.end.column === 0) {
      newEnd = {
        line: prev.piece.end.line - 1,
        column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1
      };
    } else {
      newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
    }
    const prevNewLength = prev.piece.length - 1;
    const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
    updateTreeMetadata(this, prev, -1, -1);
    if (prev.piece.length === 0) {
      nodesToDel.push(prev);
    }
    const newStart = {
      line: next.piece.start.line + 1,
      column: 0
    };
    const newLength = next.piece.length - 1;
    const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);
    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
    updateTreeMetadata(this, next, -1, -1);
    if (next.piece.length === 0) {
      nodesToDel.push(next);
    }
    const pieces = this.createNewPieces("\r\n");
    this.rbInsertRight(prev, pieces[0]);
    for (let i = 0; i < nodesToDel.length; i++) {
      rbDelete(this, nodesToDel[i]);
    }
  }
  adjustCarriageReturnFromNext(value, node) {
    if (this.shouldCheckCRLF() && this.endWithCR(value)) {
      const nextNode = node.next();
      if (this.startWithLF(nextNode)) {
        value += "\n";
        if (nextNode.piece.length === 1) {
          rbDelete(this, nextNode);
        } else {
          const piece = nextNode.piece;
          const newStart = {
            line: piece.start.line + 1,
            column: 0
          };
          const newLength = piece.length - 1;
          const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);
          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
          updateTreeMetadata(this, nextNode, -1, -1);
        }
        return true;
      }
    }
    return false;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(node, callback) {
    if (node === SENTINEL) {
      return callback(SENTINEL);
    }
    const leftRet = this.iterate(node.left, callback);
    if (!leftRet) {
      return leftRet;
    }
    return callback(node) && this.iterate(node.right, callback);
  }
  getNodeContent(node) {
    if (node === SENTINEL) {
      return "";
    }
    const buffer = this._buffers[node.piece.bufferIndex];
    const piece = node.piece;
    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const currentContent = buffer.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  getPieceContent(piece) {
    const buffer = this._buffers[piece.bufferIndex];
    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);
    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);
    const currentContent = buffer.buffer.substring(startOffset, endOffset);
    return currentContent;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(node, p) {
    const z = new TreeNode(p, 1 /* Red */);
    z.left = SENTINEL;
    z.right = SENTINEL;
    z.parent = SENTINEL;
    z.size_left = 0;
    z.lf_left = 0;
    const x = this.root;
    if (x === SENTINEL) {
      this.root = z;
      z.color = 0 /* Black */;
    } else if (node.right === SENTINEL) {
      node.right = z;
      z.parent = node;
    } else {
      const nextNode = leftest(node.right);
      nextNode.left = z;
      z.parent = nextNode;
    }
    fixInsert(this, z);
    return z;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(node, p) {
    const z = new TreeNode(p, 1 /* Red */);
    z.left = SENTINEL;
    z.right = SENTINEL;
    z.parent = SENTINEL;
    z.size_left = 0;
    z.lf_left = 0;
    if (this.root === SENTINEL) {
      this.root = z;
      z.color = 0 /* Black */;
    } else if (node.left === SENTINEL) {
      node.left = z;
      z.parent = node;
    } else {
      const prevNode = righttest(node.left);
      prevNode.right = z;
      z.parent = prevNode;
    }
    fixInsert(this, z);
    return z;
  }
  getContentOfSubTree(node) {
    let str = "";
    this.iterate(node, (node2) => {
      str += this.getNodeContent(node2);
      return true;
    });
    return str;
  }
  // #endregion
};

// src/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts
var UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
function startsWithUTF8BOM(str) {
  return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
}
var PieceTreeTextBufferFactory = class {
  constructor(_chunks, _bom, _cr, _lf, _crlf, _normalizeEOL) {
    this._chunks = _chunks;
    this._bom = _bom;
    this._cr = _cr;
    this._lf = _lf;
    this._crlf = _crlf;
    this._normalizeEOL = _normalizeEOL;
  }
  _getEOL(defaultEOL) {
    const totalEOLCount = this._cr + this._lf + this._crlf;
    const totalCRCount = this._cr + this._crlf;
    if (totalEOLCount === 0) {
      return defaultEOL === 1 /* LF */ ? "\n" : "\r\n";
    }
    if (totalCRCount > totalEOLCount / 2) {
      return "\r\n";
    }
    return "\n";
  }
  create(defaultEOL) {
    const eol = this._getEOL(defaultEOL);
    const chunks = this._chunks;
    if (this._normalizeEOL && (eol === "\r\n" && (this._cr > 0 || this._lf > 0) || eol === "\n" && (this._cr > 0 || this._crlf > 0))) {
      for (let i = 0, len = chunks.length; i < len; i++) {
        const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
        const newLineStart = createLineStartsFast(str);
        chunks[i] = new StringBuffer(str, newLineStart);
      }
    }
    return new PieceTreeBase(chunks, eol, this._normalizeEOL);
  }
  getFirstLineText(lengthLimit) {
    return this._chunks[0].buffer.substr(0, 100).split(/\r\n|\r|\n/)[0];
  }
};
var PieceTreeTextBufferBuilder = class {
  constructor() {
    this.chunks = [];
    this.BOM = "";
    this._hasPreviousChar = false;
    this._previousChar = 0;
    this._tmpLineStarts = [];
    this.cr = 0;
    this.lf = 0;
    this.crlf = 0;
  }
  acceptChunk(chunk) {
    if (chunk.length === 0) {
      return;
    }
    if (this.chunks.length === 0) {
      if (startsWithUTF8BOM(chunk)) {
        this.BOM = UTF8_BOM_CHARACTER;
        chunk = chunk.substr(1);
      }
    }
    const lastChar = chunk.charCodeAt(chunk.length - 1);
    if (lastChar === 13 /* CarriageReturn */ || lastChar >= 55296 && lastChar <= 56319) {
      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);
      this._hasPreviousChar = true;
      this._previousChar = lastChar;
    } else {
      this._acceptChunk1(chunk, false);
      this._hasPreviousChar = false;
      this._previousChar = lastChar;
    }
  }
  _acceptChunk1(chunk, allowEmptyStrings) {
    if (!allowEmptyStrings && chunk.length === 0) {
      return;
    }
    if (this._hasPreviousChar) {
      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);
    } else {
      this._acceptChunk2(chunk);
    }
  }
  _acceptChunk2(chunk) {
    const lineStarts = createLineStarts(this._tmpLineStarts, chunk);
    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));
    this.cr += lineStarts.cr;
    this.lf += lineStarts.lf;
    this.crlf += lineStarts.crlf;
  }
  finish(normalizeEOL = true) {
    this._finish();
    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, normalizeEOL);
  }
  _finish() {
    if (this.chunks.length === 0) {
      this._acceptChunk1("", true);
    }
    if (this._hasPreviousChar) {
      this._hasPreviousChar = false;
      const lastChunk = this.chunks[this.chunks.length - 1];
      lastChunk.buffer += String.fromCharCode(this._previousChar);
      const newLineStarts = createLineStartsFast(lastChunk.buffer);
      lastChunk.lineStarts = newLineStarts;
      if (this._previousChar === 13 /* CarriageReturn */) {
        this.cr++;
      }
    }
  }
};

// src/common/worker.ts
var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
function isInWorkerThread() {
  return isWebWorker;
}

// src/model/command.ts
var BaseCommand = class {
  constructor(model, operation) {
    this.model = model;
    this.operation = operation;
    this.oldPos = { ...model.lastChangeBufferPos };
    this.model.updateLastChangeBufferPos(operation);
    this.newPos = { ...model.lastChangeBufferPos };
  }
  updateBufferPos(isUndo) {
    this.model.lastChangeBufferPos = {
      ...isUndo ? this.oldPos : this.newPos
    };
  }
};
var InsertCommand = class extends BaseCommand {
  execute() {
    this.model.pieceTree.insert(this.operation.rangeOffset, this.operation.newText);
    this.updateBufferPos(false);
  }
  undo() {
    this.model.pieceTree.delete(this.operation.rangeOffset, this.operation.newText.length);
    this.updateBufferPos(true);
  }
};
var DeleteCommand = class extends BaseCommand {
  execute() {
    this.model.pieceTree.delete(this.operation.rangeOffset, this.operation.rangeLength);
    this.updateBufferPos(false);
  }
  undo() {
    this.model.pieceTree.insert(this.operation.rangeOffset, this.operation.oldText);
    this.updateBufferPos(true);
  }
};
var ReplaceCommand = class extends BaseCommand {
  execute() {
    this.model.pieceTree.delete(this.operation.rangeOffset, this.operation.oldText.length);
    this.model.pieceTree.insert(this.operation.rangeOffset, this.operation.newText);
    this.updateBufferPos(false);
  }
  undo() {
    this.model.pieceTree.delete(this.operation.rangeOffset, this.operation.newText.length);
    this.model.pieceTree.insert(this.operation.rangeOffset, this.operation.oldText);
    this.updateBufferPos(true);
  }
};
var MultiCommand = class {
  constructor(model, operation) {
    this.model = model;
    this.operation = operation;
    this.oldPos = { ...model.lastChangeBufferPos };
    this.newPos = { ...model.lastChangeBufferPos };
  }
  execute() {
    for (let i = 0; i < this.operation.length; i++) {
      const op = this.operation[i];
      switch (op.type) {
        case "insert":
          this.model.pieceTree.insert(op.rangeOffset, op.newText);
          break;
        case "delete":
          this.model.pieceTree.delete(op.rangeOffset, op.rangeLength);
          break;
        case "replace":
          this.model.pieceTree.delete(op.rangeOffset, op.oldText.length);
          this.model.pieceTree.insert(op.rangeOffset, op.newText);
          break;
      }
    }
    this.model.lastChangeBufferPos = { ...this.newPos };
  }
  undo() {
    for (let i = this.operation.length - 1; i >= 0; i--) {
      const op = this.operation[i];
      if (op.newText && op.oldText) {
        this.model.pieceTree.delete(op.rangeOffset, op.newText.length);
        this.model.pieceTree.insert(op.rangeOffset, op.oldText);
      } else if (op.newText) {
        this.model.pieceTree.delete(op.rangeOffset, op.newText.length);
      } else {
        this.model.pieceTree.insert(op.rangeOffset, op.oldText);
      }
    }
    this.model.lastChangeBufferPos = { ...this.oldPos };
  }
};

// src/model/jsonModel.ts
var JSONModel = class {
  constructor(value, normalizeEOL = true) {
    this._undoStack = [];
    this._redoStack = [];
    this.MAX_STACK_SIZE = 20;
    this.lastChangeBufferPos = {
      lineNumber: 1,
      column: 1
    };
    this._jsonWorkerManager = null;
    this.emitter = null;
    this._normalizeEOL = normalizeEOL;
    this._pieceTree = this.createTextBuffer(value);
    if (!isInWorkerThread()) {
      this._jsonWorkerManager = getJsonWorkerManager();
      this.emitter = getEmitter();
    }
  }
  get pieceTree() {
    return this._pieceTree;
  }
  createTextBufferFactory(value) {
    const builder = new PieceTreeTextBufferBuilder();
    builder.acceptChunk(value);
    return builder.finish(this._normalizeEOL);
  }
  createTextBuffer(value) {
    return this.createTextBufferFactory(value).create(1 /* LF */);
  }
  /**
   * 获取行数
   * @returns 行数
   */
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  /**
   * 获取行内容
   * @param lineNumber 行号
   * @returns 行内容
   */
  getLineContent(lineNumber) {
    return this._pieceTree.getLineContent(lineNumber);
  }
  /**
   * 获取行长度
   * @param lineNumber 行号
   * @returns 行内容
   */
  getLineLength(lineNumber) {
    return this._pieceTree.getLineLength(lineNumber);
  }
  /**
   * 获取偏移
   * @param lineNumber 行号
   * @param column 列号
   * @returns 行偏移
   */
  getOffsetAt(lineNumber, column) {
    return this._pieceTree.getOffsetAt(lineNumber, column);
  }
  positionAt(offset) {
    offset = Math.min(this._pieceTree.getLength(), Math.max(0, offset));
    return this._pieceTree.getPositionAt(offset);
  }
  _createCommand(op) {
    if (Array.isArray(op)) {
      return new MultiCommand(this, op);
    }
    switch (op.type) {
      case "insert":
        return new InsertCommand(this, op);
      case "delete":
        return new DeleteCommand(this, op);
      case "replace":
        return new ReplaceCommand(this, op);
      default:
        throw new Error("Unknown operation type");
    }
  }
  applyOperation(op) {
    this._redoStack = [];
    const command = this._createCommand(op);
    this.pushUndoStack(command);
    command.execute();
    if (!isInWorkerThread()) {
      this.emitter?.emit("contentChanged", op);
    }
    if (this._jsonWorkerManager) {
      this._jsonWorkerManager.updateModel(op).then((res) => {
        return this._jsonWorkerManager?.validate();
      }).then((result) => {
        this.emitter?.emit("problemsChanged", {
          problems: result.problems,
          root: result.root
        });
      });
    }
  }
  updateLastChangeBufferPos(op) {
    if (op.keepPosition) {
      this.lastChangeBufferPos = op.keepPosition;
      return;
    }
    switch (op.type) {
      case "insert":
        this.lastChangeBufferPos.column += op.newText.length;
        break;
      case "delete":
        if (this.lastChangeBufferPos.column === 1) {
          this.lastChangeBufferPos.lineNumber -= 1;
          this.lastChangeBufferPos.column = this.getLineLength(this.lastChangeBufferPos.lineNumber) + 1;
        } else {
          const startColumn = op.range.startColumn;
          const newColumn2 = op.rangeLength === 1 ? startColumn - 1 : startColumn;
          this.lastChangeBufferPos.column = newColumn2;
        }
        break;
      case "replace":
        const newLineNumber = op.range.startLineNumber;
        const newColumn = op.range.startColumn + op.newText.length;
        this.lastChangeBufferPos.lineNumber = newLineNumber;
        this.lastChangeBufferPos.column = newColumn;
        break;
    }
  }
  pushUndoStack(command) {
    this._undoStack.push(command);
    if (this._undoStack.length > this.MAX_STACK_SIZE) {
      this._undoStack.shift();
    }
  }
  pushRedoStack(command) {
    this._redoStack.push(command);
    if (this._redoStack.length > this.MAX_STACK_SIZE) {
      this._redoStack.shift();
    }
  }
  canUndo() {
    return this._undoStack.length > 0;
  }
  canRedo() {
    return this._redoStack.length > 0;
  }
  undo() {
    if (!this.canUndo()) return;
    const command = this._undoStack.pop();
    command.undo();
    this._redoStack.push(command);
    if (!isInWorkerThread()) {
      this.emitter?.emit("contentChanged", command.operation);
    }
    if (this._jsonWorkerManager) {
      this._jsonWorkerManager.undo().then((res) => {
        return this._jsonWorkerManager?.validate();
      }).then((result) => {
        this.emitter?.emit("problemsChanged", {
          problems: result.problems,
          root: result.root
        });
      });
    }
  }
  redo() {
    if (!this.canRedo()) return;
    const command = this._redoStack.pop();
    command.execute();
    this._undoStack.push(command);
    if (!isInWorkerThread()) {
      this.emitter?.emit("contentChanged", command.operation);
    }
    if (this._jsonWorkerManager) {
      this._jsonWorkerManager.redo().then((res) => {
        return this._jsonWorkerManager?.validate();
      }).then((result) => {
        this.emitter?.emit("problemsChanged", {
          problems: result.problems,
          root: result.root
        });
      });
    }
  }
  /**
   * 获取值
   * @returns 值
   */
  getValue() {
    return this._pieceTree.getValueInRange({
      startLineNumber: 1,
      startColumn: 1,
      endLineNumber: this._pieceTree.getLineCount(),
      endColumn: this._pieceTree.getLineContent(this._pieceTree.getLineCount()).length + 1
    });
  }
  /**
   * 设置值
   * @param value 值
   */
  setValue(value) {
    const builder = new PieceTreeTextBufferBuilder();
    builder.acceptChunk(value);
    this._pieceTree = builder.finish(this._normalizeEOL).create(1);
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  _getEndOfLine(eol) {
    switch (eol) {
      case 1 /* LF */:
        return "\n";
      case 2 /* CRLF */:
        return "\r\n";
      case 0 /* TextDefined */:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  getValueInRange(range, eol = 0 /* TextDefined */) {
    return this._pieceTree.getValueInRange(range, this._getEndOfLine(eol));
  }
  getFullModelRange() {
    const lineCount = this.getLineCount();
    return new Range2(1, 1, lineCount, this.getLineLength(lineCount) + 1);
  }
  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
  }
  /**
   * 查找匹配
   * @param searchString 搜索字符串
   * @param rawSearchScope 搜索范围
   * @param isRegex 是否为正则表达式
   * @param matchCase 是否匹配大小写
   * @param wordSeparators 分隔符
   * @param captureMatches 是否捕获匹配
   * @param limitResultCount 限制结果数量
   * @returns 匹配结果
   * Based on https://github.com/microsoft/vscode with modifications for custom requirements
   */
  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = Infinity) {
    let searchRanges = null;
    if (searchRanges === null) {
      searchRanges = [this.getFullModelRange()];
    }
    searchRanges = searchRanges.sort(
      (d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn
    );
    const uniqueSearchRanges = [];
    uniqueSearchRanges.push(
      searchRanges.reduce((prev, curr) => {
        if (Range2.areIntersecting(prev, curr)) {
          return prev.plusRange(curr);
        }
        uniqueSearchRanges.push(prev);
        return curr;
      })
    );
    let matchMapper;
    if (!isRegex && searchString.indexOf("\n") < 0) {
      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);
      const searchData = searchParams.parseSearchRequest();
      if (!searchData) {
        return [];
      }
      matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
    } else {
      matchMapper = (searchRange) => TextModelSearch.findMatches(
        this,
        new SearchParams(searchString, isRegex, matchCase, wordSeparators),
        searchRange,
        captureMatches,
        limitResultCount
      );
    }
    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);
  }
};

// src/model/index.ts
function createModel(text, normalizeEOL = true) {
  return new JSONModel(text, normalizeEOL);
}

// src/json-viewer/jsonViewer.ts
var JsonViewer = class {
  constructor(container, value, options) {
    this._jsonWorkerManager = null;
    this._id = `jsonviewer-${Math.random().toString(36).substr(2, 9)}`;
    setCurrentNameSpaceId(this._id);
    this.emitter = getEmitter();
    this._container = container;
    this._jsonModel = createModel(value);
    this._jsonWorkerManager = getJsonWorkerManager();
    this._jsonWorkerManager.init(value);
    this._view = new View(container, this._jsonModel, options);
  }
  layout() {
    this._view.layout();
  }
  getModel() {
    return this._jsonModel;
  }
  getSearchWidget() {
    return this._view.searchWidget;
  }
  format() {
    this._view.editWidget.format();
  }
  dispose() {
    disposeEmitter(this._id);
    disposeWorkerManager(this._id);
    this._view.dispose();
  }
};
export {
  JsonViewer
};
